<!DOCTYPE html>
<html lang="default">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="1、配置解析spring容器分为基础容器和扩展容器，我们目前正在使用的基础容器为DefaultListableBeanFactory、扩展容器为AnnotationConfigEmbeddedWebApplicationContext。在创建AnnotationConfigEmbeddedWebAp"/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Spring的IOC及AOP源码"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="1、配置解析spring容器分为基础容器和扩展容器，我们目前正在使用的基础容器为DefaultListableBeanFactory、扩展容器为AnnotationConfigEmbeddedWebApplicationContext。在创建AnnotationConfigEmbeddedWebAp"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>Spring的IOC及AOP源码 - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Spring的IOC及AOP源码</h1>
                    
                    <h2 class="post-subheading">
                        配置解析、bean管理及Aop
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-01-13
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/spring/">spring</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="1、配置解析"><a href="#1、配置解析" class="headerlink" title="1、配置解析"></a>1、配置解析</h3><p>spring容器分为基础容器和扩展容器，我们目前正在使用的基础容器为DefaultListableBeanFactory、扩展容器为AnnotationConfigEmbeddedWebApplicationContext。<br>在创建AnnotationConfigEmbeddedWebApplicationContext容器时，会自动创建一个AnnotatedBeanDefinitionReader的bean的读取器，创建AnnotatedBeanDefinitionReader时<br>会调用AnnotationConfigUtils的registerAnnotationConfigProcessors方法注册配置类的解析器ConfigurationClassPostProcessor。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source) &#123;</span><br><span class="line">      DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">      if (beanFactory != null) &#123;</span><br><span class="line">          if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">              beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">              beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet(8);</span><br><span class="line">      RootBeanDefinition def;</span><br><span class="line">//处理@Configuration注解</span><br><span class="line">      if (!registry.containsBeanDefinition(&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;)) &#123;</span><br><span class="line">          def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">          def.setSource(source);</span><br><span class="line">          beanDefs.add(registerPostProcessor(registry, def, &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//处理@Autowired注解</span><br><span class="line">      if (!registry.containsBeanDefinition(&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;)) &#123;</span><br><span class="line">          def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">          def.setSource(source);</span><br><span class="line">          beanDefs.add(registerPostProcessor(registry, def, &quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">//处理@Required注解</span><br><span class="line">      if (!registry.containsBeanDefinition(&quot;org.springframework.context.annotation.internalRequiredAnnotationProcessor&quot;)) &#123;</span><br><span class="line">          def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">          def.setSource(source);</span><br><span class="line">          beanDefs.add(registerPostProcessor(registry, def, &quot;org.springframework.context.annotation.internalRequiredAnnotationProcessor&quot;));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line">      return beanDefs;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在refresh刷新ApplicationContext容器的时候，AbstractApplicationContext的refresh方法会执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry<br>和BeanFactoryPostProcessor的postProcessBeanFactory方法。ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor接口，processConfigBeanDefinitions方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList();</span><br><span class="line">		//获取所有bean名称</span><br><span class="line">        String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        String[] var4 = candidateNames;</span><br><span class="line">        int var5 = candidateNames.length;</span><br><span class="line">		//获取beanBeanDefinition</span><br><span class="line">        for(int var6 = 0; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            String beanName = var4[var6];</span><br><span class="line">            BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">            if (!ConfigurationClassUtils.isFullConfigurationClass(beanDef) &amp;&amp; !ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">                if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class="line">                    configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                this.logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!configCandidates.isEmpty()) &#123;</span><br><span class="line">			//排序</span><br><span class="line">            Collections.sort(configCandidates, new Comparator&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line">                public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) &#123;</span><br><span class="line">                    int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">                    int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">                    return i1 &lt; i2 ? -1 : (i1 &gt; i2 ? 1 : 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            SingletonBeanRegistry sbr = null;</span><br><span class="line">            if (registry instanceof SingletonBeanRegistry) &#123;</span><br><span class="line">                sbr = (SingletonBeanRegistry)registry;</span><br><span class="line">                if (!this.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;)) &#123;</span><br><span class="line">                    BeanNameGenerator generator = (BeanNameGenerator)sbr.getSingleton(&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;);</span><br><span class="line">                    this.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    this.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);</span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet(configCandidates);</span><br><span class="line">            HashSet alreadyParsed = new HashSet(configCandidates.size());</span><br><span class="line"></span><br><span class="line">            do &#123;</span><br><span class="line">				//解析配置类</span><br><span class="line">                parser.parse(candidates);</span><br><span class="line">                parser.validate();</span><br><span class="line">                Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet(parser.getConfigurationClasses());</span><br><span class="line">                configClasses.removeAll(alreadyParsed);</span><br><span class="line">                if (this.reader == null) &#123;</span><br><span class="line">                    this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">                alreadyParsed.addAll(configClasses);</span><br><span class="line">                candidates.clear();</span><br><span class="line">                if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                    String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">                    Set&lt;String&gt; oldCandidateNames = new HashSet(Arrays.asList(candidateNames));</span><br><span class="line">                    Set&lt;String&gt; alreadyParsedClasses = new HashSet();</span><br><span class="line">                    Iterator var12 = alreadyParsed.iterator();</span><br><span class="line"></span><br><span class="line">                    while(var12.hasNext()) &#123;</span><br><span class="line">                        ConfigurationClass configurationClass = (ConfigurationClass)var12.next();</span><br><span class="line">                        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String[] var23 = newCandidateNames;</span><br><span class="line">                    int var24 = newCandidateNames.length;</span><br><span class="line"></span><br><span class="line">                    for(int var14 = 0; var14 &lt; var24; ++var14) &#123;</span><br><span class="line">                        String candidateName = var23[var14];</span><br><span class="line">                        if (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                            BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                                candidates.add(new BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    candidateNames = newCandidateNames;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while(!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">            if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">                sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;</span><br><span class="line">                ((CachingMetadataReaderFactory)this.metadataReaderFactory).clearCache();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>实际解析配置类的方法为doProcessConfigurationClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  protected final ConfigurationClassParser.SourceClass doProcessConfigurationClass(ConfigurationClass configClass, ConfigurationClassParser.SourceClass sourceClass) throws IOException &#123;</span><br><span class="line">      this.processMemberClasses(configClass, sourceClass);</span><br><span class="line">      Iterator var3 = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, PropertySource.class).iterator();</span><br><span class="line"></span><br><span class="line">      AnnotationAttributes importResource;</span><br><span class="line">      while(var3.hasNext()) &#123;</span><br><span class="line">          importResource = (AnnotationAttributes)var3.next();</span><br><span class="line">          if (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class="line">              this.processPropertySource(importResource);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              this.logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//包路径</span><br><span class="line">      Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">      if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">          Iterator var13 = componentScans.iterator();</span><br><span class="line"></span><br><span class="line">          while(var13.hasNext()) &#123;</span><br><span class="line">              AnnotationAttributes componentScan = (AnnotationAttributes)var13.next();</span><br><span class="line">		//扫描路径加载类</span><br><span class="line">              Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">              Iterator var7 = scannedBeanDefinitions.iterator();</span><br><span class="line"></span><br><span class="line">              while(var7.hasNext()) &#123;</span><br><span class="line">                  BeanDefinitionHolder holder = (BeanDefinitionHolder)var7.next();</span><br><span class="line">                  BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                  if (bdCand == null) &#123;</span><br><span class="line">                      bdCand = holder.getBeanDefinition();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">                      this.parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//@Import注解引入的配置</span><br><span class="line">      this.processImports(configClass, sourceClass, this.getImports(sourceClass), true);</span><br><span class="line">      if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">          importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">          String[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class="line">          Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class="line">          String[] var20 = resources;</span><br><span class="line">          int var21 = resources.length;</span><br><span class="line"></span><br><span class="line">          for(int var22 = 0; var22 &lt; var21; ++var22) &#123;</span><br><span class="line">              String resource = var20[var22];</span><br><span class="line">              String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">              configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//@BeanMethod注解创建的类</span><br><span class="line">      Set&lt;MethodMetadata&gt; beanMethods = this.retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">      Iterator var16 = beanMethods.iterator();</span><br><span class="line"></span><br><span class="line">      while(var16.hasNext()) &#123;</span><br><span class="line">          MethodMetadata methodMetadata = (MethodMetadata)var16.next();</span><br><span class="line">          configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.processInterfaces(configClass, sourceClass);</span><br><span class="line">      if (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">          String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">          if (!superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">              this.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">              return sourceClass.getSuperClass();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中processImports方法处理@Import引入的ImportSelector、ImportBeanDefinitionRegistrar及普通类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, boolean checkForCircularImports) &#123;</span><br><span class="line">    if (!importCandidates.isEmpty()) &#123;</span><br><span class="line">        if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">            this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.importStack.push(configClass);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Iterator var5 = importCandidates.iterator();</span><br><span class="line"></span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    while(true) &#123;</span><br><span class="line">                        while(var5.hasNext()) &#123;</span><br><span class="line">                            ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var5.next();</span><br><span class="line">                            Class candidateClass;</span><br><span class="line">				//处理引入的ImportSelector配置类</span><br><span class="line">                            if (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                                candidateClass = candidate.loadClass();</span><br><span class="line">                                ImportSelector selector = (ImportSelector)BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                                ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">                                if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) &#123;</span><br><span class="line">                                    this.deferredImportSelectors.add(new ConfigurationClassParser.DeferredImportSelectorHolder(configClass, (DeferredImportSelector)selector));</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                                    Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = this.asSourceClasses(importClassNames);</span><br><span class="line">                                    this.processImports(configClass, currentSourceClass, importSourceClasses, false);</span><br><span class="line">                                &#125;</span><br><span class="line">				//处理引入的ImportBeanDefinitionRegistrar配置类</span><br><span class="line">                            &#125; else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                                candidateClass = candidate.loadClass();</span><br><span class="line">                                ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                                ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">                                configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                                //处理引入的普通类</span><br><span class="line">					this.processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException var15) &#123;</span><br><span class="line">                throw var15;</span><br><span class="line">            &#125; catch (Throwable var16) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var16);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                this.importStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类的解析到此就简要介绍完了。</p>
<h3 id="2、Bean的管理"><a href="#2、Bean的管理" class="headerlink" title="2、Bean的管理"></a>2、Bean的管理</h3><h4 id="2-1、Bean的加载"><a href="#2-1、Bean的加载" class="headerlink" title="2.1、Bean的加载"></a>2.1、Bean的加载</h4><p>前文doProcessConfigurationClass方法中、调用ComponentScanAnnotationParser方法parse方法扫描加载类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//包路径</span><br><span class="line">        Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">        if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">            Iterator var13 = componentScans.iterator();</span><br><span class="line"></span><br><span class="line">            while(var13.hasNext()) &#123;</span><br><span class="line">                AnnotationAttributes componentScan = (AnnotationAttributes)var13.next();</span><br><span class="line">				//扫描路径加载类</span><br><span class="line">                Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">                Iterator var7 = scannedBeanDefinitions.iterator();</span><br><span class="line"></span><br><span class="line">                while(var7.hasNext()) &#123;</span><br><span class="line">                    BeanDefinitionHolder holder = (BeanDefinitionHolder)var7.next();</span><br><span class="line">                    BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                    if (bdCand == null) &#123;</span><br><span class="line">                        bdCand = holder.getBeanDefinition();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">                        this.parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>ComponentScanAnnotationParser的parse方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) &#123;</span><br><span class="line">        Assert.state(this.environment != null, &quot;Environment must not be null&quot;);</span><br><span class="line">        Assert.state(this.resourceLoader != null, &quot;ResourceLoader must not be null&quot;);</span><br><span class="line">		//创建扫描器</span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader);</span><br><span class="line">        Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">        boolean useInheritedGenerator = BeanNameGenerator.class == generatorClass;</span><br><span class="line">        scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : (BeanNameGenerator)BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">        ScopedProxyMode scopedProxyMode = (ScopedProxyMode)componentScan.getEnum(&quot;scopedProxy&quot;);</span><br><span class="line">        if (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">            scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;);</span><br><span class="line">            scanner.setScopeMetadataResolver((ScopeMetadataResolver)BeanUtils.instantiateClass(resolverClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;));</span><br><span class="line">		//过滤器</span><br><span class="line">        AnnotationAttributes[] var15 = componentScan.getAnnotationArray(&quot;includeFilters&quot;);</span><br><span class="line">        int var8 = var15.length;</span><br><span class="line"></span><br><span class="line">        int var9;</span><br><span class="line">        AnnotationAttributes filter;</span><br><span class="line">        Iterator var11;</span><br><span class="line">        TypeFilter typeFilter;</span><br><span class="line">        for(var9 = 0; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">            filter = var15[var9];</span><br><span class="line">            var11 = this.typeFiltersFor(filter).iterator();</span><br><span class="line"></span><br><span class="line">            while(var11.hasNext()) &#123;</span><br><span class="line">                typeFilter = (TypeFilter)var11.next();</span><br><span class="line">                scanner.addIncludeFilter(typeFilter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//过滤器</span><br><span class="line">        var15 = componentScan.getAnnotationArray(&quot;excludeFilters&quot;);</span><br><span class="line">        var8 = var15.length;</span><br><span class="line"></span><br><span class="line">        for(var9 = 0; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">            filter = var15[var9];</span><br><span class="line">            var11 = this.typeFiltersFor(filter).iterator();</span><br><span class="line"></span><br><span class="line">            while(var11.hasNext()) &#123;</span><br><span class="line">                typeFilter = (TypeFilter)var11.next();</span><br><span class="line">                scanner.addExcludeFilter(typeFilter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//懒加载</span><br><span class="line">        boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;);</span><br><span class="line">        if (lazyInit) &#123;</span><br><span class="line">            scanner.getBeanDefinitionDefaults().setLazyInit(true);</span><br><span class="line">        &#125;</span><br><span class="line">		//包路径</span><br><span class="line">        Set&lt;String&gt; basePackages = new LinkedHashSet();</span><br><span class="line">        String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;);</span><br><span class="line">        String[] var19 = basePackagesArray;</span><br><span class="line">        int var21 = basePackagesArray.length;</span><br><span class="line"></span><br><span class="line">        int var22;</span><br><span class="line">        for(var22 = 0; var22 &lt; var21; ++var22) &#123;</span><br><span class="line">            String pkg = var19[var22];</span><br><span class="line">            String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg), &quot;,; \t\n&quot;);</span><br><span class="line">            basePackages.addAll(Arrays.asList(tokenized));</span><br><span class="line">        &#125;</span><br><span class="line">		//通过类获取包路径</span><br><span class="line">        Class[] var20 = componentScan.getClassArray(&quot;basePackageClasses&quot;);</span><br><span class="line">        var21 = var20.length;</span><br><span class="line"></span><br><span class="line">        for(var22 = 0; var22 &lt; var21; ++var22) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = var20[var22];</span><br><span class="line">            basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (basePackages.isEmpty()) &#123;</span><br><span class="line">            basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) &#123;</span><br><span class="line">            protected boolean matchClassName(String className) &#123;</span><br><span class="line">                return declaringClass.equals(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		//扫描路径</span><br><span class="line">        return scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ClassPathBeanDefinitionScanner的doScan方法，将bean扫描获取出来并注册到容器中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet();</span><br><span class="line">        String[] var3 = basePackages;</span><br><span class="line">        int var4 = basePackages.length;</span><br><span class="line"></span><br><span class="line">        for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String basePackage = var3[var5];</span><br><span class="line">			//获取包路径下的类并转换成BeanDefinition</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage);</span><br><span class="line">            Iterator var8 = candidates.iterator();</span><br><span class="line"></span><br><span class="line">            while(var8.hasNext()) &#123;</span><br><span class="line">                BeanDefinition candidate = (BeanDefinition)var8.next();</span><br><span class="line">                //设置作用域，默认singleton</span><br><span class="line">				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">				//设置bean名称</span><br><span class="line">                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">                if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">                    this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">				//处理@Lazy、@Primary、@DependsOn等注解</span><br><span class="line">                if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);</span><br><span class="line">                &#125;</span><br><span class="line">				//注册到容器中</span><br><span class="line">                if (this.checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    this.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2、Bean的创建"><a href="#2-2、Bean的创建" class="headerlink" title="2.2、Bean的创建"></a>2.2、Bean的创建</h4><p>AbstractApplicationContext的finishBeanFactoryInitialization方法会调用ConfigurableListableBeanFactory的preInstantiateSingletons方法提前创建单例bean。<br>追踪到ConfigurableListableBeanFactory的doGetBean方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(String name, Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">       //转换bean名称</span><br><span class="line">	final String beanName = this.transformedBeanName(name);</span><br><span class="line">	//从缓存中获取bean</span><br><span class="line">       Object sharedInstance = this.getSingleton(beanName);</span><br><span class="line">       Object bean;</span><br><span class="line">	//创建FactoryBean形式的bean</span><br><span class="line">       if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">           if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">               if (this.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                   this.logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   this.logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">		//正在创建</span><br><span class="line">           if (this.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">               throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">           &#125;</span><br><span class="line">		//优先从父容器中获取</span><br><span class="line">           BeanFactory parentBeanFactory = this.getParentBeanFactory();</span><br><span class="line">           if (parentBeanFactory != null &amp;&amp; !this.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">               String nameToLookup = this.originalBeanName(name);</span><br><span class="line">               if (args != null) &#123;</span><br><span class="line">                   return parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">           &#125;</span><br><span class="line">		//标记该bean正在创建</span><br><span class="line">           if (!typeCheckOnly) &#123;</span><br><span class="line">               this.markBeanAsCreated(beanName);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">			//合并BeanDefinition</span><br><span class="line">               final RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">               this.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">			//检查DependsOn指定的加载顺序</span><br><span class="line">               String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">               String[] var11;</span><br><span class="line">               if (dependsOn != null) &#123;</span><br><span class="line">                   var11 = dependsOn;</span><br><span class="line">                   int var12 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">                   for(int var13 = 0; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">                       String dep = var11[var13];</span><br><span class="line">                       if (this.isDependent(beanName, dep)) &#123;</span><br><span class="line">                           throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       this.registerDependentBean(dep, beanName);</span><br><span class="line"></span><br><span class="line">                       try &#123;</span><br><span class="line">                           this.getBean(dep);</span><br><span class="line">                       &#125; catch (NoSuchBeanDefinitionException var24) &#123;</span><br><span class="line">                           throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;&apos;&quot; + beanName + &quot;&apos; depends on missing bean &apos;&quot; + dep + &quot;&apos;&quot;, var24);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			//单例	</span><br><span class="line">               if (mbd.isSingleton()) &#123;</span><br><span class="line">                   sharedInstance = this.getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                       public Object getObject() throws BeansException &#123;</span><br><span class="line">                           try &#123;</span><br><span class="line">						//创建bean</span><br><span class="line">                               return AbstractBeanFactory.this.createBean(beanName, mbd, args);</span><br><span class="line">                           &#125; catch (BeansException var2) &#123;</span><br><span class="line">                               AbstractBeanFactory.this.destroySingleton(beanName);</span><br><span class="line">                               throw var2;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">               &#125;  </span><br><span class="line">			...省略部分</span><br><span class="line">           &#125; catch (BeansException var26) &#123;</span><br><span class="line">               this.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">               throw var26;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	//类型转换</span><br><span class="line">       if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               return this.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">           &#125; catch (TypeMismatchException var25) &#123;</span><br><span class="line">               if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                   this.logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, var25);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return bean;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>继续追踪到AbstractAutowireCapableBeanFactory的docreateBean方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">  protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">      BeanWrapper instanceWrapper = null;</span><br><span class="line">      if (mbd.isSingleton()) &#123;</span><br><span class="line">          instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">//创建bean</span><br><span class="line">      if (instanceWrapper == null) &#123;</span><br><span class="line">          instanceWrapper = this.createBeanInstance(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final Object bean = instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null;</span><br><span class="line">      Class&lt;?&gt; beanType = instanceWrapper != null ? instanceWrapper.getWrappedClass() : null;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">      synchronized(mbd.postProcessingLock) &#123;</span><br><span class="line">          if (!mbd.postProcessed) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">              &#125; catch (Throwable var17) &#123;</span><br><span class="line">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              mbd.postProcessed = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//提前暴露解决循环依赖</span><br><span class="line">      boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">              this.logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName + &quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          this.addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">              public Object getObject() throws BeansException &#123;</span><br><span class="line">                  return AbstractAutowireCapableBeanFactory.this.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">	//注入属性</span><br><span class="line">          this.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">          if (exposedObject != null) &#123;</span><br><span class="line">		//初始化bean	</span><br><span class="line">              exposedObject = this.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (Throwable var18) &#123;</span><br><span class="line">          if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">              throw (BeanCreationException)var18;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          Object earlySingletonReference = this.getSingleton(beanName, false);</span><br><span class="line">          if (earlySingletonReference != null) &#123;</span><br><span class="line">              if (exposedObject == bean) &#123;</span><br><span class="line">                  exposedObject = earlySingletonReference;</span><br><span class="line">              &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) &#123;</span><br><span class="line">                  String[] dependentBeans = this.getDependentBeans(beanName);</span><br><span class="line">                  Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length);</span><br><span class="line">                  String[] var12 = dependentBeans;</span><br><span class="line">                  int var13 = dependentBeans.length;</span><br><span class="line"></span><br><span class="line">                  for(int var14 = 0; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                      String dependentBean = var12[var14];</span><br><span class="line">                      if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                          actualDependentBeans.add(dependentBean);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                      throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//注册需要执行销毁方法的Bean</span><br><span class="line">      try &#123;</span><br><span class="line">          this.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">          return exposedObject;</span><br><span class="line">      &#125; catch (BeanDefinitionValidationException var16) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这边bean就创建完成了，我们继续查看bean的初始化方法initializeBean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">      if (System.getSecurityManager() != null) &#123;</span><br><span class="line">          AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">              public Object run() &#123;</span><br><span class="line">                  AbstractAutowireCapableBeanFactory.this.invokeAwareMethods(beanName, bean);</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, this.getAccessControlContext());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          this.invokeAwareMethods(beanName, bean);</span><br><span class="line">      &#125;</span><br><span class="line">//执行初始化前处理器</span><br><span class="line">      Object wrappedBean = bean;</span><br><span class="line">      if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">          wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">	//执行afterPropertiesSet及init方法</span><br><span class="line">          this.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">      &#125; catch (Throwable var6) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, &quot;Invocation of init method failed&quot;, var6);</span><br><span class="line">      &#125;</span><br><span class="line">//执行初始化后处理方法，AOP就是在这里完成代理</span><br><span class="line">      if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">          wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return wrappedBean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h3><p>通过@EnableAspectJAutoProxy注解引入动态代理，该注解类通过@Import引入了AspectJAutoProxyRegistrar。<br>AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口它的registerBeanDefinitions方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">       //将AnnotationAwareAspectJAutoProxyCreator添加到容器中</span><br><span class="line">	AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">       AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">	//是否强制使用cglib代理</span><br><span class="line">	if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;</span><br><span class="line">           AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">       &#125;</span><br><span class="line">	//是否对自己暴露代理对象</span><br><span class="line">       if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;</span><br><span class="line">           AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>AnnotationAwareAspectJAutoProxyCreator实现了BeanPostProcessor接口，bean创建完成会调用postProcessAfterInitialization方法完成代理对象的创建<br>父类AbstractAutoProxyCreator中实现了该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">       if (bean != null) &#123;</span><br><span class="line">           Object cacheKey = this.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">           if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			//创建代理对象</span><br><span class="line">               return this.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return bean;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来追踪wrapIfNecessary方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">	//targetSourcedBeans中的bean是提前暴露并且已经被代理过</span><br><span class="line">       if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">           return bean;</span><br><span class="line">	//是否以代理或者无需代理</span><br><span class="line">       &#125; else if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">           return bean;</span><br><span class="line">       &#125; else if (!this.isInfrastructureClass(bean.getClass()) &amp;&amp; !this.shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">           //获取切面</span><br><span class="line">		Object[] specificInterceptors = this.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, (TargetSource)null);</span><br><span class="line">           if (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">               this.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			//创建代理对象</span><br><span class="line">			Object proxy = this.createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">               this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">               return proxy;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">               return bean;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">           return bean;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看看获取切面的方法getAdvicesAndAdvisorsForBean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">       //获取了全部切面</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = this.findCandidateAdvisors();</span><br><span class="line">       //通过Pointcut等信息筛选适用于本对象的切面</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = this.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">       //空方法待实现</span><br><span class="line">	this.extendAdvisors(eligibleAdvisors);</span><br><span class="line">       if (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">           eligibleAdvisors = this.sortAdvisors(eligibleAdvisors);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return eligibleAdvisors;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看创建代理对象的方法createProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line">       if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">           AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)this.beanFactory, beanName, beanClass);</span><br><span class="line">       &#125;</span><br><span class="line">	//代理对象工厂</span><br><span class="line">       ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">       proxyFactory.copyFrom(this);</span><br><span class="line">	//判断使用子类或者接口代理</span><br><span class="line">       if (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">           if (this.shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">               proxyFactory.setProxyTargetClass(true);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               this.evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	//将切面转换成Advisor对象</span><br><span class="line">       Advisor[] advisors = this.buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">       //设置切面</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	//设置代理对象</span><br><span class="line">       proxyFactory.setTargetSource(targetSource);</span><br><span class="line">       this.customizeProxyFactory(proxyFactory);</span><br><span class="line">       proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">       if (this.advisorsPreFiltered()) &#123;</span><br><span class="line">           proxyFactory.setPreFiltered(true);</span><br><span class="line">       &#125;</span><br><span class="line">	//创建代理对象</span><br><span class="line">       return proxyFactory.getProxy(this.getProxyClassLoader());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>继续追踪getProxy方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">	//cglib和jdk的代理工厂分别为CglibAopProxy、JdkDynamicAopProxy</span><br><span class="line">       return this.createAopProxy().getProxy(classLoader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>先看CglibAopProxy的getProxy方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">     if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">//advised为ProxyFactory其中维护了该对象的切面信息</span><br><span class="line">         Class&lt;?&gt; rootClass = this.advised.getTargetClass();</span><br><span class="line">         Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);</span><br><span class="line">         Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">         int x;</span><br><span class="line">//已是代理类</span><br><span class="line">         if (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">             proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">             Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">             Class[] var5 = additionalInterfaces;</span><br><span class="line">             int var6 = additionalInterfaces.length;</span><br><span class="line"></span><br><span class="line">             for(x = 0; x &lt; var6; ++x) &#123;</span><br><span class="line">                 Class&lt;?&gt; additionalInterface = var5[x];</span><br><span class="line">                 this.advised.addInterface(additionalInterface);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         this.validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line">         Enhancer enhancer = this.createEnhancer();</span><br><span class="line">         if (classLoader != null) &#123;</span><br><span class="line">             enhancer.setClassLoader(classLoader);</span><br><span class="line">             if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                 enhancer.setUseCache(false);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">//设置被代理的类</span><br><span class="line">         enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">//被代理类实现的接口</span><br><span class="line">         enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));</span><br><span class="line">         enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">         enhancer.setStrategy(new CglibAopProxy.ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line">//创建callbacks</span><br><span class="line">Callback[] callbacks = this.getCallbacks(rootClass);</span><br><span class="line">         Class&lt;?&gt;[] types = new Class[callbacks.length];</span><br><span class="line"></span><br><span class="line">         for(x = 0; x &lt; types.length; ++x) &#123;</span><br><span class="line">             types[x] = callbacks[x].getClass();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         enhancer.setCallbackFilter(new CglibAopProxy.ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));</span><br><span class="line">         enhancer.setCallbackTypes(types);</span><br><span class="line">         //创建代理对象</span><br><span class="line">return this.createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">     &#125; catch (CodeGenerationException var9) &#123;</span><br><span class="line">         throw new AopConfigException(&quot;Could not generate CGLIB subclass of &quot; + this.advised.getTargetClass() + &quot;: Common causes of this problem include using a final class or a non-visible class&quot;, var9);</span><br><span class="line">     &#125; catch (IllegalArgumentException var10) &#123;</span><br><span class="line">         throw new AopConfigException(&quot;Could not generate CGLIB subclass of &quot; + this.advised.getTargetClass() + &quot;: Common causes of this problem include using a final class or a non-visible class&quot;, var10);</span><br><span class="line">     &#125; catch (Throwable var11) &#123;</span><br><span class="line">         throw new AopConfigException(&quot;Unexpected AOP exception&quot;, var11);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>继续追踪getCallbacks方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception &#123;</span><br><span class="line">       boolean exposeProxy = this.advised.isExposeProxy();</span><br><span class="line">       boolean isFrozen = this.advised.isFrozen();</span><br><span class="line">       boolean isStatic = this.advised.getTargetSource().isStatic();</span><br><span class="line">	//创建拦截器</span><br><span class="line">       Callback aopInterceptor = new CglibAopProxy.DynamicAdvisedInterceptor(this.advised);</span><br><span class="line">       Object targetInterceptor;</span><br><span class="line">       if (exposeProxy) &#123;</span><br><span class="line">           targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedInterceptor(this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Callback targetDispatcher = (Callback)(isStatic ? new CglibAopProxy.StaticDispatcher(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.SerializableNoOp());</span><br><span class="line">       Callback[] mainCallbacks = new Callback[]&#123;aopInterceptor, (Callback)targetInterceptor, new CglibAopProxy.SerializableNoOp(), targetDispatcher, this.advisedDispatcher, new CglibAopProxy.EqualsInterceptor(this.advised), new CglibAopProxy.HashCodeInterceptor(this.advised)&#125;;</span><br><span class="line">       Callback[] callbacks;</span><br><span class="line">	//优化根据fixedInterceptorOffset直接获取拦截器</span><br><span class="line">       if (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">           Method[] methods = rootClass.getMethods();</span><br><span class="line">           Callback[] fixedCallbacks = new Callback[methods.length];</span><br><span class="line">           this.fixedInterceptorMap = new HashMap(methods.length);</span><br><span class="line"></span><br><span class="line">           for(int x = 0; x &lt; methods.length; ++x) &#123;</span><br><span class="line">               List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</span><br><span class="line">               fixedCallbacks[x] = new CglibAopProxy.FixedChainStaticTargetInterceptor(chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());</span><br><span class="line">               this.fixedInterceptorMap.put(methods[x].toString(), x);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">           System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);</span><br><span class="line">           System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">           this.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           callbacks = mainCallbacks;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return callbacks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的拦截器为aopInterceptor（DynamicAdvisedInterceptor），继续看它的intercept方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">	Object oldProxy = null;</span><br><span class="line">	boolean setProxyContext = false;</span><br><span class="line">	Class&lt;?&gt; targetClass = null;</span><br><span class="line">	Object target = null;</span><br><span class="line"></span><br><span class="line">	Object var15;</span><br><span class="line">	try &#123;</span><br><span class="line">		//对自己暴露代理对象</span><br><span class="line">		if (this.advised.exposeProxy) &#123;</span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		target = this.getTarget();</span><br><span class="line">		if (target != null) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		//创建拦截器链</span><br><span class="line">		List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">		Object retVal;</span><br><span class="line">		if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//执行拦截器链</span><br><span class="line">			retVal = (new CglibAopProxy.CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)).proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		//处理返回值</span><br><span class="line">		retVal = CglibAopProxy.processReturnType(proxy, target, method, retVal);</span><br><span class="line">		var15 = retVal;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (target != null) &#123;</span><br><span class="line">			this.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (setProxyContext) &#123;</span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return var15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cglib代理就看完了<br>接下来看JdkDynamicAopProxy的getProxy方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line">	//获取代理对象实现的接口</span><br><span class="line">       Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">       this.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	//创建代理对象，拦截器为this也就是JdkDynamicAopProxy</span><br><span class="line">       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>继续看JdkDynamicAopProxy的invoke方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       Object oldProxy = null;</span><br><span class="line">       boolean setProxyContext = false;</span><br><span class="line">       TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">       Class&lt;?&gt; targetClass = null;</span><br><span class="line">       Object target = null;</span><br><span class="line"></span><br><span class="line">       Object retVal;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">               Boolean var20 = this.equals(args[0]);</span><br><span class="line">               return var20;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">               Integer var18 = this.hashCode();</span><br><span class="line">               return var18;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">               Class var17 = AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">               return var17;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (this.advised.opaque || !method.getDeclaringClass().isInterface() || !method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">			//是否自己暴露代理</span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">                   oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                   setProxyContext = true;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               target = targetSource.getTarget();</span><br><span class="line">               if (target != null) &#123;</span><br><span class="line">                   targetClass = target.getClass();</span><br><span class="line">               &#125;</span><br><span class="line">			//拦截器链</span><br><span class="line">               List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">               if (chain.isEmpty()) &#123;</span><br><span class="line">                   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">				//执行拦截器链</span><br><span class="line">                   MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                   retVal = invocation.proceed();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">               if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                   retVal = proxy;</span><br><span class="line">               &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">                   throw new AopInvocationException(&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Object var13 = retVal;</span><br><span class="line">               return var13;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (setProxyContext) &#123;</span><br><span class="line">               AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return retVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>