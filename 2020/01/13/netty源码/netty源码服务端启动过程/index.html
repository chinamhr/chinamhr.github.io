<!DOCTYPE html>
<html lang="default">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="demonetty服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class EchoServer &amp;#123;    private f"/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="netty源码服务端启动过程"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="demonetty服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class EchoServer &amp;#123;    private f"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>netty源码服务端启动过程 - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>netty源码服务端启动过程</h1>
                    
                    <h2 class="post-subheading">
                        创建工作线程池、启动服务端及处理任务
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-01-13
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/netty/">netty</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>netty服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class EchoServer &#123;</span><br><span class="line">    private final int port;</span><br><span class="line"></span><br><span class="line">    public EchoServer(int port) &#123;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() throws Exception &#123;</span><br><span class="line">        final EchoServerHandler serverHandler = new EchoServerHandler();</span><br><span class="line">        //负责接入连接的线程池</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        //负责处理连接的线程池</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建ServerBootstrap</span><br><span class="line">            ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">            //设置线程池</span><br><span class="line">            b.group(bossGroup,workerGroup)</span><br><span class="line">             //指定channel类型</span><br><span class="line">             .channel(NioServerSocketChannel.class) </span><br><span class="line">             //设置socket地址</span><br><span class="line">             .localAddress(new InetSocketAddress(port))</span><br><span class="line">             //连接初始化器，客户端成功connect后，初始化接入连接的pipeline</span><br><span class="line">             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                    //分隔符解码器</span><br><span class="line">                    ch.pipeline().addLast(&quot;framer&quot;,new DelimiterBasedFrameDecoder(1024, Delimiters.lineDelimiter()));</span><br><span class="line">                    //String解码器，将字节数组反序列化为String对象</span><br><span class="line">                    ch.pipeline().addLast(&quot;decoder&quot;, new StringDecoder());</span><br><span class="line">                    //String编码器，将String对象序列化为字节数组</span><br><span class="line">                    ch.pipeline().addLast(&quot;encoder&quot;, new StringEncoder());</span><br><span class="line">                    //EchoServerHandler是@Sharable的，所以我们可以一直用同一个实例</span><br><span class="line">                    ch.pipeline().addLast(serverHandler); </span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            //异步绑定服务器，sync()一直等到绑定完成</span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            //获得这个Channel的CloseFuture，阻塞当前线程直到关闭操作完成</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //关闭EventLoopGroup，释放所有资源</span><br><span class="line">            bossGroup.shutdownGracefully().sync(); </span><br><span class="line">            workerGroup.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        new EchoServer(12000).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器，将收到的消息发回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Sharable           </span><br><span class="line">//表明一个ChannelHandler可以被多个Channel安全的共享</span><br><span class="line">public class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    //每次收到消息时被调用</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        //把消息打印到控制台</span><br><span class="line">        System.out.println(&quot;Server received: &quot; + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        //将收到的消息写入发送方，不刷新输出消息       </span><br><span class="line">        ctx.write(in);              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override                       </span><br><span class="line">    //用来通知handler上一个ChannelRead()是被这批消息中的最后一个消息调用</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        //刷新缓存的数据到远端，然后关闭Channel</span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override                       </span><br><span class="line">    //在读操作异常被抛出时被调用</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        //打印异常堆栈跟踪消息</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        //关闭这个Channel            </span><br><span class="line">        ctx.close();                        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、创建工作线程池"><a href="#一、创建工作线程池" class="headerlink" title="一、创建工作线程池"></a>一、创建工作线程池</h3><h4 id="1、实例化NioEventLoopGroup"><a href="#1、实例化NioEventLoopGroup" class="headerlink" title="1、实例化NioEventLoopGroup"></a>1、实例化NioEventLoopGroup</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup() &#123;</span><br><span class="line">    this(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads) &#123;</span><br><span class="line">    this(nThreads, (Executor) null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads, Executor executor) &#123;</span><br><span class="line">    this(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup(</span><br><span class="line">        int nThreads, Executor executor, final SelectorProvider selectorProvider) &#123;</span><br><span class="line">    this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,</span><br><span class="line">                         final SelectStrategyFactory selectStrategyFactory) &#123;</span><br><span class="line">    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioEventLoopGroup的父类MultithreadEventLoopGroup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">    //DEFAULT_EVENT_LOOP_THREADS默认为处理器的数量</span><br><span class="line">    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MultithreadEventLoopGroup的父类MultithreadEventExecutorGroup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">protected MultithreadEventExecutorGroup(int nThreads, Executor executor,</span><br><span class="line">                                        EventExecutorChooserFactory chooserFactory, Object... args) &#123;</span><br><span class="line">    if (nThreads &lt;= 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (executor == null) &#123;</span><br><span class="line">        //执行器</span><br><span class="line">        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = new EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    //创建nTreads个NioEventLoop对象保存在children数组中</span><br><span class="line">    for (int i = 0; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        boolean success = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建NioEventLoop对象</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: Think about if this is a good exception type</span><br><span class="line">            throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //如果newChild方法执行失败，则对前面执行new成功的几个NioEventLoop进行shutdown处理</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int j = 0; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException interrupted) &#123;</span><br><span class="line">                        // Let the caller handle the interruption.</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据线程个数是否为2的幂，采用不同策略初始化chooser</span><br><span class="line">    //是2的幂返回PowerOfTwoEventExecutorChooser，否则返回GenericEventExecutorChooser</span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    //线程终止监听器</span><br><span class="line">    final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;</span><br><span class="line">            //线程池线程全部关闭结束，则设置关闭成功</span><br><span class="line">            if (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //添加监听器</span><br><span class="line">    for (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    //只读的线程集合</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、NioEventLoopGroup的newChild方法"><a href="#2、NioEventLoopGroup的newChild方法" class="headerlink" title="2、NioEventLoopGroup的newChild方法"></a>2、NioEventLoopGroup的newChild方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected EventLoop newChild(Executor executor, Object... args) throws Exception &#123;</span><br><span class="line">    return new NioEventLoop(this, executor, (SelectorProvider) args[0],</span><br><span class="line">        ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、实例化NioEventLoop"><a href="#3、实例化NioEventLoop" class="headerlink" title="3、实例化NioEventLoop"></a>3、实例化NioEventLoop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    if (selectorProvider == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;selectorProvider&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (strategy == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;selectStrategy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //选择器工厂</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    //创建selectorTuple</span><br><span class="line">    final SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    //获取选择器，默认SelectedSelectionKeySetSelector</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    //获取nio原生的选择器</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    //默认DefaultSelectStrategy</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioEventLoop的父类SingleThreadEventLoop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor,</span><br><span class="line">                                boolean addTaskWakesUp, int maxPendingTasks,</span><br><span class="line">                                RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    super(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    //任务队列，优先级低于taskQueue</span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SingleThreadEventLoop的父类SingleThreadEventExecutor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,</span><br><span class="line">                                    boolean addTaskWakesUp, int maxPendingTasks,</span><br><span class="line">                                    RejectedExecutionHandler rejectedHandler) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    //添加任务时是否唤醒线程</span><br><span class="line">    this.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    //任务队列大小即未执行的最大任务数</span><br><span class="line">    this.maxPendingTasks = Math.max(16, maxPendingTasks);</span><br><span class="line">    //执行器,ThreadPerTaskExecutor</span><br><span class="line">    this.executor = ObjectUtil.checkNotNull(executor, &quot;executor&quot;);</span><br><span class="line">    //任务队列，LinkedBlockingQueue，优先级低于定时任务</span><br><span class="line">    taskQueue = newTaskQueue(this.maxPendingTasks);</span><br><span class="line">    //拒接策略，默认RejectedExecutionHandler会抛出RejectedExecutionException异常</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、绑定服务器"><a href="#二、绑定服务器" class="headerlink" title="二、绑定服务器"></a>二、绑定服务器</h3><h4 id="1、AbstractBootstrap的bind方法"><a href="#1、AbstractBootstrap的bind方法" class="headerlink" title="1、AbstractBootstrap的bind方法"></a>1、AbstractBootstrap的bind方法</h4><p>ServerBootstrap的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ChannelFuture bind() &#123;</span><br><span class="line">    //校验group、channelFactory是否存在</span><br><span class="line">    validate();</span><br><span class="line">    SocketAddress localAddress = this.localAddress;</span><br><span class="line">    if (localAddress == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;localAddress not set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定端口</span><br><span class="line">    return doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、AbstractBootstrap的doBind方法"><a href="#2、AbstractBootstrap的doBind方法" class="headerlink" title="2、AbstractBootstrap的doBind方法"></a>2、AbstractBootstrap的doBind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">    //初始化并注册NioServerSocketChannel</span><br><span class="line">    final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    final Channel channel = regFuture.channel();</span><br><span class="line">    //检查result是否为CauseHolder（表示失败），是则返回result的cause，否则返回null</span><br><span class="line">    if (regFuture.cause() != null) &#123;</span><br><span class="line">        return regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    //已注册完成</span><br><span class="line">    if (regFuture.isDone()) &#123;</span><br><span class="line">        // At this point we know that the registration was complete and successful.</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        //绑定端口</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        return promise;</span><br><span class="line">    //尚在注册</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Registration future is almost always fulfilled already, but just in case it&apos;s not.</span><br><span class="line">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">        //添加监听器，待注册成功在绑定端口</span><br><span class="line">        regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                if (cause != null) &#123;</span><br><span class="line">                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br><span class="line">                    // IllegalStateException once we try to access the EventLoop of the Channel.</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Registration was successful, so set the correct executor to use.</span><br><span class="line">                    // See https://github.com/netty/netty/issues/2586</span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、AbstractBootstrap的initAndRegister方法"><a href="#3、AbstractBootstrap的initAndRegister方法" class="headerlink" title="3、AbstractBootstrap的initAndRegister方法"></a>3、AbstractBootstrap的initAndRegister方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final ChannelFuture initAndRegister() &#123;</span><br><span class="line">    Channel channel = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建NioServerSocketChannel</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        //初始化channel</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (channel != null) &#123;</span><br><span class="line">            // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br><span class="line">            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br><span class="line">        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    //channel注册到NioEventLoop线程上</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    //cause不为null则注册失败</span><br><span class="line">    if (regFuture.c() != null) &#123;</span><br><span class="line">        //关闭channel</span><br><span class="line">        if (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we are here and the promise is not failed, it&apos;s one of the following cases:</span><br><span class="line">    // 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br><span class="line">    //    i.e. It&apos;s safe to attempt bind() or connect() now because the channel has been registered.</span><br><span class="line">    // 2) If we attempted registration from the other thread, the registration request has been successfully</span><br><span class="line">    //    added to the event loop&apos;s task queue for later execution.</span><br><span class="line">    //    i.e. It&apos;s safe to attempt bind() or connect() now:</span><br><span class="line">    //         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br><span class="line">    //         because register(), bind(), and connect() are all bound to the same thread.</span><br><span class="line"></span><br><span class="line">    return regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、实例化NioServerSocketChannel"><a href="#4、实例化NioServerSocketChannel" class="headerlink" title="4、实例化NioServerSocketChannel"></a>4、实例化NioServerSocketChannel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannel() &#123;</span><br><span class="line">    //newSocket创建ServerSocketChannelImpl</span><br><span class="line">    this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    //config属性</span><br><span class="line">    config = new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioServerSocketChannel的父类AbstractNioChannel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    this.ch = ch;</span><br><span class="line">    //设置SelectionKey.OP_ACCEPT事件</span><br><span class="line">    this.readInterestOp = readInterestOp;</span><br><span class="line">    try &#123;</span><br><span class="line">        //设置非阻塞</span><br><span class="line">        ch.configureBlocking(false);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (IOException e2) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Failed to close a partially initialized socket.&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioChannel的父类AbstractChannel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractChannel(Channel parent) &#123;</span><br><span class="line">    this.parent = parent;</span><br><span class="line">    //创建DefaultChannelId</span><br><span class="line">    id = newId();</span><br><span class="line">    //创建NioMessageUnsafe</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    //创建DefaultChannelPipeline</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、接（二、3）ServerBootstrap的init方法"><a href="#5、接（二、3）ServerBootstrap的init方法" class="headerlink" title="5、接（二、3）ServerBootstrap的init方法"></a>5、接（二、3）ServerBootstrap的init方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">    //获取ServerBootstrap的options</span><br><span class="line">    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    synchronized (options) &#123;</span><br><span class="line">        //设置channel的option</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取ServerBootstrap的attrs</span><br><span class="line">    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    synchronized (attrs) &#123;</span><br><span class="line">        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            //设置channel的attr</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取pipeline,默认为DefaultChannelPipeline</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    //连接处理线程相关属性</span><br><span class="line">    final EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    final ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    synchronized (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将ChannelInitializer加入pipeline，初始化操作后将ChannelInitializer从pipeline中移除</span><br><span class="line">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        //当channel注册到EventLoop后，对这个Channel执行一些初始化操作</span><br><span class="line">        public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">            final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            if (handler != null) &#123;</span><br><span class="line">                //ServerBootstrap中的handler加入pipeline中</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //向Channel注册的NioEventLoop线程中提交一个任务</span><br><span class="line">            ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    //这是一个接入器，接受新请求并交给currentChildGroup线程池处理</span><br><span class="line">                    pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、DefaultChannelPipeline的addLast方法"><a href="#6、DefaultChannelPipeline的addLast方法" class="headerlink" title="6、DefaultChannelPipeline的addLast方法"></a>6、DefaultChannelPipeline的addLast方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final ChannelPipeline addLast(String name, ChannelHandler handler) &#123;</span><br><span class="line">    return addLast(null, name, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">    final AbstractChannelHandlerContext newCtx;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //检查handler是否已添加,是否被@Sharable注解</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        //创建DefaultChannelHandlerContext</span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        //将newCtx加入队列</span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        // If the registered is false it means that the channel was not registered on an eventloop yet.</span><br><span class="line">        // In this case we add the context to the pipeline and add a task that will call</span><br><span class="line">        // ChannelHandler.handlerAdded(...) once the channel is registered.</span><br><span class="line">        //尚未注册</span><br><span class="line">        if (!registered) &#123;</span><br><span class="line">            //handlerState由INIT转换为ADD_PENDING</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            //将ctx封装为PendingHandlerAddedTask加入pendingHandlerCallbackHead队列</span><br><span class="line">            callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取newCtx或channel的线程NioEventLoop</span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        //不是当前线程</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            //向线程中添加任务</span><br><span class="line">            executor.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    //执行handler的handlerAdded</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //执行handler的handlerAdded</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、ChannelInitializer的handlerAdded方法"><a href="#7、ChannelInitializer的handlerAdded方法" class="headerlink" title="7、ChannelInitializer的handlerAdded方法"></a>7、ChannelInitializer的handlerAdded方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    //已注册</span><br><span class="line">    if (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        // This should always be true with our current DefaultChannelPipeline implementation.</span><br><span class="line">        // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span><br><span class="line">        // surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span><br><span class="line">        // will be added in the expected order.</span><br><span class="line">        //初始化方法</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、ChannelInitializer的handlerAdded方法"><a href="#8、ChannelInitializer的handlerAdded方法" class="headerlink" title="8、ChannelInitializer的handlerAdded方法"></a>8、ChannelInitializer的handlerAdded方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</span><br><span class="line">        try &#123;</span><br><span class="line">            //初始化方法</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; catch (Throwable cause) &#123;</span><br><span class="line">            // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span><br><span class="line">            // We do so to prevent multiple calls to initChannel(...).</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //从pipeline中移除自己</span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、接（二、3）MultithreadEventLoopGroup的register方法"><a href="#9、接（二、3）MultithreadEventLoopGroup的register方法" class="headerlink" title="9、接（二、3）MultithreadEventLoopGroup的register方法"></a>9、接（二、3）MultithreadEventLoopGroup的register方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">    //获取线程池中的下一个NioEventLoop线程，注册channel</span><br><span class="line">    return next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、SingleThreadEventLoop的register方法"><a href="#10、SingleThreadEventLoop的register方法" class="headerlink" title="10、SingleThreadEventLoop的register方法"></a>10、SingleThreadEventLoop的register方法</h4><p>NioEventLoop的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">    return register(new DefaultChannelPromise(channel, this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, &quot;promise&quot;);</span><br><span class="line">    //获取NioMessageUnsafe注册promise</span><br><span class="line">    promise.channel().unsafe().register(this, promise);</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、AbstractUnsafe的register方法"><a href="#11、AbstractUnsafe的register方法" class="headerlink" title="11、AbstractUnsafe的register方法"></a>11、AbstractUnsafe的register方法</h4><p>NioMessageUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">    if (eventLoop == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;eventLoop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //已注册</span><br><span class="line">    if (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //检查eventLoop是否为NioEventLoop</span><br><span class="line">    if (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    //判断当前线程是否为该EventLoop中拥有的线程</span><br><span class="line">    if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        //注册promise</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //向NioEventLoop线程中提交一个任务</span><br><span class="line">            eventLoop.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    //注册promise</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    &quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;,</span><br><span class="line">                    AbstractChannel.this, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="12、SingleThreadEventExecutor的execute方法"><a href="#12、SingleThreadEventExecutor的execute方法" class="headerlink" title="12、SingleThreadEventExecutor的execute方法"></a>12、SingleThreadEventExecutor的execute方法</h4><p>NioEventLoop的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(Runnable task) &#123;</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean inEventLoop = inEventLoop();</span><br><span class="line">    //判断当前线程是否为该EventLoop中拥有的线程</span><br><span class="line">    if (inEventLoop) &#123;</span><br><span class="line">        //添加任务</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //启动线程</span><br><span class="line">        startThread();</span><br><span class="line">        //添加任务</span><br><span class="line">        addTask(task);</span><br><span class="line">        //线程已关闭</span><br><span class="line">        if (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            //拒绝任务</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加完任务，唤醒线程</span><br><span class="line">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="13、SingleThreadEventExecutor的startThread方法"><a href="#13、SingleThreadEventExecutor的startThread方法" class="headerlink" title="13、SingleThreadEventExecutor的startThread方法"></a>13、SingleThreadEventExecutor的startThread方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void startThread() &#123;</span><br><span class="line">    //状态为未启动</span><br><span class="line">    if (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        //状态转换为已启动</span><br><span class="line">        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //启动线程</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; catch (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(this, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、SingleThreadEventExecutor的doStartThread方法"><a href="#14、SingleThreadEventExecutor的doStartThread方法" class="headerlink" title="14、SingleThreadEventExecutor的doStartThread方法"></a>14、SingleThreadEventExecutor的doStartThread方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private void doStartThread() &#123;</span><br><span class="line">    assert thread == null;</span><br><span class="line">    //ThreadPerTaskExecutor的execute方法创建一个新的线程</span><br><span class="line">    executor.execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            //中断线程</span><br><span class="line">            if (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean success = false;</span><br><span class="line">            //更新最近执行时间</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理任务</span><br><span class="line">                SingleThreadEventExecutor.this.run();</span><br><span class="line">                success = true;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //线程状态切换为关闭</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    int oldState = state;</span><br><span class="line">                    if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Check if confirmShutdown() was called at the end of the loop.</span><br><span class="line">                if (success &amp;&amp; gracefulShutdownStartTime == 0) &#123;</span><br><span class="line">                    logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; +</span><br><span class="line">                            SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must be called &quot; +</span><br><span class="line">                            &quot;before run() implementation terminates.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // Run all remaining tasks and shutdown hooks.</span><br><span class="line">                    //确认线程是否关闭完成</span><br><span class="line">                    for (;;) &#123;</span><br><span class="line">                        if (confirmShutdown()) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //关闭selector</span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        //将SingleThreadEventExecutor的state设置为ST_TERMINATED</span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);</span><br><span class="line">                        //释放线程锁</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        if (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                            logger.warn(</span><br><span class="line">                                    &quot;An event executor terminated with &quot; +</span><br><span class="line">                                            &quot;non-empty task queue (&quot; + taskQueue.size() + &apos;)&apos;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        terminationFuture.setSuccess(null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、接（二、12）SingleThreadEventExecutor的addTask方法"><a href="#15、接（二、12）SingleThreadEventExecutor的addTask方法" class="headerlink" title="15、接（二、12）SingleThreadEventExecutor的addTask方法"></a>15、接（二、12）SingleThreadEventExecutor的addTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void addTask(Runnable task) &#123;</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //添加任务</span><br><span class="line">    if (!offerTask(task)) &#123;</span><br><span class="line">        //拒绝任务</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、SingleThreadEventExecutor的offerTask方法"><a href="#16、SingleThreadEventExecutor的offerTask方法" class="headerlink" title="16、SingleThreadEventExecutor的offerTask方法"></a>16、SingleThreadEventExecutor的offerTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final boolean offerTask(Runnable task) &#123;</span><br><span class="line">    //线程已关闭</span><br><span class="line">    if (isShutdown()) &#123;</span><br><span class="line">        //拒绝任务</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    //任务添加进任务队列</span><br><span class="line">    return taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、接（二、11）AbstractUnsafe的register0方法"><a href="#17、接（二、11）AbstractUnsafe的register0方法" class="headerlink" title="17、接（二、11）AbstractUnsafe的register0方法"></a>17、接（二、11）AbstractUnsafe的register0方法</h4><p>NioMessageUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // check if the channel is still open as it could be closed in the mean time when the register</span><br><span class="line">        // call was outside of the eventLoop</span><br><span class="line">        //promise已关闭</span><br><span class="line">        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //是否注册过</span><br><span class="line">        boolean firstRegistration = neverRegistered;</span><br><span class="line">        //向当前工作线程的unwrappedSelector上注册关注事件为0，把channel作为Attachment绑定到SelectionKey</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = false;</span><br><span class="line">        registered = true;</span><br><span class="line"></span><br><span class="line">        // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br><span class="line">        // user may already fire events through the pipeline in the ChannelFutureListener.</span><br><span class="line">        //初次注册，执行所有handler的handlerAdded方法</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        //promise设置注册成功，唤醒等待线程，并且广播成功事件，执行监听器的operationComplete方法</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        //从head开始，依次执行handler的channelRegistered方法</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        // Only fire a channelActive if the channel has never been registered. This prevents firing</span><br><span class="line">        // multiple channel actives if the channel is deregistered and re-registered.</span><br><span class="line">        // ServerSocketChannelImpl是否绑定</span><br><span class="line">        if (isActive()) &#123;</span><br><span class="line">            if (firstRegistration) &#123;</span><br><span class="line">                //从head开始，依次执行handler的channelActive</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; else if (config().isAutoRead()) &#123;</span><br><span class="line">                // This channel was registered before and autoRead() is set. This means we need to begin read</span><br><span class="line">                // again so that we process inbound data.</span><br><span class="line">                //</span><br><span class="line">                // See https://github.com/netty/netty/issues/4805</span><br><span class="line">                //注册关注读事件就绪</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // Close the channel directly to avoid FD leak.</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="18、接（二、2）AbstractBootstrap的doBind0方法"><a href="#18、接（二、2）AbstractBootstrap的doBind0方法" class="headerlink" title="18、接（二、2）AbstractBootstrap的doBind0方法"></a>18、接（二、2）AbstractBootstrap的doBind0方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void doBind0(</span><br><span class="line">        final ChannelFuture regFuture, final Channel channel,</span><br><span class="line">        final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line"></span><br><span class="line">    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span><br><span class="line">    // the pipeline in its channelRegistered() implementation.</span><br><span class="line">    //向注册线程提交任务</span><br><span class="line">    channel.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (regFuture.isSuccess()) &#123;</span><br><span class="line">                //NioServerSocketChannel绑定端口</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19、AbstractChannel的bind方法"><a href="#19、AbstractChannel的bind方法" class="headerlink" title="19、AbstractChannel的bind方法"></a>19、AbstractChannel的bind方法</h4><p>NioServerSocketChannel的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="20、DefaultChannelPipeline的bind方法"><a href="#20、DefaultChannelPipeline的bind方法" class="headerlink" title="20、DefaultChannelPipeline的bind方法"></a>20、DefaultChannelPipeline的bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;</span><br><span class="line">    //hadler的队尾</span><br><span class="line">    return tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21、AbstractChannelHandlerContext的bind方法"><a href="#21、AbstractChannelHandlerContext的bind方法" class="headerlink" title="21、AbstractChannelHandlerContext的bind方法"></a>21、AbstractChannelHandlerContext的bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    if (localAddress == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;localAddress&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //已失效</span><br><span class="line">    if (isNotValidPromise(promise, false)) &#123;</span><br><span class="line">        // cancelled</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">    //往前查找第一个outbound类型的handler，默认会查出HeadContext</span><br><span class="line">    final AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    //获取线程</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        //绑定端口</span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        safeExecute(executor, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                next.invokeBind(localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, null);</span><br><span class="line">    &#125;</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22、HeadContext的bind方法"><a href="#22、HeadContext的bind方法" class="headerlink" title="22、HeadContext的bind方法"></a>22、HeadContext的bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void bind(</span><br><span class="line">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line">    //NioMessageUnsafe</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23、AbstractUnsafe的bind方法"><a href="#23、AbstractUnsafe的bind方法" class="headerlink" title="23、AbstractUnsafe的bind方法"></a>23、AbstractUnsafe的bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // See: https://github.com/netty/netty/issues/576</span><br><span class="line">    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress instanceof InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">        // Warn a user about the fact that a non-root user can&apos;t receive a</span><br><span class="line">        // broadcast packet on *nix if the socket is bound on non-wildcard address.</span><br><span class="line">        logger.warn(</span><br><span class="line">                &quot;A non-root user can&apos;t receive a broadcast packet if the socket &quot; +</span><br><span class="line">                &quot;is not bound to a wildcard address; binding to a non-wildcard &quot; +</span><br><span class="line">                &quot;address (&quot; + localAddress + &quot;) anyway as requested.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean wasActive = isActive();</span><br><span class="line">    try &#123;</span><br><span class="line">        //绑定端口</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24、NioServerSocketChannel的bind方法"><a href="#24、NioServerSocketChannel的bind方法" class="headerlink" title="24、NioServerSocketChannel的bind方法"></a>24、NioServerSocketChannel的bind方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doBind(SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">    //判断java版本</span><br><span class="line">    if (PlatformDependent.javaVersion() &gt;= 7) &#123;</span><br><span class="line">        //ServerSocketChannel绑定端口，参数为绑定地址、最大等待连接数量</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、处理任务"><a href="#三、处理任务" class="headerlink" title="三、处理任务"></a>三、处理任务</h3><h4 id="1、NioEventLoop的run方法"><a href="#1、NioEventLoop的run方法" class="headerlink" title="1、NioEventLoop的run方法"></a>1、NioEventLoop的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void run() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //由taskQueue、tailTasks是否为空、选择是否采用阻塞等待的方式获取连接</span><br><span class="line">            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                case SelectStrategy.CONTINUE:</span><br><span class="line">                    continue;</span><br><span class="line">                case SelectStrategy.SELECT:</span><br><span class="line">                    //</span><br><span class="line">                    select(wakenUp.getAndSet(false));</span><br><span class="line"></span><br><span class="line">                    // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</span><br><span class="line">                    // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</span><br><span class="line">                    // overhead. (Selector.wakeup() is an expensive operation.)</span><br><span class="line">                    //</span><br><span class="line">                    // However, there is a race condition in this approach.</span><br><span class="line">                    // The race condition is triggered when &apos;wakenUp&apos; is set to</span><br><span class="line">                    // true too early.</span><br><span class="line">                    //</span><br><span class="line">                    // &apos;wakenUp&apos; is set to true too early if:</span><br><span class="line">                    // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</span><br><span class="line">                    //    &apos;selector.select(...)&apos;. (BAD)</span><br><span class="line">                    // 2) Selector is waken up between &apos;selector.select(...)&apos; and</span><br><span class="line">                    //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</span><br><span class="line">                    //</span><br><span class="line">                    // In the first case, &apos;wakenUp&apos; is set to true and the</span><br><span class="line">                    // following &apos;selector.select(...)&apos; will wake up immediately.</span><br><span class="line">                    // Until &apos;wakenUp&apos; is set to false again in the next round,</span><br><span class="line">                    // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</span><br><span class="line">                    // any attempt to wake up the Selector will fail, too, causing</span><br><span class="line">                    // the following &apos;selector.select(...)&apos; call to block</span><br><span class="line">                    // unnecessarily.</span><br><span class="line">                    //</span><br><span class="line">                    // To fix this problem, we wake up the selector again if wakenUp</span><br><span class="line">                    // is true immediately after selector.select(...).</span><br><span class="line">                    // It is inefficient in that it wakes up the selector for both</span><br><span class="line">                    // the first case (BAD - wake-up required) and the second case</span><br><span class="line">                    // (OK - no wake-up required).</span><br><span class="line"></span><br><span class="line">                    if (wakenUp.get()) &#123;</span><br><span class="line">                        //唤醒selector</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // fall through</span><br><span class="line">                default:</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = 0;</span><br><span class="line">            needsToSelectAgain = false;</span><br><span class="line">            //默认50</span><br><span class="line">            final int ioRatio = this.ioRatio;</span><br><span class="line">            //不考虑IO耗时的占比</span><br><span class="line">            if (ioRatio == 100) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //处理selector中的就绪事件</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // Ensure we always run tasks.</span><br><span class="line">                    //处理任务队列中的任务</span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final long ioStartTime = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // Ensure we always run tasks.</span><br><span class="line">                    final long ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    //处理任务队列中的任务,处理时间为ioTime按比例计算所得，时间用尽则不继续其他处理任务</span><br><span class="line">                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        // Always handle shutdown even if the loop processing threw an exception.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                if (confirmShutdown()) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、NioEventLoop的select方法"><a href="#2、NioEventLoop的select方法" class="headerlink" title="2、NioEventLoop的select方法"></a>2、NioEventLoop的select方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">private void select(boolean oldWakenUp) throws IOException &#123;</span><br><span class="line">    Selector selector = this.selector;</span><br><span class="line">    try &#123;</span><br><span class="line">        int selectCnt = 0;</span><br><span class="line">        long currentTimeNanos = System.nanoTime();</span><br><span class="line">        //计算延迟任务队列中第一个任务的到期执行时间</span><br><span class="line">        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //计算超时时间</span><br><span class="line">            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;</span><br><span class="line">            //已超过，退出循环</span><br><span class="line">            if (timeoutMillis &lt;= 0) &#123;</span><br><span class="line">                if (selectCnt == 0) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</span><br><span class="line">            // Selector#wakeup. So we need to check task queue again before executing select operation.</span><br><span class="line">            // If we don&apos;t, the task might be pended until select operation was timed out.</span><br><span class="line">            // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span><br><span class="line">            //任务队列中发现任务</span><br><span class="line">            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //阻塞等待</span><br><span class="line">            int selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                // - Selected something,</span><br><span class="line">                // - waken up by user, or</span><br><span class="line">                // - the task queue has a pending task.</span><br><span class="line">                // - a scheduled task is ready for processing</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //线程中断</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                // Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span><br><span class="line">                // As this is most likely a bug in the handler of the user or it&apos;s client library we will</span><br><span class="line">                // also log it.</span><br><span class="line">                //</span><br><span class="line">                // See https://github.com/netty/netty/issues/2426</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Selector.select() returned prematurely because &quot; +</span><br><span class="line">                            &quot;Thread.currentThread().interrupt() was called. Use &quot; +</span><br><span class="line">                            &quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long time = System.nanoTime();</span><br><span class="line">            //selector的select已等待了timeoutMillis长的时间</span><br><span class="line">            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                // timeoutMillis elapsed without anything selected.</span><br><span class="line">                selectCnt = 1;</span><br><span class="line">            //selectCnt大于512，说明循环了512次，使用rebuildSelector来消除select(timeout)不会阻塞的bug</span><br><span class="line">            &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                // The selector returned prematurely many times in a row.</span><br><span class="line">                // Rebuild the selector to work around the problem.</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,</span><br><span class="line">                        selectCnt, selector);</span><br><span class="line"></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = this.selector;</span><br><span class="line"></span><br><span class="line">                // Select again to populate selectedKeys.</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;,</span><br><span class="line">                        selectCnt - 1, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(CancelledKeyException.class.getSimpleName() + &quot; raised by a Selector &#123;&#125; - JDK bug?&quot;,</span><br><span class="line">                    selector, e);</span><br><span class="line">        &#125;</span><br><span class="line">        // Harmless exception - log anyway</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、接（三、1）NioEventLoop的processSelectedKeys方法"><a href="#3、接（三、1）NioEventLoop的processSelectedKeys方法" class="headerlink" title="3、接（三、1）NioEventLoop的processSelectedKeys方法"></a>3、接（三、1）NioEventLoop的processSelectedKeys方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectedKeys() &#123;</span><br><span class="line">    //selectedKeys为封装以后的就绪事件的selectedKey集合</span><br><span class="line">    if (selectedKeys != null) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //未封装直接获取selector的selectedKey集合</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、NioEventLoop的processSelectedKeysOptimized方法"><a href="#4、NioEventLoop的processSelectedKeysOptimized方法" class="headerlink" title="4、NioEventLoop的processSelectedKeysOptimized方法"></a>4、NioEventLoop的processSelectedKeysOptimized方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectedKeysOptimized() &#123;</span><br><span class="line">    for (int i = 0; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        //就绪的事件的SelectionKey</span><br><span class="line">        final SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        // null out entry in the array to allow to have it GC&apos;ed once the Channel close</span><br><span class="line">        // See https://github.com/netty/netty/issues/2363</span><br><span class="line">        selectedKeys.keys[i] = null;</span><br><span class="line">        //获取key关联的对象</span><br><span class="line">        final Object a = k.attachment();</span><br><span class="line">        //key关联两种不同类型的对象，一种是AbstractNioChannel，一种是NioTask </span><br><span class="line">        if (a instanceof AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果需要重新select,取消的SelectionKey个数大于256</span><br><span class="line">        if (needsToSelectAgain) &#123;</span><br><span class="line">            // null out entries in the array to allow to have it GC&apos;ed once the Channel close</span><br><span class="line">            // See https://github.com/netty/netty/issues/2363</span><br><span class="line">            selectedKeys.reset(i + 1);</span><br><span class="line">            //重新执行selector的selectNow</span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、NioEventLoop的processSelectedKey方法"><a href="#5、NioEventLoop的processSelectedKey方法" class="headerlink" title="5、NioEventLoop的processSelectedKey方法"></a>5、NioEventLoop的processSelectedKey方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;</span><br><span class="line">    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    //SelectionKey已失效，则关闭channel</span><br><span class="line">    if (!k.isValid()) &#123;</span><br><span class="line">        final EventLoop eventLoop;</span><br><span class="line">        try &#123;</span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; catch (Throwable ignored) &#123;</span><br><span class="line">            // If the channel implementation throws an exception because there is no event loop, we ignore this</span><br><span class="line">            // because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br><span class="line">            // to close ch.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br><span class="line">        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br><span class="line">        // still healthy and should not be closed.</span><br><span class="line">        // See https://github.com/netty/netty/issues/5125</span><br><span class="line">        if (eventLoop != this || eventLoop == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // close the channel if the key is not valid anymore</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        int readyOps = k.readyOps();</span><br><span class="line">        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br><span class="line">        // the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br><span class="line">        //如果CONNECT就绪</span><br><span class="line">        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br><span class="line">            // See https://github.com/netty/netty/issues/924</span><br><span class="line">            int ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            //移除对OP_CONNECT的关注</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            //处理连接接入</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br><span class="line">        //如果WRITE就绪</span><br><span class="line">        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123;</span><br><span class="line">            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br><span class="line">            //刷新数据到客户端</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br><span class="line">        // to a spin loop</span><br><span class="line">        //如果READ或ACCEPT就绪，检查是否为0，解决JDK可能会产生死循环的一个bug</span><br><span class="line">        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</span><br><span class="line">            //读取数据</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（三、1）SingleThreadEventExecutor的runAllTasks方法"><a href="#6、接（三、1）SingleThreadEventExecutor的runAllTasks方法" class="headerlink" title="6、接（三、1）SingleThreadEventExecutor的runAllTasks方法"></a>6、接（三、1）SingleThreadEventExecutor的runAllTasks方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAllTasks() &#123;</span><br><span class="line">    assert inEventLoop();</span><br><span class="line">    boolean fetchedAll;</span><br><span class="line">    boolean ranAtLeastOne = false;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        //将要执行的定时任务加入taskQueue</span><br><span class="line">        fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">        //执行taskQueue中的任务</span><br><span class="line">        if (runAllTasksFrom(taskQueue)) &#123;</span><br><span class="line">            ranAtLeastOne = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (!fetchedAll); // keep on processing until we fetched all scheduled tasks.</span><br><span class="line">    //更新最新执行时间</span><br><span class="line">    if (ranAtLeastOne) &#123;</span><br><span class="line">        lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    afterRunningAllTasks();</span><br><span class="line">    return ranAtLeastOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、SingleThreadEventExecutor的pollScheduledTask方法"><a href="#7、SingleThreadEventExecutor的pollScheduledTask方法" class="headerlink" title="7、SingleThreadEventExecutor的pollScheduledTask方法"></a>7、SingleThreadEventExecutor的pollScheduledTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean fetchFromScheduledTaskQueue() &#123;</span><br><span class="line">    long nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">    //获取执行时间小于nanoTime的任务</span><br><span class="line">    Runnable scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    //scheduledTask加入taskQueue</span><br><span class="line">    while (scheduledTask != null) &#123;</span><br><span class="line">        if (!taskQueue.offer(scheduledTask)) &#123;</span><br><span class="line">            // No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span><br><span class="line">            scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、接（三、6）SingleThreadEventExecutor的runAllTasksFrom方法"><a href="#8、接（三、6）SingleThreadEventExecutor的runAllTasksFrom方法" class="headerlink" title="8、接（三、6）SingleThreadEventExecutor的runAllTasksFrom方法"></a>8、接（三、6）SingleThreadEventExecutor的runAllTasksFrom方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) &#123;</span><br><span class="line">    //获取任务</span><br><span class="line">    Runnable task = pollTaskFrom(taskQueue);</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //执行任务，执行task的run方法</span><br><span class="line">        safeExecute(task);</span><br><span class="line">        //获取任务</span><br><span class="line">        task = pollTaskFrom(taskQueue);</span><br><span class="line">        if (task == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、阻塞"><a href="#四、阻塞" class="headerlink" title="四、阻塞"></a>四、阻塞</h3><h4 id="1、DefaultChannelPromise的sync方法"><a href="#1、DefaultChannelPromise的sync方法" class="headerlink" title="1、DefaultChannelPromise的sync方法"></a>1、DefaultChannelPromise的sync方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Promise&lt;V&gt; sync() throws InterruptedException &#123;</span><br><span class="line">    //阻塞</span><br><span class="line">    await();</span><br><span class="line">    //cause存在则表示失败，抛出异常</span><br><span class="line">    rethrowIfFailed();</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、DefaultPromise的await方法"><a href="#2、DefaultPromise的await方法" class="headerlink" title="2、DefaultPromise的await方法"></a>2、DefaultPromise的await方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Promise&lt;V&gt; await() throws InterruptedException &#123;</span><br><span class="line">    //检查result确定是否处理完成</span><br><span class="line">    if (isDone()) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Thread.interrupted()) &#123;</span><br><span class="line">        throw new InterruptedException(toString());</span><br><span class="line">    &#125;</span><br><span class="line">    //检查线程</span><br><span class="line">    checkDeadLock();</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        while (!isDone()) &#123;</span><br><span class="line">            //等待次数加一</span><br><span class="line">            incWaiters();</span><br><span class="line">            try &#123;</span><br><span class="line">                //等待</span><br><span class="line">                wait();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //等待次数减一</span><br><span class="line">                decWaiters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>