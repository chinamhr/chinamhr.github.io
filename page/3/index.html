<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-zookeeper源码/zookeeper源码客户端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/zookeeper源码/zookeeper源码客户端/" class="article-date">
  <time datetime="2018-04-07T04:44:43.474Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/zookeeper源码/zookeeper源码客户端/">zookeeper源码客户端</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper源码客户端"><a href="#zookeeper源码客户端" class="headerlink" title="zookeeper源码客户端"></a>zookeeper源码客户端</h2><h3 id="客户端Demo"><a href="#客户端Demo" class="headerlink" title="客户端Demo"></a>客户端Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">//参数1 路径，参数2 内容，参数3 权限，参数4 类型</span><br><span class="line">String znodePath = zk.create(&quot;/demo&quot;, &quot;hello zookeeper&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">   	CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">//判断/java节点是否存在，并且给它注册一个监听器，这个监听器只能监听一次，监听到一次事件后就会失效  </span><br><span class="line">   zk.exists(&quot;/demo&quot;, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="一、建立连接过程"><a href="#一、建立连接过程" class="headerlink" title="一、建立连接过程"></a>一、建立连接过程</h3><h4 id="1、实例化ZooKeeper"><a href="#1、实例化ZooKeeper" class="headerlink" title="1、实例化ZooKeeper"></a>1、实例化ZooKeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   // connectString 连接字符串 如&quot;192.168.12.1:2181,192.168.12.2:2181,192.168.12.3:2181/root&quot;  </span><br><span class="line">   // sessionTimeout 客户端提议的session有效时间</span><br><span class="line">public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,</span><br><span class="line">           boolean canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">           ZKClientConfig clientConfig) throws IOException &#123;</span><br><span class="line">       LOG.info(&quot;Initiating client connection, connectString=&quot; + connectString</span><br><span class="line">               + &quot; sessionTimeout=&quot; + sessionTimeout + &quot; watcher=&quot; + watcher);</span><br><span class="line"></span><br><span class="line">       if (clientConfig == null) &#123;</span><br><span class="line">           clientConfig = new ZKClientConfig();</span><br><span class="line">       &#125;</span><br><span class="line">       this.clientConfig = clientConfig;</span><br><span class="line"></span><br><span class="line">       //创建Watcher监听器的管理器</span><br><span class="line">       watchManager = defaultWatchManager();</span><br><span class="line"></span><br><span class="line">       //设置默认的Watcher监听器</span><br><span class="line">       watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">       ConnectStringParser connectStringParser = new ConnectStringParser(</span><br><span class="line">               connectString);</span><br><span class="line"></span><br><span class="line">       hostProvider = aHostProvider;</span><br><span class="line"></span><br><span class="line">       //客户端负责与服务端通信的对象</span><br><span class="line">       cnxn = new ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">               hostProvider, sessionTimeout, this, watchManager,</span><br><span class="line">               getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">       cnxn.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、实例化ClientCnxn"><a href="#2、实例化ClientCnxn" class="headerlink" title="2、实例化ClientCnxn"></a>2、实例化ClientCnxn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">       this.zooKeeper = zooKeeper;</span><br><span class="line">       this.watcher = watcher;</span><br><span class="line">       this.sessionId = sessionId; //初始值为0</span><br><span class="line">       this.sessionPasswd = sessionPasswd; //初始值为 new byte[16]</span><br><span class="line">       this.sessionTimeout = sessionTimeout;</span><br><span class="line">       this.hostProvider = hostProvider;</span><br><span class="line">       this.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.size();//hostProvider.size() 服务端地址个数</span><br><span class="line">       readTimeout = sessionTimeout * 2 / 3;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">	//发送和接收socket数据的线程</span><br><span class="line">       sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line"></span><br><span class="line">       //事件线程</span><br><span class="line">       eventThread = new EventThread();</span><br><span class="line"></span><br><span class="line">       this.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、SendThread的run方法"><a href="#3、SendThread的run方法" class="headerlink" title="3、SendThread的run方法"></a>3、SendThread的run方法</h4><p>ClientCnxn 的start方法 会分别启动SendThread、EventThread、SendThread的run方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    //更新最近接受和发送时间</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    int to;</span><br><span class="line">    long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">    InetSocketAddress serverAddress = null;</span><br><span class="line">    while (state.isAlive()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//判断是否完成连接</span><br><span class="line">            if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                判断是否关闭</span><br><span class="line">                if (closing) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //若之前连接过只读服务器，直接用上次查找出的读写服务器地址连接</span><br><span class="line">                if (rwServerAddress != null) &#123;</span><br><span class="line">                    serverAddress = rwServerAddress;</span><br><span class="line">                    rwServerAddress = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//获取下一个服务端地址 延迟1s返回</span><br><span class="line">                    serverAddress = hostProvider.next(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                //连接服务端</span><br><span class="line">                startConnect(serverAddress);</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            判断是否已连接</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                // determine whether we need to send an AuthFailed event.</span><br><span class="line">                if (zooKeeperSaslClient != null) &#123;</span><br><span class="line">                	...</span><br><span class="line">                    //进行sasl权限验证</span><br><span class="line">                &#125;</span><br><span class="line">                //超时剩余时间</span><br><span class="line">                to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	//超时剩余时间</span><br><span class="line">                to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //to &lt;= 0 则说明连接超时</span><br><span class="line">            if (to &lt;= 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //打印日志抛出异常</span><br><span class="line">                throw new SessionTimeoutException(warnInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果已连接  定时发送心跳检测</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - </span><br><span class="line">                		((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);</span><br><span class="line">                if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                    //发送ping数据</span><br><span class="line">                    sendPing();</span><br><span class="line">                    clientCnxnSocket.updateLastSend();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (timeToNextPing &lt; to) &#123;</span><br><span class="line">                        to = timeToNextPing;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果连接的是只读服务器</span><br><span class="line">            if (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                long now = Time.currentElapsedTime();</span><br><span class="line">                int idlePingRwServer = (int) (now - lastPingRwServer);</span><br><span class="line">                if (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                    lastPingRwServer = now;</span><br><span class="line">                    idlePingRwServer = 0;</span><br><span class="line">                    pingRwTimeout =</span><br><span class="line">                        Math.min(2*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                    //寻找读写服务器，抛出异常，重新连接</span><br><span class="line">                    pingRwServer();</span><br><span class="line">                &#125;</span><br><span class="line">                to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理与客户端的通信</span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (closing) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //跳出主循环，结束线程</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (state) &#123;</span><br><span class="line">        断开连接，处理队列中的数据包</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    关闭socket</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    if (state.isAlive()) &#123;</span><br><span class="line">    	//添加断开连接事件</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(Event.EventType.None,</span><br><span class="line">                Event.KeeperState.Disconnected, null));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、startConnect方法连接服务端"><a href="#4、startConnect方法连接服务端" class="headerlink" title="4、startConnect方法连接服务端"></a>4、startConnect方法连接服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startConnect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    客户端状态更新为正在连接</span><br><span class="line">    state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">    //连接服务端</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、ClientCnxnSocketNIO中的connect方法"><a href="#5、ClientCnxnSocketNIO中的connect方法" class="headerlink" title="5、ClientCnxnSocketNIO中的connect方法"></a>5、ClientCnxnSocketNIO中的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void connect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line">       SocketChannel sock = createSock();</span><br><span class="line">       try &#123;</span><br><span class="line">          registerAndConnect(sock, addr);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">           sock.close();</span><br><span class="line">           throw e;</span><br><span class="line">       &#125;</span><br><span class="line">       //未初始化</span><br><span class="line">       initialized = false;</span><br><span class="line">       //清空缓存区</span><br><span class="line">       lenBuffer.clear();</span><br><span class="line">       incomingBuffer = lenBuffer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、调用了registerAndConnect方法"><a href="#6、调用了registerAndConnect方法" class="headerlink" title="6、调用了registerAndConnect方法"></a>6、调用了registerAndConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void registerAndConnect(SocketChannel sock, InetSocketAddress addr) </span><br><span class="line">   throws IOException &#123;</span><br><span class="line">   	//向selector注册SocketChannel指定OP_CONNECT事件</span><br><span class="line">       sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">       //连接服务器</span><br><span class="line">       boolean immediateConnect = sock.connect(addr);</span><br><span class="line">       if (immediateConnect) &#123;</span><br><span class="line">           sendThread.primeConnection();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、SendThread的primeConnection方法"><a href="#7、SendThread的primeConnection方法" class="headerlink" title="7、SendThread的primeConnection方法"></a>7、SendThread的primeConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void primeConnection() throws IOException &#123;</span><br><span class="line">       isFirstConnect = false;</span><br><span class="line">       若之前连接过只读服务器，则使用之前的sessionId</span><br><span class="line">       long sessId = (seenRwServerBefore) ? sessionId : 0;</span><br><span class="line">       创建连接请求对象</span><br><span class="line">       ConnectRequest conReq = new ConnectRequest(0, lastZxid,</span><br><span class="line">               sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">      </span><br><span class="line">       //重新连接将已有的监听器注册到服务器</span><br><span class="line">       if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) &#123;</span><br><span class="line">       	//类是否存在监听器</span><br><span class="line">           List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();</span><br><span class="line">           //数据变化监听器</span><br><span class="line">           List&lt;String&gt; existWatches = zooKeeper.getExistWatches();</span><br><span class="line">           //子节点变化监听器</span><br><span class="line">           List&lt;String&gt; childWatches = zooKeeper.getChildWatches();</span><br><span class="line">           if (!dataWatches.isEmpty()</span><br><span class="line">                   || !existWatches.isEmpty() || !childWatches.isEmpty()) &#123;</span><br><span class="line">               Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();</span><br><span class="line">               long setWatchesLastZxid = lastZxid;</span><br><span class="line"></span><br><span class="line">               while (dataWatchesIter.hasNext()</span><br><span class="line">                      || existWatchesIter.hasNext() || childWatchesIter.hasNext()) &#123;</span><br><span class="line">                   List&lt;String&gt; dataWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; existWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; childWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   int batchLength = 0;</span><br><span class="line"></span><br><span class="line">                   while (batchLength &lt; SET_WATCHES_MAX_LENGTH) &#123;</span><br><span class="line">                       final String watch;</span><br><span class="line">                       if (dataWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = dataWatchesIter.next();</span><br><span class="line">                           dataWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (existWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = existWatchesIter.next();</span><br><span class="line">                           existWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (childWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = childWatchesIter.next();</span><br><span class="line">                           childWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                       batchLength += watch.length();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   SetWatches sw = new SetWatches(setWatchesLastZxid,</span><br><span class="line">                                                  dataWatchesBatch,</span><br><span class="line">                                                  existWatchesBatch,</span><br><span class="line">                                                  childWatchesBatch);</span><br><span class="line">                   RequestHeader header = new RequestHeader(-8, OpCode.setWatches);</span><br><span class="line">                   Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);</span><br><span class="line">                   outgoingQueue.addFirst(packet);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       //新建一个数据包，加入发送队列</span><br><span class="line">       outgoingQueue.addFirst(new Packet(null, null, conReq,</span><br><span class="line">               null, null, readOnly));</span><br><span class="line">       //该方法修改SocketChannel指定事件为读和写</span><br><span class="line">       clientCnxnSocket.connectionPrimed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、ClientCnxnSocketNIO的doTransport方法"><a href="#8、ClientCnxnSocketNIO的doTransport方法" class="headerlink" title="8、ClientCnxnSocketNIO的doTransport方法"></a>8、ClientCnxnSocketNIO的doTransport方法</h4><p>读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void doTransport(int waitTimeOut, List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">           throws IOException, InterruptedException &#123;</span><br><span class="line">       selector.select(waitTimeOut);</span><br><span class="line">       Set&lt;SelectionKey&gt; selected;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           selected = selector.selectedKeys();</span><br><span class="line">       &#125;</span><br><span class="line">       updateNow();</span><br><span class="line">       for (SelectionKey k : selected) &#123;</span><br><span class="line">           SocketChannel sc = ((SocketChannel) k.channel());</span><br><span class="line">           //连接事件未就绪</span><br><span class="line">           if ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">               if (sc.finishConnect()) &#123;</span><br><span class="line">                   updateLastSendAndHeard();</span><br><span class="line">                   更新服务端地址</span><br><span class="line">                   updateSocketAddresses();</span><br><span class="line">                   连接服务端</span><br><span class="line">                   sendThread.primeConnection();</span><br><span class="line">               &#125;</span><br><span class="line">            //读写事件就绪</span><br><span class="line">           &#125; else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) &#123;</span><br><span class="line">               处理通信数据</span><br><span class="line">               doIO(pendingQueue, cnxn);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sendThread.getZkState().isConnected()) &#123;</span><br><span class="line">       	//找出可以在sasl认证之前可以预先发送的请求</span><br><span class="line">           if (findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       selected.clear();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9、ClientCnxnSocketNIO的doIO方法"><a href="#9、ClientCnxnSocketNIO的doIO方法" class="headerlink" title="9、ClientCnxnSocketNIO的doIO方法"></a>9、ClientCnxnSocketNIO的doIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">     throws InterruptedException, IOException &#123;</span><br><span class="line">       SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">       if (sock == null) &#123;</span><br><span class="line">           throw new IOException(&quot;Socket is null!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //就绪事件为读事件</span><br><span class="line">       if (sockKey.isReadable()) &#123;</span><br><span class="line">           int rc = sock.read(incomingBuffer);</span><br><span class="line">           if (rc &lt; 0) &#123;</span><br><span class="line">               throw new EndOfStreamException(</span><br><span class="line">                       &quot;Unable to read additional data from server sessionid 0x&quot;</span><br><span class="line">                               + Long.toHexString(sessionId)</span><br><span class="line">                               + &quot;, likely server has closed socket&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           //incomingBuffer是否还有空间</span><br><span class="line">           if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">               incomingBuffer.flip();</span><br><span class="line">               //如果incomingBuffer和lenBuffer指向同一个byteBuffer，说明是新请求的第一次读 </span><br><span class="line">               if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">               	请求次数增加</span><br><span class="line">                   recvCount++;</span><br><span class="line">                   //incomingBuffer缓存区初始化</span><br><span class="line">                   readLength();</span><br><span class="line">               &#125; else if (!initialized) &#123;</span><br><span class="line">               	//读取服务端的连接请求返回</span><br><span class="line">                   readConnectResult();</span><br><span class="line">                   enableRead();</span><br><span class="line">                   if (findSendablePacket(outgoingQueue,</span><br><span class="line">                           sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">                       enableWrite();</span><br><span class="line">                   &#125;</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">                   initialized = true;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               	//读取服务端的其他请求返回</span><br><span class="line">                   sendThread.readResponse(incomingBuffer);</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sockKey.isWritable()) &#123;</span><br><span class="line">       	//查找可发送的数据包</span><br><span class="line">           Packet p = findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress());</span><br><span class="line"></span><br><span class="line">           if (p != null) &#123;</span><br><span class="line">               updateLastSend();</span><br><span class="line">               // If we already started writing p, p.bb will already exist</span><br><span class="line">               if (p.bb == null) &#123;</span><br><span class="line">                   if ((p.requestHeader != null) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.auth)) &#123;</span><br><span class="line">                       p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                   &#125;</span><br><span class="line">                   p.createBB();</span><br><span class="line">               &#125;</span><br><span class="line">               //发送数据</span><br><span class="line">               sock.write(p.bb);</span><br><span class="line">               if (!p.bb.hasRemaining()) &#123;</span><br><span class="line">                   sentCount++;</span><br><span class="line">                   outgoingQueue.removeFirstOccurrence(p);</span><br><span class="line">                   if (p.requestHeader != null</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.ping</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</span><br><span class="line">                       synchronized (pendingQueue) &#123;</span><br><span class="line">                       	//把包裹加入到等待服务端返回队列</span><br><span class="line">                           pendingQueue.add(p);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">               发送队列为空，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else if (!initialized &amp;&amp; p != null &amp;&amp; !p.bb.hasRemaining()) &#123;</span><br><span class="line">               连接请求发送完成，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Just in case</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ClientCnxnSocketNIO的readConnectResult方法"><a href="#10、ClientCnxnSocketNIO的readConnectResult方法" class="headerlink" title="10、ClientCnxnSocketNIO的readConnectResult方法"></a>10、ClientCnxnSocketNIO的readConnectResult方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void readConnectResult() throws IOException &#123;</span><br><span class="line">       if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">           StringBuilder buf = new StringBuilder(&quot;0x[&quot;);</span><br><span class="line">           for (byte b : incomingBuffer.array()) &#123;</span><br><span class="line">               buf.append(Integer.toHexString(b) + &quot;,&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           buf.append(&quot;]&quot;);</span><br><span class="line">           LOG.trace(&quot;readConnectResult &quot; + incomingBuffer.remaining() + &quot; &quot;</span><br><span class="line">                   + buf.toString());</span><br><span class="line">       &#125;</span><br><span class="line">       ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">       BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">       ConnectResponse conRsp = new ConnectResponse();</span><br><span class="line">       反序列化连接请求返回</span><br><span class="line">       conRsp.deserialize(bbia, &quot;connect&quot;);</span><br><span class="line"></span><br><span class="line">       // read &quot;is read-only&quot; flag</span><br><span class="line">       boolean isRO = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           isRO = bbia.readBool(&quot;readOnly&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           // this is ok -- just a packet from an old server which</span><br><span class="line">           // doesn&apos;t contain readOnly field</span><br><span class="line">           LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //获取服务端返回的sessionId</span><br><span class="line">       this.sessionId = conRsp.getSessionId();</span><br><span class="line">       //最终处理连接返回数据</span><br><span class="line">       sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,</span><br><span class="line">               conRsp.getPasswd(), isRO);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、sendThread的onConnected方法"><a href="#11、sendThread的onConnected方法" class="headerlink" title="11、sendThread的onConnected方法"></a>11、sendThread的onConnected方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void onConnected(int _negotiatedSessionTimeout, long _sessionId,</span><br><span class="line">                byte[] _sessionPasswd, boolean isRO) throws IOException &#123;</span><br><span class="line">    negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">    //session是否过期</span><br><span class="line">    if (negotiatedSessionTimeout &lt;= 0) &#123;</span><br><span class="line">        state = States.CLOSED;</span><br><span class="line">        //session过期 关闭客户端</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">                Watcher.Event.EventType.None,</span><br><span class="line">                Watcher.Event.KeeperState.Expired, null));</span><br><span class="line">        eventThread.queueEventOfDeath();</span><br><span class="line">        ...</span><br><span class="line">        throw new SessionExpiredException(warnInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    //读写客户端连接上只读服务器，则打印错误日志</span><br><span class="line">    if (!readOnly &amp;&amp; isRO) &#123;</span><br><span class="line">        LOG.error(&quot;Read/write client got connected to read-only server&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    readTimeout = negotiatedSessionTimeout * 2 / 3;</span><br><span class="line">    connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">    hostProvider.onConnected();</span><br><span class="line">    sessionId = _sessionId;</span><br><span class="line">    sessionPasswd = _sessionPasswd;</span><br><span class="line">    //连接成功修改连接状态</span><br><span class="line">    state = (isRO) ?</span><br><span class="line">            States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">    //是否连接上读写服务器</span><br><span class="line">    seenRwServerBefore |= !isRO;</span><br><span class="line">    KeeperState eventState = (isRO) ?</span><br><span class="line">            KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">    事件队列添加一个None类型的事件</span><br><span class="line">    eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">            Watcher.Event.EventType.None,</span><br><span class="line">            eventState, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、EventThread的queueEvent方法"><a href="#12、EventThread的queueEvent方法" class="headerlink" title="12、EventThread的queueEvent方法"></a>12、EventThread的queueEvent方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void queueEvent(WatchedEvent event,</span><br><span class="line">           Set&lt;Watcher&gt; materializedWatchers) &#123;</span><br><span class="line">       if (event.getType() == EventType.None</span><br><span class="line">               &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       sessionState = event.getState();</span><br><span class="line">       final Set&lt;Watcher&gt; watchers;</span><br><span class="line">       if (materializedWatchers == null) &#123;</span><br><span class="line">           // 获取与该事件相关的所有监听器</span><br><span class="line">           watchers = watcher.materialize(event.getState(),</span><br><span class="line">                   event.getType(), event.getPath());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">           watchers.addAll(materializedWatchers);</span><br><span class="line">       &#125;</span><br><span class="line">       WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);</span><br><span class="line">       //往队列添加监听器和事件对</span><br><span class="line">       waitingEvents.add(pair);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、ZKWatchManager的materialize方法"><a href="#13、ZKWatchManager的materialize方法" class="headerlink" title="13、ZKWatchManager的materialize方法"></a>13、ZKWatchManager的materialize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,</span><br><span class="line">                                       Watcher.Event.EventType type,</span><br><span class="line">                                       String clientPath)</span><br><span class="line">   &#123;</span><br><span class="line">       Set&lt;Watcher&gt; result = new HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">       switch (type) &#123;</span><br><span class="line">       //None类型的事件通知所有监听器</span><br><span class="line">       case None:</span><br><span class="line">           result.add(defaultWatcher);</span><br><span class="line">           boolean clear = disableAutoWatchReset &amp;&amp; state != Watcher.Event.KeeperState.SyncConnected;</span><br><span class="line">           synchronized(dataWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: dataWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   dataWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(existWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: existWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   existWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(childWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: childWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   childWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       case NodeDataChanged:</span><br><span class="line">       case NodeCreated:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               addTo(existWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeChildrenChanged:</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeDeleted:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           // XXX This shouldn&apos;t be needed, but just in case</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; list = existWatches.remove(clientPath);</span><br><span class="line">               if (list != null) &#123;</span><br><span class="line">                   addTo(existWatches.remove(clientPath), result);</span><br><span class="line">                   LOG.warn(&quot;We are triggering an exists watch for delete! Shouldn&apos;t happen!&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       default:</span><br><span class="line">           String msg = &quot;Unhandled watch event type &quot; + type</span><br><span class="line">               + &quot; with state &quot; + state + &quot; on path &quot; + clientPath;</span><br><span class="line">           LOG.error(msg);</span><br><span class="line">           throw new RuntimeException(msg);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、EventThread的processEvent方法"><a href="#14、EventThread的processEvent方法" class="headerlink" title="14、EventThread的processEvent方法"></a>14、EventThread的processEvent方法</h4><p>EventThread的run方法中的processEvent方法处理事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private void processEvent(Object event) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (event instanceof WatcherSetEventPair) &#123;</span><br><span class="line">            //是监听器事件则调用所有监听器</span><br><span class="line">            WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">            for (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                      watcher.process(pair.event);</span><br><span class="line">                catch (Throwable t) &#123;</span><br><span class="line">                      LOG.error(&quot;Error while calling watcher &quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用回调函数</span><br><span class="line">        &#125; else if (event instanceof LocalCallback) &#123;</span><br><span class="line">            LocalCallback lcb = (LocalCallback) event;</span><br><span class="line">            if (lcb.cb instanceof StatCallback) &#123;</span><br><span class="line">                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path,</span><br><span class="line">                        lcb.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	//是数据包则调用其中的回调函数</span><br><span class="line">            Packet p = (Packet) event;</span><br><span class="line">            int rc = 0;</span><br><span class="line">            String clientPath = p.clientPath;</span><br><span class="line">            if (p.replyHeader.getErr() != 0) &#123;</span><br><span class="line">                rc = p.replyHeader.getErr();</span><br><span class="line">            &#125;</span><br><span class="line">            if (p.cb == null) &#123;</span><br><span class="line">                LOG.warn(&quot;Somehow a null cb got to EventThread!&quot;);</span><br><span class="line">            &#125; else if (p.response instanceof ExistsResponse</span><br><span class="line">                      || p.response instanceof SetDataResponse</span><br><span class="line">                      || p.response instanceof SetACLResponse) &#123;</span><br><span class="line">            	StatCallback cb = (StatCallback) p.cb;</span><br><span class="line">                if (rc == 0) &#123;</span><br><span class="line">                    if (p.response instanceof ExistsResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((ExistsResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetDataResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetDataResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetACLResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetACLResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	... </span><br><span class="line">       	&#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        LOG.error(&quot;Caught unexpected throwable&quot;, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此客户端连接成功</p>
<h3 id="二、添加节点过程"><a href="#二、添加节点过程" class="headerlink" title="二、添加节点过程"></a>二、添加节点过程</h3><h4 id="1、ZooKeeper类中的create方法"><a href="#1、ZooKeeper类中的create方法" class="headerlink" title="1、ZooKeeper类中的create方法"></a>1、ZooKeeper类中的create方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   //path   		节点的位置</span><br><span class="line">   //data[] 		节点的数据</span><br><span class="line">   //acl 			OPEN_ACL_UNSAFE：完全开放</span><br><span class="line">//				CREATOR_ALL_ACL：创建该znode的连接拥有所有权限</span><br><span class="line">//				READ_ACL_UNSAFE：所有的客户端都可读</span><br><span class="line">   //createMode 	PERSISTENT：持久化节点</span><br><span class="line">//				PERSISTENT_SEQUENTIAL：持久化有序节点</span><br><span class="line">//				EPHEMERAL：临时节点（连接断开自动删除）</span><br><span class="line">//				EPHEMERAL_SEQUENTIAL：临时有序节点（连接断开自动删除）</span><br><span class="line">public String create(final String path, byte data[], List&lt;ACL&gt; acl,</span><br><span class="line">           CreateMode createMode)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">       EphemeralType.validateTTL(createMode, -1);</span><br><span class="line">       validateACL(acl);</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">       CreateRequest request = new CreateRequest();</span><br><span class="line">       CreateResponse response = new CreateResponse();</span><br><span class="line">       request.setData(data);</span><br><span class="line">       request.setFlags(createMode.toFlag());</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setAcl(acl);</span><br><span class="line">       //发送请求</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, null);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line">       if (cnxn.chrootPath == null) &#123;</span><br><span class="line">           return response.getPath();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return response.getPath().substring(cnxn.chrootPath.length());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ClientCnxn的submitRequest方法"><a href="#2、ClientCnxn的submitRequest方法" class="headerlink" title="2、ClientCnxn的submitRequest方法"></a>2、ClientCnxn的submitRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ReplyHeader submitRequest(RequestHeader h, Record request,</span><br><span class="line">           Record response, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       ReplyHeader r = new ReplyHeader();</span><br><span class="line">       //将请求打包并加入发送队列</span><br><span class="line">       Packet packet = queuePacket(h, r, request, response, null, null, null,</span><br><span class="line">               null, watchRegistration, watchDeregistration);</span><br><span class="line">       synchronized (packet) &#123;</span><br><span class="line">       	//等待直到数据包处理</span><br><span class="line">           while (!packet.finished) &#123;</span><br><span class="line">               packet.wait();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ClientCnxn的queuePacket方法"><a href="#3、ClientCnxn的queuePacket方法" class="headerlink" title="3、ClientCnxn的queuePacket方法"></a>3、ClientCnxn的queuePacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,</span><br><span class="line">           Record response, AsyncCallback cb, String clientPath,</span><br><span class="line">           String serverPath, Object ctx, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration) &#123;</span><br><span class="line">       Packet packet = null;</span><br><span class="line"></span><br><span class="line">       //创建待发送的数据包裹</span><br><span class="line">       packet = new Packet(h, r, request, response, watchRegistration);</span><br><span class="line">       packet.cb = cb;</span><br><span class="line">       packet.ctx = ctx;</span><br><span class="line">       packet.clientPath = clientPath;</span><br><span class="line">       packet.serverPath = serverPath;</span><br><span class="line">       packet.watchDeregistration = watchDeregistration;</span><br><span class="line">       </span><br><span class="line">       synchronized (state) &#123;</span><br><span class="line">           if (!state.isAlive() || closing) &#123;</span><br><span class="line">           	//客户端已关闭或正在关闭，关闭包裹</span><br><span class="line">               conLossPacket(packet);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果发送的是关闭请求,更改正关闭状态为true</span><br><span class="line">               if (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                   closing = true;</span><br><span class="line">               &#125;</span><br><span class="line">               将数据包裹加入待发送队列</span><br><span class="line">               outgoingQueue.add(packet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //唤醒selector</span><br><span class="line">       sendThread.getClientCnxnSocket().packetAdded();</span><br><span class="line">       return packet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、SendThread类的readResponse方法"><a href="#4、SendThread类的readResponse方法" class="headerlink" title="4、SendThread类的readResponse方法"></a>4、SendThread类的readResponse方法</h4><p>发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">void readResponse(ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    ByteBufferInputStream bbis = new ByteBufferInputStream(</span><br><span class="line">            incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ReplyHeader replyHdr = new ReplyHeader();</span><br><span class="line"></span><br><span class="line">    replyHdr.deserialize(bbia, &quot;header&quot;);</span><br><span class="line">    //ping请求返回</span><br><span class="line">    if (replyHdr.getXid() == -2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //权限认证请求返回</span><br><span class="line">    if (replyHdr.getXid() == -4) &#123;</span><br><span class="line">        if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">            state = States.AUTH_FAILED;                    </span><br><span class="line">            eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, </span><br><span class="line">                    Watcher.Event.KeeperState.AuthFailed, null) );            		            		</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //客户端返回通知</span><br><span class="line">    if (replyHdr.getXid() == -1) &#123;</span><br><span class="line">        WatcherEvent event = new WatcherEvent();</span><br><span class="line">        event.deserialize(bbia, &quot;response&quot;);</span><br><span class="line"></span><br><span class="line">        //把event中的path转换为客户端path</span><br><span class="line">        if (chrootPath != null) &#123;</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            if(serverPath.compareTo(chrootPath)==0)</span><br><span class="line">                event.setPath(&quot;/&quot;);</span><br><span class="line">            else if (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            else &#123;</span><br><span class="line">            	LOG.warn(&quot;Got server path &quot; + event.getPath()</span><br><span class="line">            			+ &quot; which is too short for chroot path &quot;</span><br><span class="line">            			+ chrootPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WatchedEvent we = new WatchedEvent(event);</span><br><span class="line">        //添加事件，逻辑在（一、12）中</span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Packet packet;</span><br><span class="line">    synchronized (pendingQueue) &#123;</span><br><span class="line">        if (pendingQueue.size() == 0) &#123;</span><br><span class="line">            throw new IOException(&quot;Nothing in the queue, but got &quot;</span><br><span class="line">                    + replyHdr.getXid());</span><br><span class="line">        &#125;</span><br><span class="line">        //服务端已返回，从队列中删除该数据包</span><br><span class="line">        packet = pendingQueue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    //数据包裹按顺序处理，返回不一致则抛出异常</span><br><span class="line">    try &#123;</span><br><span class="line">        if (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">            packet.replyHeader.setErr(</span><br><span class="line">                    KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">            throw new IOException(&quot;Xid out of order. Got Xid &quot;</span><br><span class="line">                    + replyHdr.getXid() + &quot; with err &quot; +</span><br><span class="line">                    + replyHdr.getErr() +</span><br><span class="line">                    &quot; expected Xid &quot;</span><br><span class="line">                    + packet.requestHeader.getXid()</span><br><span class="line">                    + &quot; for a packet with details: &quot;</span><br><span class="line">                    + packet );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">        packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">        if (replyHdr.getZxid() &gt; 0) &#123;</span><br><span class="line">        	//更新最新处理事物id</span><br><span class="line">            lastZxid = replyHdr.getZxid();</span><br><span class="line">        &#125;</span><br><span class="line">        if (packet.response != null &amp;&amp; replyHdr.getErr() == 0) &#123;</span><br><span class="line">        	//序列化返回数据</span><br><span class="line">            packet.response.deserialize(bbia, &quot;response&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	//最终完成数据包处理</span><br><span class="line">        finishPacket(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、SendThread的finishPacket方法"><a href="#5、SendThread的finishPacket方法" class="headerlink" title="5、SendThread的finishPacket方法"></a>5、SendThread的finishPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void finishPacket(Packet p) &#123;</span><br><span class="line">       int err = p.replyHeader.getErr();</span><br><span class="line">       if (p.watchRegistration != null) &#123;</span><br><span class="line">       	//注册监听器到watchManager中</span><br><span class="line">           p.watchRegistration.register(err);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       数据包裹处理完成</span><br><span class="line">       if (p.cb == null) &#123;</span><br><span class="line">           synchronized (p) &#123;</span><br><span class="line">               p.finished = true;</span><br><span class="line">               p.notifyAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           p.finished = true;</span><br><span class="line">           eventThread.queuePacket(p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到此create处理完成</p>
<h3 id="三、添加监听器过程"><a href="#三、添加监听器过程" class="headerlink" title="三、添加监听器过程"></a>三、添加监听器过程</h3><h4 id="1、以ZooKeepe类中的exists方法为例"><a href="#1、以ZooKeepe类中的exists方法为例" class="headerlink" title="1、以ZooKeepe类中的exists方法为例"></a>1、以ZooKeepe类中的exists方法为例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Stat exists(final String path, Watcher watcher)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath);</span><br><span class="line">       WatchRegistration wcb = null;</span><br><span class="line">       if (watcher != null) &#123;</span><br><span class="line">       	//新建Exist监听器注册器</span><br><span class="line">           wcb = new ExistsWatchRegistration(watcher, clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">       //实例化Exists请求</span><br><span class="line">       ExistsRequest request = new ExistsRequest();</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setWatch(watcher != null);</span><br><span class="line">       SetDataResponse response = new SetDataResponse();</span><br><span class="line">       //发送请求，见（二、2）</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           if (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return response.getStat().getCzxid() == -1 ? null : response.getStat();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ExistsWatchRegistration的register方法"><a href="#2、ExistsWatchRegistration的register方法" class="headerlink" title="2、ExistsWatchRegistration的register方法"></a>2、ExistsWatchRegistration的register方法</h4><p>发送和接受请求与二中相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void register(int rc) &#123;</span><br><span class="line">       if (shouldAddWatch(rc)) &#123;</span><br><span class="line">           Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">           synchronized(watches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">               if (watchers == null) &#123;</span><br><span class="line">                   watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">                   watches.put(clientPath, watchers);</span><br><span class="line">               &#125;</span><br><span class="line">               watchers.add(watcher);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、ExistsWatchRegistration的getWatches方法"><a href="#3、ExistsWatchRegistration的getWatches方法" class="headerlink" title="3、ExistsWatchRegistration的getWatches方法"></a>3、ExistsWatchRegistration的getWatches方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(int rc) &#123;</span><br><span class="line">   	//返回成功则注册到dataWatches，不存在则注册到existWatches中</span><br><span class="line">       return rc == 0 ?  watchManager.dataWatches : watchManager.existWatches;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到此zookeeper客户端源码就介绍完了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码客户端/" data-id="cjix6ii7d000weguedyo9bvh4" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-zookeeper源码/zookeeper源码单机版服务端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/zookeeper源码/zookeeper源码单机版服务端/" class="article-date">
  <time datetime="2018-04-07T04:44:43.471Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/zookeeper源码/zookeeper源码单机版服务端/">zookeeper源码单机版服务端</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper源码单机版服务端"><a href="#zookeeper源码单机版服务端" class="headerlink" title="zookeeper源码单机版服务端"></a>zookeeper源码单机版服务端</h2><h3 id="一、服务器启动过程"><a href="#一、服务器启动过程" class="headerlink" title="一、服务器启动过程"></a>一、服务器启动过程</h3><h4 id="1、ZooKeeperServerMain的nitializeAndRun方法"><a href="#1、ZooKeeperServerMain的nitializeAndRun方法" class="headerlink" title="1、ZooKeeperServerMain的nitializeAndRun方法"></a>1、ZooKeeperServerMain的nitializeAndRun方法</h4><p>单机版入口为ZooKeeperServerMain类main方法，调用了initializeAndRun方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected void initializeAndRun(String[] args)</span><br><span class="line">     throws ConfigException, IOException, AdminServerException</span><br><span class="line"> &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         ManagedUtil.registerLog4jMBeans();</span><br><span class="line">     &#125; catch (JMException e) &#123;</span><br><span class="line">         LOG.warn(&quot;Unable to register log4j JMX control&quot;, e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ServerConfig config = new ServerConfig();</span><br><span class="line">     if (args.length == 1) &#123;</span><br><span class="line">         //args[0]为配置文件路径</span><br><span class="line">         config.parse(args[0]);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         config.parse(args);</span><br><span class="line">     &#125;</span><br><span class="line">     runFromConfig(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、ServerConfig的parse方法"><a href="#2、ServerConfig的parse方法" class="headerlink" title="2、ServerConfig的parse方法"></a>2、ServerConfig的parse方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void parse(String path) throws ConfigException &#123;</span><br><span class="line">    QuorumPeerConfig config = new QuorumPeerConfig();</span><br><span class="line">    //解析配置文件</span><br><span class="line">    config.parse(path);</span><br><span class="line">    //将解析存放于QuorumPeerConfig中的配置信息赋值给ServerConfig</span><br><span class="line">    readFrom(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、runFromConfig方法"><a href="#3、runFromConfig方法" class="headerlink" title="3、runFromConfig方法"></a>3、runFromConfig方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> public void runFromConfig(ServerConfig config)</span><br><span class="line">        throws IOException, AdminServerException &#123;</span><br><span class="line">    FileTxnSnapLog txnLog = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //FileTxnSnapLog包含了日志和快照文件 </span><br><span class="line">        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);</span><br><span class="line">        //zookeeper服务器实例</span><br><span class="line">        final ZooKeeperServer zkServer = new ZooKeeperServer(txnLog,</span><br><span class="line">                config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);</span><br><span class="line">        //主线程以此等待zkServer关闭</span><br><span class="line">        final CountDownLatch shutdownLatch = new CountDownLatch(1);</span><br><span class="line">        zkServer.registerServerShutdownHandler(</span><br><span class="line">                new ZooKeeperServerShutdownHandler(shutdownLatch));</span><br><span class="line"></span><br><span class="line">        //内嵌的管理控制台是通过jetty启动,占用8080 端口</span><br><span class="line">        adminServer = AdminServerFactory.createAdminServer();</span><br><span class="line">        adminServer.setZooKeeperServer(zkServer);</span><br><span class="line">        adminServer.start();</span><br><span class="line"></span><br><span class="line">        boolean needStartZKServer = true;</span><br><span class="line">        if (config.getClientPortAddress() != null) &#123;</span><br><span class="line">            //连接工厂，默认NIOServerCnxnFactory </span><br><span class="line">            cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            //监听客户端请求，实例化接受、处理请求的线程</span><br><span class="line">            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), false);</span><br><span class="line">            cnxnFactory.startup(zkServer);</span><br><span class="line">            // zkServer has been started. So we don&apos;t need to start it again in secureCnxnFactory.</span><br><span class="line">            needStartZKServer = false;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        //定期删除子节点为空的容器节点</span><br><span class="line">        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor,</span><br><span class="line">                Integer.getInteger(&quot;znode.container.checkIntervalMs&quot;, (int) TimeUnit.MINUTES.toMillis(1)),</span><br><span class="line">                Integer.getInteger(&quot;znode.container.maxPerMinute&quot;, 10000)</span><br><span class="line">        );</span><br><span class="line">        containerManager.start();</span><br><span class="line"></span><br><span class="line">        // Watch status of ZooKeeper server. It will do a graceful shutdown</span><br><span class="line">        // if the server is not running or hits an internal error.</span><br><span class="line">        shutdownLatch.await();</span><br><span class="line"></span><br><span class="line">        shutdown();</span><br><span class="line"></span><br><span class="line">        //等待子线程执行完毕</span><br><span class="line">        if (cnxnFactory != null) &#123;</span><br><span class="line">            cnxnFactory.join();</span><br><span class="line">        &#125;</span><br><span class="line">        if (secureCnxnFactory != null) &#123;</span><br><span class="line">            secureCnxnFactory.join();</span><br><span class="line">        &#125;</span><br><span class="line">        if (zkServer.canShutdown()) &#123;</span><br><span class="line">            zkServer.shutdown(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // warn, but generally this is ok</span><br><span class="line">        LOG.warn(&quot;Server interrupted&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (txnLog != null) &#123;</span><br><span class="line">            txnLog.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、NIOServerCnxnFactory的configure方法"><a href="#4、NIOServerCnxnFactory的configure方法" class="headerlink" title="4、NIOServerCnxnFactory的configure方法"></a>4、NIOServerCnxnFactory的configure方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException &#123;</span><br><span class="line">    if (secure) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;SSL isn&apos;t supported in NIOServerCnxn&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    configureSaslLogin();</span><br><span class="line">    //单个客户端与单台服务器之间的连接数的限制</span><br><span class="line">    maxClientCnxns = maxcc;</span><br><span class="line">    //服务端连接过期时间</span><br><span class="line">    sessionlessCnxnTimeout = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);</span><br><span class="line">    //存放服务端接收到的连接</span><br><span class="line">    cnxnExpiryQueue =</span><br><span class="line">        new ExpiryQueue&lt;NIOServerCnxn&gt;(sessionlessCnxnTimeout);</span><br><span class="line">    //该线程关闭cnxnExpiryQueue中已经过期的连接</span><br><span class="line">    expirerThread = new ConnectionExpirerThread();</span><br><span class="line"></span><br><span class="line">    int numCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    // 32 cores sweet spot seems to be 4 selector threads</span><br><span class="line">    numSelectorThreads = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_NUM_SELECTOR_THREADS,</span><br><span class="line">        Math.max((int) Math.sqrt((float) numCores/2), 1));</span><br><span class="line">    if (numSelectorThreads &lt; 1) &#123;</span><br><span class="line">        throw new IOException(&quot;numSelectorThreads must be at least 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numWorkerThreads = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);</span><br><span class="line">    workerShutdownTimeoutMS = Long.getLong(</span><br><span class="line">        ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);</span><br><span class="line"></span><br><span class="line">    //处理接收到请求的线程</span><br><span class="line">    for(int i=0; i&lt;numSelectorThreads; ++i) &#123;</span><br><span class="line">        selectorThreads.add(new SelectorThread(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.ss = ServerSocketChannel.open();</span><br><span class="line">    ss.socket().setReuseAddress(true);</span><br><span class="line">    LOG.info(&quot;binding to port &quot; + addr);</span><br><span class="line">    ss.socket().bind(addr);</span><br><span class="line">    ss.configureBlocking(false);</span><br><span class="line">    //接受客户端请求的线程</span><br><span class="line">    acceptThread = new AcceptThread(ss, addr, selectorThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（一、3）NIOServerCnxnFactory的startup方法"><a href="#5、接（一、3）NIOServerCnxnFactory的startup方法" class="headerlink" title="5、接（一、3）NIOServerCnxnFactory的startup方法"></a>5、接（一、3）NIOServerCnxnFactory的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startup(ZooKeeperServer zks, boolean startServer)</span><br><span class="line">        throws IOException, InterruptedException &#123;</span><br><span class="line">    start();</span><br><span class="line">    setZooKeeperServer(zks);</span><br><span class="line">    if (startServer) &#123;</span><br><span class="line">        zks.startdata();</span><br><span class="line">        zks.startup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、NIOServerCnxnFactory的start方法"><a href="#6、NIOServerCnxnFactory的start方法" class="headerlink" title="6、NIOServerCnxnFactory的start方法"></a>6、NIOServerCnxnFactory的start方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">    stopped = false;</span><br><span class="line">    if (workerPool == null) &#123;</span><br><span class="line">        //封装了一组线程池集合，集合大小默认2 * numCores。定长线程池大小1，</span><br><span class="line">        workerPool = new WorkerService(</span><br><span class="line">            &quot;NIOWorker&quot;, numWorkerThreads, false);</span><br><span class="line">    &#125;</span><br><span class="line">    //启动处理接收到请求的线程</span><br><span class="line">    for(SelectorThread thread : selectorThreads) &#123;</span><br><span class="line">        if (thread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动管理请求线程</span><br><span class="line">    if (acceptThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">        acceptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭cnxnExpiryQueue中已经过期的连接</span><br><span class="line">    if (expirerThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">        expirerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、接（一、3）实例化ZooKeeperServer"><a href="#7、接（一、3）实例化ZooKeeperServer" class="headerlink" title="7、接（一、3）实例化ZooKeeperServer"></a>7、接（一、3）实例化ZooKeeperServer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime,</span><br><span class="line">        int minSessionTimeout, int maxSessionTimeout, ZKDatabase zkDb) &#123;</span><br><span class="line">    serverStats = new ServerStats(this);</span><br><span class="line">    //封装日志和快照</span><br><span class="line">    this.txnLogFactory = txnLogFactory;</span><br><span class="line">    //内存数据ZKDatabase</span><br><span class="line">    this.zkDb = zkDb;</span><br><span class="line">    //最小事件单位</span><br><span class="line">    this.tickTime = tickTime;</span><br><span class="line">    //最小session时间</span><br><span class="line">    setMinSessionTimeout(minSessionTimeout);</span><br><span class="line">    //最大session时间</span><br><span class="line">    setMaxSessionTimeout(maxSessionTimeout);</span><br><span class="line">    listener = new ZooKeeperServerListenerImpl(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、接（一、5）ZooKeeperServer的startdata方法恢复数据s"><a href="#8、接（一、5）ZooKeeperServer的startdata方法恢复数据s" class="headerlink" title="8、接（一、5）ZooKeeperServer的startdata方法恢复数据s"></a>8、接（一、5）ZooKeeperServer的startdata方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public void startdata()</span><br><span class="line"> throws IOException, InterruptedException &#123;</span><br><span class="line">     //check to see if zkDb is not null</span><br><span class="line">     if (zkDb == null) &#123;</span><br><span class="line">         zkDb = new ZKDatabase(this.txnLogFactory);</span><br><span class="line">     &#125;</span><br><span class="line">     if (!zkDb.isInitialized()) &#123;</span><br><span class="line">//恢复数据</span><br><span class="line">         loadData();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ZooKeeperServer的loadData方法恢复数据s"><a href="#9、ZooKeeperServer的loadData方法恢复数据s" class="headerlink" title="9、ZooKeeperServer的loadData方法恢复数据s"></a>9、ZooKeeperServer的loadData方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  public void loadData() throws IOException, InterruptedException &#123;</span><br><span class="line">//设置最新的事务Zxid</span><br><span class="line">      if(zkDb.isInitialized())&#123;</span><br><span class="line">          setZxid(zkDb.getDataTreeLastProcessedZxid());</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">	//恢复数据</span><br><span class="line">          setZxid(zkDb.loadDataBase());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // Clean up dead sessions</span><br><span class="line">      List&lt;Long&gt; deadSessions = new LinkedList&lt;Long&gt;();</span><br><span class="line">//获取过期的session</span><br><span class="line">      for (Long session : zkDb.getSessions()) &#123;</span><br><span class="line">          if (zkDb.getSessionWithTimeOuts().get(session) == null) &#123;</span><br><span class="line">              deadSessions.add(session);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//清除过期的session</span><br><span class="line">      for (long session : deadSessions) &#123;</span><br><span class="line">          killSession(session, zkDb.getDataTreeLastProcessedZxid());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //创建一个最新的快照文件</span><br><span class="line">      takeSnapshot();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ZKDatabase的loadDataBase方法恢复数据"><a href="#10、ZKDatabase的loadDataBase方法恢复数据" class="headerlink" title="10、ZKDatabase的loadDataBase方法恢复数据"></a>10、ZKDatabase的loadDataBase方法恢复数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public long loadDataBase() throws IOException &#123;</span><br><span class="line">        PlayBackListener listener=new PlayBackListener()&#123;</span><br><span class="line">            public void onTxnLoaded(TxnHeader hdr,Record txn)&#123;</span><br><span class="line">                Request r = new Request(0, hdr.getCxid(),hdr.getType(), hdr, txn, hdr.getZxid());</span><br><span class="line">                addCommittedProposal(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		//实际恢复数据的方法</span><br><span class="line">        long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);</span><br><span class="line">        initialized = true;</span><br><span class="line">        return zxid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、FileTxnSnapLog的restore方法恢复数据s"><a href="#11、FileTxnSnapLog的restore方法恢复数据s" class="headerlink" title="11、FileTxnSnapLog的restore方法恢复数据s"></a>11、FileTxnSnapLog的restore方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public long restore(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span><br><span class="line">           PlayBackListener listener) throws IOException &#123;</span><br><span class="line">	//从快照文件中恢复数据</span><br><span class="line">       long deserializeResult = snapLog.deserialize(dt, sessions);</span><br><span class="line">	//事务记录</span><br><span class="line">       FileTxnLog txnLog = new FileTxnLog(dataDir);</span><br><span class="line">       boolean trustEmptyDB;</span><br><span class="line">       File initFile = new File(dataDir.getParent(), &quot;initialize&quot;);</span><br><span class="line">       if (Files.deleteIfExists(initFile.toPath())) &#123;</span><br><span class="line">           LOG.info(&quot;Initialize file found, an empty database will not block voting participation&quot;);</span><br><span class="line">           trustEmptyDB = true;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           trustEmptyDB = autoCreateDB;</span><br><span class="line">       &#125;</span><br><span class="line">	//无快照文件</span><br><span class="line">       if (-1L == deserializeResult) &#123;</span><br><span class="line">           //无快照文件，但是有事务记录</span><br><span class="line">           if (txnLog.getLastLoggedZxid() != -1) &#123;</span><br><span class="line">               throw new IOException(</span><br><span class="line">                       &quot;No snapshot found, but there are log entries. &quot; +</span><br><span class="line">                       &quot;Something is broken!&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (trustEmptyDB) &#123;</span><br><span class="line">               //创建内存快照</span><br><span class="line">               save(dt, (ConcurrentHashMap&lt;Long, Integer&gt;)sessions, false);</span><br><span class="line">               //内存DataTree数据为空</span><br><span class="line">               return 0L;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //返回-1L可能丢失数据</span><br><span class="line">               dt.lastProcessedZxid = -1L;</span><br><span class="line">               return -1L;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	//获取事务id大于最新快照文件的事务记录</span><br><span class="line">       TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);</span><br><span class="line">       long highestZxid = dt.lastProcessedZxid;</span><br><span class="line">       TxnHeader hdr;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true) &#123;</span><br><span class="line">			获取事务头</span><br><span class="line">               hdr = itr.getHeader();</span><br><span class="line">			//空事务记录</span><br><span class="line">               if (hdr == null) &#123;</span><br><span class="line">                   return dt.lastProcessedZxid;</span><br><span class="line">               &#125;</span><br><span class="line">			//取出的事务记录id应当不小于快照中的</span><br><span class="line">               if (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != 0) &#123;</span><br><span class="line">                   LOG.error(&quot;&#123;&#125;(highestZxid) &gt; &#123;&#125;(next log) for type &#123;&#125;&quot;,</span><br><span class="line">                           highestZxid, hdr.getZxid(), hdr.getType());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   highestZxid = hdr.getZxid();</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">			    //将事务执行到内存树DataTree上</span><br><span class="line">                   processTransaction(hdr,dt,sessions, itr.getTxn());</span><br><span class="line">               &#125; catch(KeeperException.NoNodeException e) &#123;</span><br><span class="line">                  throw new IOException(&quot;Failed to process transaction type: &quot; +</span><br><span class="line">                        hdr.getType() + &quot; error: &quot; + e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">			//调用监听器将事务commitedLog集合，待服务恢复的时候会同步到其他leaner server</span><br><span class="line">               listener.onTxnLoaded(hdr, itr.getTxn());</span><br><span class="line">               if (!itr.next())</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (itr != null) &#123;</span><br><span class="line">               itr.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return highestZxid;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、接（一、5）ZooKeeperServer的startup方法"><a href="#12、接（一、5）ZooKeeperServer的startup方法" class="headerlink" title="12、接（一、5）ZooKeeperServer的startup方法"></a>12、接（一、5）ZooKeeperServer的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void startup() &#123;</span><br><span class="line">       if (sessionTracker == null) &#123;</span><br><span class="line">		//创建SessionTrackerImpl用来管理Session</span><br><span class="line">           createSessionTracker();</span><br><span class="line">       &#125;</span><br><span class="line">	//启动SessionTrackerImpl</span><br><span class="line">       startSessionTracker();</span><br><span class="line">	//初始化处理器</span><br><span class="line">       setupRequestProcessors();</span><br><span class="line">       registerJMX();</span><br><span class="line">       setState(State.RUNNING);</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、ZooKeeperServer的setupRequestProcessors方法"><a href="#13、ZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="13、ZooKeeperServer的setupRequestProcessors方法"></a>13、ZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">	//FinalRequestProcessor负责把已经commit的写操作应用到本机，对于读操作则从本机中读取数据并返回给client</span><br><span class="line">       RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">	//这个 processor负责把写request持久化到本地磁盘</span><br><span class="line">       RequestProcessor syncProcessor = new SyncRequestProcessor(this,</span><br><span class="line">               finalProcessor);</span><br><span class="line">       ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">	//为修改状态的操作建立相应的TxnHeader和Record对象</span><br><span class="line">       firstProcessor = new PrepRequestProcessor(this, syncProcessor);</span><br><span class="line">       ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、接（一、12）实例化SessionTrackerImpl"><a href="#14、接（一、12）实例化SessionTrackerImpl" class="headerlink" title="14、接（一、12）实例化SessionTrackerImpl"></a>14、接（一、12）实例化SessionTrackerImpl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public SessionTrackerImpl(SessionExpirer expirer,</span><br><span class="line">           ConcurrentMap&lt;Long, Integer&gt; sessionsWithTimeout, int tickTime,</span><br><span class="line">           long serverId, ZooKeeperServerListener listener)</span><br><span class="line">   &#123;</span><br><span class="line">       super(&quot;SessionTracker&quot;, listener);</span><br><span class="line">       this.expirer = expirer;</span><br><span class="line">	//管理session的队列</span><br><span class="line">       this.sessionExpiryQueue = new ExpiryQueue&lt;SessionImpl&gt;(tickTime);</span><br><span class="line">       this.sessionsWithTimeout = sessionsWithTimeout;</span><br><span class="line">	//初始化sessionId</span><br><span class="line">       this.nextSessionId.set(initializeNextSession(serverId));</span><br><span class="line">	//恢复的数据中的sessions，加入SessionTrackerImpl</span><br><span class="line">       for (Entry&lt;Long, Integer&gt; e : sessionsWithTimeout.entrySet()) &#123;</span><br><span class="line">           addSession(e.getKey(), e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、SessionTrackerImpl的run方法"><a href="#15、SessionTrackerImpl的run方法" class="headerlink" title="15、SessionTrackerImpl的run方法"></a>15、SessionTrackerImpl的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (running) &#123;</span><br><span class="line">			//获取最近过期时间</span><br><span class="line">               long waitTime = sessionExpiryQueue.getWaitTime();</span><br><span class="line">               if (waitTime &gt; 0) &#123;</span><br><span class="line">                   Thread.sleep(waitTime);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">			//获取最近过期时间对应的Session集合</span><br><span class="line">               for (SessionImpl s : sessionExpiryQueue.poll()) &#123;</span><br><span class="line">				//关闭Session</span><br><span class="line">                   setSessionClosing(s.sessionId);</span><br><span class="line">				//调用ZooKeeperServer的expire方法，提交关闭session请求，关闭session</span><br><span class="line">                   expirer.expire(s);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           handleException(this.getName(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、接（一、13）PrepRequestProcessor的run方法"><a href="#16、接（一、13）PrepRequestProcessor的run方法" class="headerlink" title="16、接（一、13）PrepRequestProcessor的run方法"></a>16、接（一、13）PrepRequestProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true) &#123;</span><br><span class="line">			//获取提交到队列中请求</span><br><span class="line">               Request request = submittedRequests.take();</span><br><span class="line">               long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">               if (request.type == OpCode.ping) &#123;</span><br><span class="line">                   traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">               &#125;</span><br><span class="line">               if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                   ZooTrace.logRequest(LOG, traceMask, &apos;P&apos;, request, &quot;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               if (Request.requestOfDeath == request) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">			//处理请求</span><br><span class="line">               pRequest(request);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">	...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、接（一、13）SyncRequestProcessor的run方法"><a href="#17、接（一、13）SyncRequestProcessor的run方法" class="headerlink" title="17、接（一、13）SyncRequestProcessor的run方法"></a>17、接（一、13）SyncRequestProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           int logCount = 0;</span><br><span class="line">           int randRoll = r.nextInt(snapCount/2);</span><br><span class="line">           while (true) &#123;</span><br><span class="line">               Request si = null;</span><br><span class="line">               //等待刷新到本地的磁盘为空</span><br><span class="line">               if (toFlush.isEmpty()) &#123;</span><br><span class="line">                   //从等待队列中获取待处理请求</span><br><span class="line">                   si = queuedRequests.take();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   si = queuedRequests.poll();</span><br><span class="line">                   if (si == null) &#123;</span><br><span class="line">                       //将日志文件刷新到磁盘，调用下个处理器处理队列中的请求</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //关闭请求</span><br><span class="line">               if (si == requestOfDeath) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (si != null) &#123;</span><br><span class="line">                   //往日志文件文件尾部添加一条记录</span><br><span class="line">                   if (zks.getZKDatabase().append(si)) &#123;</span><br><span class="line">                       logCount++;</span><br><span class="line">                       //事务达到一定数量则保存快照</span><br><span class="line">                       if (logCount &gt; (snapCount / 2 + randRoll)) &#123;</span><br><span class="line">                           randRoll = r.nextInt(snapCount/2);</span><br><span class="line">                           //将日志文件刷新到磁盘，释放资源，之后的日志开新文件保存</span><br><span class="line">                           zks.getZKDatabase().rollLog();</span><br><span class="line">                           //创建快照文件</span><br><span class="line">                           if (snapInProcess != null &amp;&amp; snapInProcess.isAlive()) &#123;</span><br><span class="line">                               LOG.warn(&quot;Too busy to snap, skipping&quot;);</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               snapInProcess = new ZooKeeperThread(&quot;Snapshot Thread&quot;) &#123;</span><br><span class="line">                                       public void run() &#123;</span><br><span class="line">                                           try &#123;</span><br><span class="line">                                               zks.takeSnapshot();</span><br><span class="line">                                           &#125; catch(Exception e) &#123;</span><br><span class="line">                                               LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;;</span><br><span class="line">                               snapInProcess.start();</span><br><span class="line">                           &#125;</span><br><span class="line">                           logCount = 0;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else if (toFlush.isEmpty()) &#123;</span><br><span class="line">                       //如果本次请求是读请求，并且没有待刷新的请求，直接调用下个处理器</span><br><span class="line">                       if (nextProcessor != null) &#123;</span><br><span class="line">                           nextProcessor.processRequest(si);</span><br><span class="line">                           if (nextProcessor instanceof Flushable) &#123;</span><br><span class="line">                               ((Flushable)nextProcessor).flush();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //本次请求添加到待刷新队列</span><br><span class="line">                   toFlush.add(si);</span><br><span class="line">                   if (toFlush.size() &gt; 1000) &#123;</span><br><span class="line">                       //将日志文件刷新到磁盘，调用下个处理器处理队列中的请求</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           handleException(this.getName(), t);</span><br><span class="line">       &#125; finally&#123;</span><br><span class="line">           running = false;</span><br><span class="line">       &#125;</span><br><span class="line">       LOG.info(&quot;SyncRequestProcessor exited!&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="18、接（一、4）实例化AcceptThread"><a href="#18、接（一、4）实例化AcceptThread" class="headerlink" title="18、接（一、4）实例化AcceptThread"></a>18、接（一、4）实例化AcceptThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public AcceptThread(ServerSocketChannel ss, InetSocketAddress addr,</span><br><span class="line">        Set&lt;SelectorThread&gt; selectorThreads) throws IOException &#123;</span><br><span class="line">    super(&quot;NIOServerCxnFactory.AcceptThread:&quot; + addr);</span><br><span class="line">    //NiO服务端ServerSocketChannel</span><br><span class="line">    this.acceptSocket = ss;</span><br><span class="line">    //注册到selector指定OP_ACCEPT事件,selector在父类AbstractSelectThread中</span><br><span class="line">    this.acceptKey =</span><br><span class="line">        acceptSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    this.selectorThreads = Collections.unmodifiableList(</span><br><span class="line">        new ArrayList&lt;SelectorThread&gt;(selectorThreads));</span><br><span class="line">    selectorIterator = this.selectorThreads.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19、AcceptThread的run方法"><a href="#19、AcceptThread的run方法" class="headerlink" title="19、AcceptThread的run方法"></a>19、AcceptThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stopped &amp;&amp; !acceptSocket.socket().isClosed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理连接</span><br><span class="line">                select();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSelector();</span><br><span class="line">        // This will wake up the selector threads, and tell the</span><br><span class="line">        // worker thread pool to begin shutdown.</span><br><span class="line">        if (!reconfiguring) &#123;                    </span><br><span class="line">            NIOServerCnxnFactory.this.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20、AcceptThread的select方法"><a href="#20、AcceptThread的select方法" class="headerlink" title="20、AcceptThread的select方法"></a>20、AcceptThread的select方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void select() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //等待事件就绪</span><br><span class="line">        selector.select();</span><br><span class="line">        //获取就绪的事件</span><br><span class="line">        Iterator&lt;SelectionKey&gt; selectedKeys =</span><br><span class="line">            selector.selectedKeys().iterator();</span><br><span class="line">        while (!stopped &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = selectedKeys.next();</span><br><span class="line">            selectedKeys.remove();</span><br><span class="line"></span><br><span class="line">            if (!key.isValid()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (key.isAcceptable()) &#123;</span><br><span class="line">                //处理接到的请求</span><br><span class="line">                if (!doAccept()) &#123;</span><br><span class="line">                    //如果获取连接失败，由于需要释放资源，等待一段时间。</span><br><span class="line">                    pauseAccept(10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.warn(&quot;Unexpected ops in accept select &quot;</span><br><span class="line">                         + key.readyOps());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21、接（一、4）实例化SelectorThread"><a href="#21、接（一、4）实例化SelectorThread" class="headerlink" title="21、接（一、4）实例化SelectorThread"></a>21、接（一、4）实例化SelectorThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public SelectorThread(int id) throws IOException &#123;</span><br><span class="line">    super(&quot;NIOServerCxnFactory.SelectorThread-&quot; + id);</span><br><span class="line">    this.id = id;</span><br><span class="line">    //接收到的客户端请求</span><br><span class="line">    acceptedQueue = new LinkedBlockingQueue&lt;SocketChannel&gt;();</span><br><span class="line">    //待修改连接指定等待事件的队列</span><br><span class="line">    updateQueue = new LinkedBlockingQueue&lt;SelectionKey&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22、SelectorThread的run方法"><a href="#22、SelectorThread的run方法" class="headerlink" title="22、SelectorThread的run方法"></a>22、SelectorThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stopped) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理请求</span><br><span class="line">                select();</span><br><span class="line">                //封装获取到的连接</span><br><span class="line">                processAcceptedConnections();</span><br><span class="line">                //修改连接指定的事件</span><br><span class="line">                processInterestOpsUpdateRequests();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭连接</span><br><span class="line">        for (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line">            if (cnxn.isSelectable()) &#123;</span><br><span class="line">                cnxn.close();</span><br><span class="line">            &#125;</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        SocketChannel accepted;</span><br><span class="line">        //关闭尚未处理的连接</span><br><span class="line">        while ((accepted = acceptedQueue.poll()) != null) &#123;</span><br><span class="line">            fastCloseSock(accepted);</span><br><span class="line">        &#125;</span><br><span class="line">        updateQueue.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSelector();</span><br><span class="line">        // This will wake up the accept thread and the other selector</span><br><span class="line">        // threads, and tell the worker thread pool to begin shutdown.</span><br><span class="line">        NIOServerCnxnFactory.this.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、建立连接"><a href="#二、建立连接" class="headerlink" title="二、建立连接"></a>二、建立连接</h3><h4 id="1、接（一、20）AcceptThread的doAccept"><a href="#1、接（一、20）AcceptThread的doAccept" class="headerlink" title="1、接（一、20）AcceptThread的doAccept"></a>1、接（一、20）AcceptThread的doAccept</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private boolean doAccept() &#123;</span><br><span class="line">    boolean accepted = false;</span><br><span class="line">    SocketChannel sc = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取连接</span><br><span class="line">        sc = acceptSocket.accept();</span><br><span class="line">        accepted = true;</span><br><span class="line">        //获取连接的客户端地址            </span><br><span class="line">        InetAddress ia = sc.socket().getInetAddress();</span><br><span class="line">        //该客户端的连接数量</span><br><span class="line">        int cnxncount = getClientCnxnCount(ia);</span><br><span class="line">        if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;</span><br><span class="line">            throw new IOException(&quot;Too many connections from &quot; + ia</span><br><span class="line">                                  + &quot; - max is &quot; + maxClientCnxns );</span><br><span class="line">        &#125;</span><br><span class="line">        sc.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        if (!selectorIterator.hasNext()) &#123;</span><br><span class="line">            selectorIterator = selectorThreads.iterator();</span><br><span class="line">        &#125;</span><br><span class="line">        //获取处理该次取到的SocketChannel的SelectorThread对象</span><br><span class="line">        SelectorThread selectorThread = selectorIterator.next();</span><br><span class="line">        //将获取到的SocketChannel加入到acceptedQueue队列中</span><br><span class="line">        if (!selectorThread.addAcceptedConnection(sc)) &#123;</span><br><span class="line">            throw new IOException(</span><br><span class="line">                &quot;Unable to add connection to selector queue&quot;</span><br><span class="line">                + (stopped ? &quot; (shutdown in progress)&quot; : &quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        acceptErrorLogger.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // accept, maxClientCnxns, configureBlocking</span><br><span class="line">        acceptErrorLogger.rateLimitLog(</span><br><span class="line">            &quot;Error accepting new connection: &quot; + e.getMessage());</span><br><span class="line">        fastCloseSock(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    return accepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、selectorThread的processAcceptedConnections方法"><a href="#2、selectorThread的processAcceptedConnections方法" class="headerlink" title="2、selectorThread的processAcceptedConnections方法"></a>2、selectorThread的processAcceptedConnections方法</h4><p>selectorThread处理连接run方法首先经过processAcceptedConnections<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void processAcceptedConnections() &#123;</span><br><span class="line">    SocketChannel accepted;</span><br><span class="line">    while (!stopped &amp;&amp; (accepted = acceptedQueue.poll()) != null) &#123;</span><br><span class="line">        SelectionKey key = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将获取到的SocketChannel注册到selector中，指定OP_READ事件</span><br><span class="line">            key = accepted.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            //将连接包装成NIOServerCnxn对象</span><br><span class="line">            NIOServerCnxn cnxn = createConnection(accepted, key, this);</span><br><span class="line">            key.attach(cnxn);</span><br><span class="line"></span><br><span class="line">            addCnxn(cnxn);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // register, createConnection</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">            fastCloseSock(accepted);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、SelectorThread的addCnxn方法"><a href="#3、SelectorThread的addCnxn方法" class="headerlink" title="3、SelectorThread的addCnxn方法"></a>3、SelectorThread的addCnxn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void addCnxn(NIOServerCnxn cnxn) &#123;</span><br><span class="line">    //获取客户端ip</span><br><span class="line">    InetAddress addr = cnxn.getSocketAddress();</span><br><span class="line">    //该客户端连接的集合</span><br><span class="line">    Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span><br><span class="line"></span><br><span class="line">    if (set == null) &#123;</span><br><span class="line">        set = Collections.newSetFromMap(</span><br><span class="line">            new ConcurrentHashMap&lt;NIOServerCnxn, Boolean&gt;(2));</span><br><span class="line">        //防止其他线程已经添加</span><br><span class="line">        Set&lt;NIOServerCnxn&gt; existingSet = ipMap.putIfAbsent(addr, set);</span><br><span class="line">        if (existingSet != null) &#123;</span><br><span class="line">            set = existingSet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //加入该ip的连接集合</span><br><span class="line">    set.add(cnxn);</span><br><span class="line">    //加入连接集合</span><br><span class="line">    cnxns.add(cnxn);</span><br><span class="line">    //该方法将cnxn添加到cnxnExpiryQueue的最新时间所对应的集合中，重原来的时间对应的集合中删除</span><br><span class="line">    touchCnxn(cnxn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、SelectorThread的select方法"><a href="#4、SelectorThread的select方法" class="headerlink" title="4、SelectorThread的select方法"></a>4、SelectorThread的select方法</h4><p>processAcceptedConnections处理完，select继续处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void select() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             //等待事件就绪</span><br><span class="line">             selector.select();</span><br><span class="line">             //获取就绪事件</span><br><span class="line">             Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</span><br><span class="line">             ArrayList&lt;SelectionKey&gt; selectedList =</span><br><span class="line">                 new ArrayList&lt;SelectionKey&gt;(selected);</span><br><span class="line">             Collections.shuffle(selectedList);</span><br><span class="line">             Iterator&lt;SelectionKey&gt; selectedKeys = selectedList.iterator();</span><br><span class="line">             while(!stopped &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class="line">                 获取就绪事件的key</span><br><span class="line">                 SelectionKey key = selectedKeys.next();</span><br><span class="line">                 selected.remove(key);</span><br><span class="line"></span><br><span class="line">                 if (!key.isValid()) &#123;</span><br><span class="line">                     cleanupSelectionKey(key);</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (key.isReadable() || key.isWritable()) &#123;</span><br><span class="line">                     //处理就绪事件的key</span><br><span class="line">                     handleIO(key);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     LOG.warn(&quot;Unexpected ops in select &quot; + key.readyOps());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (IOException e) &#123;</span><br><span class="line">             LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、SelectorThread的shandleIO方法"><a href="#5、SelectorThread的shandleIO方法" class="headerlink" title="5、SelectorThread的shandleIO方法"></a>5、SelectorThread的shandleIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void handleIO(SelectionKey key) &#123;</span><br><span class="line">    IOWorkRequest workRequest = new IOWorkRequest(this, key);</span><br><span class="line">    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line"></span><br><span class="line">    // 正在处理中的连接不可宣</span><br><span class="line">    cnxn.disableSelectable();</span><br><span class="line">    key.interestOps(0);</span><br><span class="line">    //将cnxn更新到最新时间所对应下的连接集合中</span><br><span class="line">    touchCnxn(cnxn);</span><br><span class="line">    //WorkerService对象中有一个线程池集合，用于执行线程ScheduledWorkRequest，</span><br><span class="line">    //ScheduledWorkRequest线程run方法，调用IOWorkRequest的doWork方法</span><br><span class="line">    workerPool.schedule(workRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、IOWorkRequest的doWork方法"><a href="#6、IOWorkRequest的doWork方法" class="headerlink" title="6、IOWorkRequest的doWork方法"></a>6、IOWorkRequest的doWork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void doWork() throws InterruptedException &#123;</span><br><span class="line">    if (!key.isValid()) &#123;</span><br><span class="line">        selectorThread.cleanupSelectionKey(key);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key.isReadable() || key.isWritable()) &#123;</span><br><span class="line">        //处理key就绪的事件</span><br><span class="line">        cnxn.doIO(key);</span><br><span class="line"></span><br><span class="line">        // Check if we shutdown or doIO() closed this connection</span><br><span class="line">        if (stopped) &#123;</span><br><span class="line">            cnxn.close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            selectorThread.cleanupSelectionKey(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        touchCnxn(cnxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理完成标记可选</span><br><span class="line">    cnxn.enableSelectable();</span><br><span class="line">    //将key加入updateQueue队列中</span><br><span class="line">    if (!selectorThread.addInterestOpsUpdateRequest(key)) &#123;</span><br><span class="line">        cnxn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、NIOServerCnxn的doIO方法"><a href="#7、NIOServerCnxn的doIO方法" class="headerlink" title="7、NIOServerCnxn的doIO方法"></a>7、NIOServerCnxn的doIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void doIO(SelectionKey k) throws InterruptedException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (isSocketOpen() == false) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //就绪事件为读事件</span><br><span class="line">        if (k.isReadable()) &#123;</span><br><span class="line">            //数据读入缓冲区incomingBuffer</span><br><span class="line">            int rc = sock.read(incomingBuffer);</span><br><span class="line">            if (rc &lt; 0) &#123;</span><br><span class="line">                throw new EndOfStreamException(</span><br><span class="line">                        &quot;Unable to read additional data from client sessionid 0x&quot;</span><br><span class="line">                        + Long.toHexString(sessionId)</span><br><span class="line">                        + &quot;, likely client has closed socket&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (incomingBuffer.remaining() == 0) &#123;</span><br><span class="line">                boolean isPayload;</span><br><span class="line">	//相等则说明是新请求</span><br><span class="line">                if (incomingBuffer == lenBuffer) &#123; // start of next request</span><br><span class="line">                    incomingBuffer.flip();</span><br><span class="line">		//读取头四个字节，校检长度及请求类型</span><br><span class="line">                    isPayload = readLength(k);</span><br><span class="line">                    incomingBuffer.clear();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // continuation</span><br><span class="line">                    isPayload = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isPayload) &#123; // not the case for 4letterword</span><br><span class="line">		//处理请求</span><br><span class="line">                    readPayload();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // four letter words take care</span><br><span class="line">                    // need not do anything else</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //就绪事件为写事件</span><br><span class="line">        if (k.isWritable()) &#123;</span><br><span class="line">            handleWrite(k);</span><br><span class="line"></span><br><span class="line">            if (!initialized &amp;&amp; !getReadInterest() &amp;&amp; !getWriteInterest()) &#123;</span><br><span class="line">                throw new CloseRequestException(&quot;responded to info probe&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、NIOServerCnxn的readPayload方法"><a href="#8、NIOServerCnxn的readPayload方法" class="headerlink" title="8、NIOServerCnxn的readPayload方法"></a>8、NIOServerCnxn的readPayload方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void readPayload() throws IOException, InterruptedException &#123;</span><br><span class="line">       if (incomingBuffer.remaining() != 0) &#123; // have we read length bytes?</span><br><span class="line">		//读取客户端数据</span><br><span class="line">           int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok</span><br><span class="line">           if (rc &lt; 0) &#123;</span><br><span class="line">               throw new EndOfStreamException(</span><br><span class="line">                       &quot;Unable to read additional data from client sessionid 0x&quot;</span><br><span class="line">                       + Long.toHexString(sessionId)</span><br><span class="line">                       + &quot;, likely client has closed socket&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (incomingBuffer.remaining() == 0) &#123; // have we read length bytes?</span><br><span class="line">           //记录获取到的数据包个数</span><br><span class="line">		packetReceived();</span><br><span class="line">           incomingBuffer.flip();</span><br><span class="line">           if (!initialized) &#123;</span><br><span class="line">			//读取连接请求</span><br><span class="line">               readConnectRequest();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">			//读取请求</span><br><span class="line">               readRequest();</span><br><span class="line">           &#125;</span><br><span class="line">           lenBuffer.clear();</span><br><span class="line">		//处理完成,重置</span><br><span class="line">           incomingBuffer = lenBuffer;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、NIOServerCnxn的readConnectRequest方法"><a href="#9、NIOServerCnxn的readConnectRequest方法" class="headerlink" title="9、NIOServerCnxn的readConnectRequest方法"></a>9、NIOServerCnxn的readConnectRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void readConnectRequest() throws IOException, InterruptedException &#123;</span><br><span class="line">       if (!isZKServerRunning()) &#123;</span><br><span class="line">           throw new IOException(&quot;ZooKeeperServer not running&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">	//处理连接请求</span><br><span class="line">       zkServer.processConnectRequest(this, incomingBuffer);</span><br><span class="line">       initialized = true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ZooKeeperServer的processConnectRequest方法"><a href="#10、ZooKeeperServer的processConnectRequest方法" class="headerlink" title="10、ZooKeeperServer的processConnectRequest方法"></a>10、ZooKeeperServer的processConnectRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">       BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));</span><br><span class="line">       ConnectRequest connReq = new ConnectRequest();</span><br><span class="line">       //反序列化请求数据</span><br><span class="line">	connReq.deserialize(bia, &quot;connect&quot;);</span><br><span class="line">       boolean readOnly = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           readOnly = bia.readBool(&quot;readOnly&quot;);</span><br><span class="line">           cnxn.isOldClient = false;</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">	//客户端非只读，而服务端为只读服务器</span><br><span class="line">       if (!readOnly &amp;&amp; this instanceof ReadOnlyZooKeeperServer) &#123;</span><br><span class="line">           String msg = &quot;Refusing session request for not-read-only client &quot;</span><br><span class="line">               + cnxn.getRemoteSocketAddress();</span><br><span class="line">           LOG.info(msg);</span><br><span class="line">           throw new CloseRequestException(msg);</span><br><span class="line">       &#125;</span><br><span class="line">	//客户端的事务id大于服务端，需要重连其他服务器</span><br><span class="line">       if (connReq.getLastZxidSeen() &gt; zkDb.dataTree.lastProcessedZxid) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       int sessionTimeout = connReq.getTimeOut();</span><br><span class="line">       byte passwd[] = connReq.getPasswd();</span><br><span class="line">       int minSessionTimeout = getMinSessionTimeout();</span><br><span class="line">       if (sessionTimeout &lt; minSessionTimeout) &#123;</span><br><span class="line">           sessionTimeout = minSessionTimeout;</span><br><span class="line">       &#125;</span><br><span class="line">       int maxSessionTimeout = getMaxSessionTimeout();</span><br><span class="line">       if (sessionTimeout &gt; maxSessionTimeout) &#123;</span><br><span class="line">           sessionTimeout = maxSessionTimeout;</span><br><span class="line">       &#125;</span><br><span class="line">	//协商后的Session超时事件</span><br><span class="line">       cnxn.setSessionTimeout(sessionTimeout);</span><br><span class="line">       //停止接受新的请求，把SelectionKey加入updateQueue中，见（二、17）</span><br><span class="line">       cnxn.disableRecv();</span><br><span class="line">       long sessionId = connReq.getSessionId();</span><br><span class="line">	//sessionId == 0新客户端连接，否则短线重连</span><br><span class="line">       if (sessionId == 0) &#123;</span><br><span class="line">		//创建session</span><br><span class="line">           createSession(cnxn, passwd, sessionTimeout);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           long clientSessionId = connReq.getSessionId();</span><br><span class="line">           //sessionMap中移除sessionId，关闭旧连接</span><br><span class="line">           if (serverCnxnFactory != null) &#123;</span><br><span class="line">               serverCnxnFactory.closeSession(sessionId);</span><br><span class="line">           &#125;</span><br><span class="line">           if (secureServerCnxnFactory != null) &#123;</span><br><span class="line">               secureServerCnxnFactory.closeSession(sessionId);</span><br><span class="line">           &#125;</span><br><span class="line">		//添加新sessionId</span><br><span class="line">           cnxn.setSessionId(sessionId);</span><br><span class="line">           reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、ZooKeeperServer的createSession方法"><a href="#11、ZooKeeperServer的createSession方法" class="headerlink" title="11、ZooKeeperServer的createSession方法"></a>11、ZooKeeperServer的createSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;</span><br><span class="line">       if (passwd == null) &#123;</span><br><span class="line">           passwd = new byte[0];</span><br><span class="line">       &#125;</span><br><span class="line">	//创建session</span><br><span class="line">       long sessionId = sessionTracker.createSession(timeout);</span><br><span class="line">       Random r = new Random(sessionId ^ superSecret);</span><br><span class="line">       r.nextBytes(passwd);</span><br><span class="line">       ByteBuffer to = ByteBuffer.allocate(4);</span><br><span class="line">       to.putInt(timeout);</span><br><span class="line">	//sessionMap中加入sessionId及本连接对象</span><br><span class="line">       cnxn.setSessionId(sessionId);</span><br><span class="line">	//创建Session请求</span><br><span class="line">       Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);</span><br><span class="line">	setLocalSessionFlag(si);</span><br><span class="line">	//提交请求</span><br><span class="line">       submitRequest(si);</span><br><span class="line">       return sessionId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、ZooKeeperServer的submitRequest方法"><a href="#12、ZooKeeperServer的submitRequest方法" class="headerlink" title="12、ZooKeeperServer的submitRequest方法"></a>12、ZooKeeperServer的submitRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void submitRequest(Request si) &#123;</span><br><span class="line">       if (firstProcessor == null) &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">				//等待初始化</span><br><span class="line">                   while (state == State.INITIAL) &#123;</span><br><span class="line">                       wait(1000);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   LOG.warn(&quot;Unexpected interruption&quot;, e);</span><br><span class="line">               &#125;</span><br><span class="line">               if (firstProcessor == null || state != State.RUNNING) &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;Not started&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           touch(si.cnxn);</span><br><span class="line">           boolean validpacket = Request.isValid(si.type);</span><br><span class="line">           if (validpacket) &#123;</span><br><span class="line">			//请求加入处理器待处理请求队列,处理器为prepRequestProcessor</span><br><span class="line">               firstProcessor.processRequest(si);</span><br><span class="line">               if (si.cnxn != null) &#123;</span><br><span class="line">				//正在处理的请求加一</span><br><span class="line">                   incInProcess();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               new UnimplementedRequestProcessor().processRequest(si);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">	...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、prepRequestProcessor的pRequest方法"><a href="#13、prepRequestProcessor的pRequest方法" class="headerlink" title="13、prepRequestProcessor的pRequest方法"></a>13、prepRequestProcessor的pRequest方法</h4><p>prepRequestProcessor从请求队列中获取请求后调用pRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">       request.setHdr(null);</span><br><span class="line">       request.setTxn(null);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           switch (request.type) &#123;</span><br><span class="line">           //为不同请求生成请求对象</span><br><span class="line">           case OpCode.createContainer:</span><br><span class="line">           case OpCode.create:</span><br><span class="line">           case OpCode.create2:</span><br><span class="line">               CreateRequest create2Request = new CreateRequest();</span><br><span class="line">               pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);</span><br><span class="line">               break;</span><br><span class="line">           ...</span><br><span class="line">           //create/close session don&apos;t require request record</span><br><span class="line">           case OpCode.createSession:</span><br><span class="line">           case OpCode.closeSession:</span><br><span class="line">               if (!request.isLocalSession()) &#123;</span><br><span class="line">                   pRequest2Txn(request.type, zks.getNextZxid(), request,</span><br><span class="line">                                null, true);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">           //下列请求只需要验证Session</span><br><span class="line">           case OpCode.sync:</span><br><span class="line">           case OpCode.exists:</span><br><span class="line">           case OpCode.getData:</span><br><span class="line">           case OpCode.getACL:</span><br><span class="line">           case OpCode.getChildren:</span><br><span class="line">           case OpCode.getChildren2:</span><br><span class="line">           case OpCode.ping:</span><br><span class="line">           case OpCode.setWatches:</span><br><span class="line">           case OpCode.checkWatches:</span><br><span class="line">           case OpCode.removeWatches:</span><br><span class="line">               zks.sessionTracker.checkSession(request.sessionId,</span><br><span class="line">                       request.getOwner());</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       ...</span><br><span class="line">       //获取事务zxid</span><br><span class="line">       request.zxid = zks.getZxid();</span><br><span class="line">       //提交到下个处理器处理</span><br><span class="line">       nextProcessor.processRequest(request);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="14、PrepRequestProcessor的pRequest2Txn方法"><a href="#14、PrepRequestProcessor的pRequest2Txn方法" class="headerlink" title="14、PrepRequestProcessor的pRequest2Txn方法"></a>14、PrepRequestProcessor的pRequest2Txn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                            Record record, boolean deserialize)</span><br><span class="line">    throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">    // 创建事务头</span><br><span class="line">    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">            Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //请求类型为创建会话请求</span><br><span class="line">        case OpCode.createSession:</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            int to = request.request.getInt();</span><br><span class="line">            //创建会话请求</span><br><span class="line">            request.setTxn(new CreateSessionTxn(to));</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            //往sessionTrackerImpl中添加新session</span><br><span class="line">            if (request.isLocalSession()) &#123;</span><br><span class="line">                // This will add to local session tracker if it is enabled</span><br><span class="line">                zks.sessionTracker.addSession(request.sessionId, to);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Explicitly add to global session if the flag is not set</span><br><span class="line">                zks.sessionTracker.addGlobalSession(request.sessionId, to);</span><br><span class="line">            &#125;</span><br><span class="line">            //设置该session所属的客户端</span><br><span class="line">            zks.setOwner(request.sessionId, request.getOwner());</span><br><span class="line">            break;</span><br><span class="line">        // 关闭会话请求</span><br><span class="line">        case OpCode.closeSession:</span><br><span class="line">            //获取该session对应的临时节点</span><br><span class="line">            Set&lt;String&gt; es = zks.getZKDatabase()</span><br><span class="line">                    .getEphemerals(request.sessionId);</span><br><span class="line">            synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">                for (ChangeRecord c : zks.outstandingChanges) &#123;</span><br><span class="line">                    if (c.stat == null) &#123;</span><br><span class="line">                        // Doing a delete</span><br><span class="line">                        es.remove(c.path);</span><br><span class="line">                    &#125; else if (c.stat.getEphemeralOwner() == request.sessionId) &#123;</span><br><span class="line">                        //添加到零时节点路径集合</span><br><span class="line">                        es.add(c.path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (String path2Delete : es) &#123;</span><br><span class="line">                    //添加变更记录</span><br><span class="line">                    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));</span><br><span class="line">                &#125;</span><br><span class="line">                //关闭session</span><br><span class="line">                zks.sessionTracker.setSessionClosing(request.sessionId);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">        default:</span><br><span class="line">            LOG.warn(&quot;unknown type &quot; + type);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、FinalRequestProcessor的processRequest方法"><a href="#15、FinalRequestProcessor的processRequest方法" class="headerlink" title="15、FinalRequestProcessor的processRequest方法"></a>15、FinalRequestProcessor的processRequest方法</h4><p>SyncRequestProcessor的获取到请求，添加完日志文件如（一、17），之后调用FinalRequestProcessor的processRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    // request.addRQRec(&quot;&gt;final&quot;);</span><br><span class="line">    long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">    if (request.type == OpCode.ping) &#123;</span><br><span class="line">        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    ProcessTxnResult rc = null;</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        // zookeeperserver处理请求</span><br><span class="line">        rc = zks.processTxn(request);</span><br><span class="line"></span><br><span class="line">        // request.hdr is set for write requests, which are the only ones</span><br><span class="line">        // that add to outstandingChanges.</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            TxnHeader hdr = request.getHdr();</span><br><span class="line">            Record txn = request.getTxn();</span><br><span class="line">            long zxid = hdr.getZxid();</span><br><span class="line">            // outstandingChanges不为空且首个元素的zxid小于等于请求的zxid，移除首个元素</span><br><span class="line">            while (!zks.outstandingChanges.isEmpty()</span><br><span class="line">                   &amp;&amp; zks.outstandingChanges.get(0).zxid &lt;= zxid) &#123;</span><br><span class="line">                ChangeRecord cr = zks.outstandingChanges.remove(0);</span><br><span class="line">                if (zks.outstandingChangesForPath.get(cr.path) == cr) &#123;</span><br><span class="line">                    // 移除cr的路径对应的记录</span><br><span class="line">                    zks.outstandingChangesForPath.remove(cr.path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 判断是否是集群范围的请求</span><br><span class="line">        if (request.isQuorum()) &#123;</span><br><span class="line">            //加入集群最近Commit提议队列</span><br><span class="line">            zks.getZKDatabase().addCommittedProposal(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接请求，连接已关闭</span><br><span class="line">    if (request.type == OpCode.closeSession &amp;&amp; connClosedByClient(request)) &#123;</span><br><span class="line">        //关闭Session</span><br><span class="line">        if (closeSession(zks.serverCnxnFactory, request.sessionId) ||</span><br><span class="line">                closeSession(zks.secureServerCnxnFactory, request.sessionId)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (request.cnxn == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ServerCnxn cnxn = request.cnxn;</span><br><span class="line"></span><br><span class="line">    String lastOp = &quot;NA&quot;;</span><br><span class="line">    zks.decInProcess();</span><br><span class="line">    Code err = Code.OK;</span><br><span class="line">    Record rsp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        case OpCode.ping: &#123;</span><br><span class="line">            //更新等待时间</span><br><span class="line">            zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">            lastOp = &quot;PING&quot;;</span><br><span class="line">            // 更新响应的状态</span><br><span class="line">            cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">                    request.createTime, Time.currentElapsedTime());</span><br><span class="line">            // 发回响应</span><br><span class="line">            cnxn.sendResponse(new ReplyHeader(-2,</span><br><span class="line">                    zks.getZKDatabase().getDataTreeLastProcessedZxid(), 0), null, &quot;response&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case OpCode.createSession: &#123;</span><br><span class="line">            zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">            lastOp = &quot;SESS&quot;;</span><br><span class="line">            // 更新响应的状态</span><br><span class="line">            cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">                    request.createTime, Time.currentElapsedTime());</span><br><span class="line">            //完成session的初始化</span><br><span class="line">            zks.finishSessionInit(request.cnxn, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="16、ZooKeeperServer的processTxn方法"><a href="#16、ZooKeeperServer的processTxn方法" class="headerlink" title="16、ZooKeeperServer的processTxn方法"></a>16、ZooKeeperServer的processTxn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private ProcessTxnResult processTxn(Request request, TxnHeader hdr,</span><br><span class="line">                                    Record txn) &#123;</span><br><span class="line">    ProcessTxnResult rc;</span><br><span class="line">    int opCode = request != null ? request.type : hdr.getType();</span><br><span class="line">    long sessionId = request != null ? request.sessionId : hdr.getClientId();</span><br><span class="line">    //无请求头为读请求</span><br><span class="line">    if (hdr != null) &#123;</span><br><span class="line">        //处理普通请求</span><br><span class="line">        rc = getZKDatabase().processTxn(hdr, txn);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //读请求处理结果，空的，后续会处理。</span><br><span class="line">        rc = new ProcessTxnResult();</span><br><span class="line">    &#125;</span><br><span class="line">    if (opCode == OpCode.createSession) &#123;</span><br><span class="line">        if (hdr != null &amp;&amp; txn instanceof CreateSessionTxn) &#123;</span><br><span class="line">            CreateSessionTxn cst = (CreateSessionTxn) txn;</span><br><span class="line">            //添加session</span><br><span class="line">            sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());</span><br><span class="line">        &#125; else if (request != null &amp;&amp; request.isLocalSession()) &#123;</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            int timeout = request.request.getInt();</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            //添加session</span><br><span class="line">            sessionTracker.addSession(request.sessionId, timeout);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (opCode == OpCode.closeSession) &#123;</span><br><span class="line">        //关闭session</span><br><span class="line">        sessionTracker.removeSession(sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、接（二、15）ZooKeeperServer的finishSessionInit方法"><a href="#17、接（二、15）ZooKeeperServer的finishSessionInit方法" class="headerlink" title="17、接（二、15）ZooKeeperServer的finishSessionInit方法"></a>17、接（二、15）ZooKeeperServer的finishSessionInit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void finishSessionInit(ServerCnxn cnxn, boolean valid) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建连接请求返回</span><br><span class="line">        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout()</span><br><span class="line">                : 0, valid ? cnxn.getSessionId() : 0, // send 0 if session is no</span><br><span class="line">                        // longer valid</span><br><span class="line">                        valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">        bos.writeInt(-1, &quot;len&quot;);</span><br><span class="line">        rsp.serialize(bos, &quot;connect&quot;);</span><br><span class="line">        if (!cnxn.isOldClient) &#123;</span><br><span class="line">            bos.writeBool(</span><br><span class="line">                    this instanceof ReadOnlyZooKeeperServer, &quot;readOnly&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.close();</span><br><span class="line">        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span><br><span class="line">        bb.putInt(bb.remaining() - 4).rewind();</span><br><span class="line">        //发送返回数据包裹</span><br><span class="line">        cnxn.sendBuffer(bb);</span><br><span class="line"></span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            //连接已完成，允许接受新请求</span><br><span class="line">            cnxn.enableRecv();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        cnxn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18、SelectorThread的processInterestOpsUpdateRequests方法"><a href="#18、SelectorThread的processInterestOpsUpdateRequests方法" class="headerlink" title="18、SelectorThread的processInterestOpsUpdateRequests方法"></a>18、SelectorThread的processInterestOpsUpdateRequests方法</h4><p>连接建立完成，允许key接受读取事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void processInterestOpsUpdateRequests() &#123;</span><br><span class="line">    SelectionKey key;</span><br><span class="line">    while (!stopped &amp;&amp; (key = updateQueue.poll()) != null) &#123;</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line">        if (cnxn.isSelectable()) &#123;</span><br><span class="line">            //key指定事件</span><br><span class="line">            key.interestOps(cnxn.getInterestOps());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，连接就建立完成了。</p>
<h3 id="三、create请求处理过程"><a href="#三、create请求处理过程" class="headerlink" title="三、create请求处理过程"></a>三、create请求处理过程</h3><h4 id="1、接（二、8）NIOServerCnxn的readRequest-方法"><a href="#1、接（二、8）NIOServerCnxn的readRequest-方法" class="headerlink" title="1、接（二、8）NIOServerCnxn的readRequest 方法"></a>1、接（二、8）NIOServerCnxn的readRequest 方法</h4><p>处理普通连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void readRequest() throws IOException &#123;</span><br><span class="line">    zkServer.processPacket(this, incomingBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、ZooKeeperServer的processPacket方法"><a href="#2、ZooKeeperServer的processPacket方法" class="headerlink" title="2、ZooKeeperServer的processPacket方法"></a>2、ZooKeeperServer的processPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    // We have the request, now process and setup for next</span><br><span class="line">    InputStream bais = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">    BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span><br><span class="line">    RequestHeader h = new RequestHeader();</span><br><span class="line">    h.deserialize(bia, &quot;header&quot;);</span><br><span class="line">    incomingBuffer = incomingBuffer.slice();</span><br><span class="line">    if (h.getType() == OpCode.auth) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (h.getType() == OpCode.sasl) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //封装请求</span><br><span class="line">            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">              h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">            si.setOwner(ServerCnxn.me);</span><br><span class="line">            setLocalSessionFlag(si);</span><br><span class="line">            //将请求加入处理器等待队列（见二、12）</span><br><span class="line">            submitRequest(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //提交但还未返回的请求数增加1</span><br><span class="line">    cnxn.incrOutstandingRequests(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、PrepRequestProcessor的pRequest2Txn方法"><a href="#3、PrepRequestProcessor的pRequest2Txn方法" class="headerlink" title="3、PrepRequestProcessor的pRequest2Txn方法"></a>3、PrepRequestProcessor的pRequest2Txn方法</h4><p>前面和创建session请求相同，直到pRequest2Txn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                            Record record, boolean deserialize)</span><br><span class="line">    throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">            Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case OpCode.create:</span><br><span class="line">        case OpCode.create2:</span><br><span class="line">        case OpCode.createTTL:</span><br><span class="line">        case OpCode.createContainer: &#123;</span><br><span class="line">            //处理增加请求</span><br><span class="line">            pRequest2TxnCreate(type, request, record, deserialize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            LOG.warn(&quot;unknown type &quot; + type);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、PrepRequestProcessor的pRequest2TxnCreate方法"><a href="#4、PrepRequestProcessor的pRequest2TxnCreate方法" class="headerlink" title="4、PrepRequestProcessor的pRequest2TxnCreate方法"></a>4、PrepRequestProcessor的pRequest2TxnCreate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException &#123;</span><br><span class="line">    if (deserialize) &#123;</span><br><span class="line">        ByteBufferInputStream.byteBuffer2Record(request.request, record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int flags;</span><br><span class="line">    String path;</span><br><span class="line">    List&lt;ACL&gt; acl;</span><br><span class="line">    byte[] data;</span><br><span class="line">    long ttl;</span><br><span class="line">    if (type == OpCode.createTTL) &#123;</span><br><span class="line">        CreateTTLRequest createTtlRequest = (CreateTTLRequest)record;</span><br><span class="line">        flags = createTtlRequest.getFlags();</span><br><span class="line">        path = createTtlRequest.getPath();</span><br><span class="line">        acl = createTtlRequest.getAcl();</span><br><span class="line">        data = createTtlRequest.getData();</span><br><span class="line">        ttl = createTtlRequest.getTtl();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CreateRequest createRequest = (CreateRequest)record;</span><br><span class="line">        flags = createRequest.getFlags();</span><br><span class="line">        path = createRequest.getPath();</span><br><span class="line">        acl = createRequest.getAcl();</span><br><span class="line">        data = createRequest.getData();</span><br><span class="line">        ttl = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateMode createMode = CreateMode.fromFlag(flags);</span><br><span class="line">    validateCreateRequest(path, createMode, request, ttl);</span><br><span class="line">    String parentPath = validatePathForCreate(path, request.sessionId);</span><br><span class="line"></span><br><span class="line">    List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, acl);</span><br><span class="line">    //父节点的最新变化记录</span><br><span class="line">    ChangeRecord parentRecord = getRecordForPath(parentPath);</span><br><span class="line">    checkACL(zks, request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);</span><br><span class="line">    //父节点修改次数</span><br><span class="line">    int parentCVersion = parentRecord.stat.getCversion();</span><br><span class="line">    //按顺序创建</span><br><span class="line">    if (createMode.isSequential()) &#123;</span><br><span class="line">        path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    validatePath(path, request.sessionId);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (getRecordForPath(path) != null) &#123;</span><br><span class="line">            throw new KeeperException.NodeExistsException(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (KeeperException.NoNodeException e) &#123;</span><br><span class="line">        // ignore this one</span><br><span class="line">    &#125;</span><br><span class="line">    //临时节点不允许创建子节点</span><br><span class="line">    boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;</span><br><span class="line">    if (ephemeralParent) &#123;</span><br><span class="line">        throw new KeeperException.NoChildrenForEphemeralsException(path);</span><br><span class="line">    &#125;</span><br><span class="line">    //子节点修改次数</span><br><span class="line">    int newCversion = parentRecord.stat.getCversion()+1;</span><br><span class="line">    //创建具体事务</span><br><span class="line">    if (type == OpCode.createContainer) &#123;</span><br><span class="line">        request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));</span><br><span class="line">    &#125; else if (type == OpCode.createTTL) &#123;</span><br><span class="line">        request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(),</span><br><span class="line">                newCversion));</span><br><span class="line">    &#125;</span><br><span class="line">    StatPersisted s = new StatPersisted();</span><br><span class="line">    if (createMode.isEphemeral()) &#123;</span><br><span class="line">        s.setEphemeralOwner(request.sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建最新的父节点变化记录</span><br><span class="line">    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span><br><span class="line">    parentRecord.childCount++;</span><br><span class="line">    parentRecord.stat.setCversion(newCversion);</span><br><span class="line">    //添加父节点最新的变化记录</span><br><span class="line">    addChangeRecord(parentRecord);</span><br><span class="line">    //添加本节点最新的变化记录</span><br><span class="line">    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、FinalRequestProcessor的processRequest方法"><a href="#5、FinalRequestProcessor的processRequest方法" class="headerlink" title="5、FinalRequestProcessor的processRequest方法"></a>5、FinalRequestProcessor的processRequest方法</h4><p>SyncRequestProcessor处理也与创建session相同，直到FinalRequestProcessor的processRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessTxnResult rc = null;</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        //处理请求</span><br><span class="line">        rc = zks.processTxn(request);</span><br><span class="line"></span><br><span class="line">        // request.hdr is set for write requests, which are the only ones</span><br><span class="line">        // that add to outstandingChanges.</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            TxnHeader hdr = request.getHdr();</span><br><span class="line">            Record txn = request.getTxn();</span><br><span class="line">            long zxid = hdr.getZxid();</span><br><span class="line">            while (!zks.outstandingChanges.isEmpty()</span><br><span class="line">                   &amp;&amp; zks.outstandingChanges.get(0).zxid &lt;= zxid) &#123;</span><br><span class="line">                ChangeRecord cr = zks.outstandingChanges.remove(0);</span><br><span class="line">                if (cr.zxid &lt; zxid) &#123;</span><br><span class="line">                    LOG.warn(&quot;Zxid outstanding &quot; + cr.zxid</span><br><span class="line">                             + &quot; is less than current &quot; + zxid);</span><br><span class="line">                &#125;</span><br><span class="line">                if (zks.outstandingChangesForPath.get(cr.path) == cr) &#123;</span><br><span class="line">                    zks.outstandingChangesForPath.remove(cr.path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // do not add non quorum packets to the queue.</span><br><span class="line">        if (request.isQuorum()) &#123;</span><br><span class="line">            zks.getZKDatabase().addCommittedProposal(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case OpCode.create: &#123;</span><br><span class="line">            lastOp = &quot;CREA&quot;;</span><br><span class="line">            //创建请求返回</span><br><span class="line">            rsp = new CreateResponse(rc.path);</span><br><span class="line">            err = Code.get(rc.err);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case OpCode.create2:</span><br><span class="line">        case OpCode.createTTL:</span><br><span class="line">        case OpCode.createContainer: &#123;</span><br><span class="line">            lastOp = &quot;CREA&quot;;</span><br><span class="line">            //创建请求返回</span><br><span class="line">            rsp = new Create2Response(rc.path, rc.stat);</span><br><span class="line">            err = Code.get(rc.err);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch ...</span><br><span class="line">    //获取最近的一个事务编号</span><br><span class="line">    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">    //创建返回头</span><br><span class="line">    ReplyHeader hdr =</span><br><span class="line">        new ReplyHeader(request.cxid, lastZxid, err.intValue());</span><br><span class="line"></span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">    //更新响应状态</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,</span><br><span class="line">                request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //返回数据</span><br><span class="line">        cnxn.sendResponse(hdr, rsp, &quot;response&quot;);</span><br><span class="line">        if (request.type == OpCode.closeSession) &#123;</span><br><span class="line">            cnxn.sendCloseSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;FIXMSG&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6、DataTree的processTxn方法"><a href="#6、DataTree的processTxn方法" class="headerlink" title="6、DataTree的processTxn方法"></a>6、DataTree的processTxn方法</h4><p>之后与（二、15）同，接（二、16）依次调用ZKDatabase、DataTree的processTxn方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public ProcessTxnResult processTxn(TxnHeader header, Record txn)</span><br><span class="line">&#123;</span><br><span class="line">    ProcessTxnResult rc = new ProcessTxnResult();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        rc.clientId = header.getClientId();</span><br><span class="line">        rc.cxid = header.getCxid();</span><br><span class="line">        rc.zxid = header.getZxid();</span><br><span class="line">        rc.type = header.getType();</span><br><span class="line">        rc.err = 0;</span><br><span class="line">        rc.multiResult = null;</span><br><span class="line">        switch (header.getType()) &#123;</span><br><span class="line">            case OpCode.create:</span><br><span class="line">                CreateTxn createTxn = (CreateTxn) txn;</span><br><span class="line">                rc.path = createTxn.getPath();</span><br><span class="line">                createNode(</span><br><span class="line">                        createTxn.getPath(),</span><br><span class="line">                        createTxn.getData(),</span><br><span class="line">                        createTxn.getAcl(),</span><br><span class="line">                        createTxn.getEphemeral() ? header.getClientId() : 0,</span><br><span class="line">                        createTxn.getParentCVersion(),</span><br><span class="line">                        header.getZxid(), header.getTime(), null);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch </span><br><span class="line">    ...</span><br><span class="line">    //更新最新处理Zxid</span><br><span class="line">    if (rc.zxid &gt; lastProcessedZxid) &#123;</span><br><span class="line">        lastProcessedZxid = rc.zxid;</span><br><span class="line">    &#125;</span><br><span class="line">    //要创建的节点已存在</span><br><span class="line">    if (header.getType() == OpCode.create &amp;&amp;</span><br><span class="line">            rc.err == Code.NODEEXISTS.intValue()) &#123;</span><br><span class="line">        int lastSlash = rc.path.lastIndexOf(&apos;/&apos;);</span><br><span class="line">        String parentName = rc.path.substring(0, lastSlash);</span><br><span class="line">        CreateTxn cTxn = (CreateTxn)txn;</span><br><span class="line">        try &#123;</span><br><span class="line">            //更新节点相关信息（修改次数、Zxid）</span><br><span class="line">            setCversionPzxid(parentName, cTxn.getParentCVersion(),</span><br><span class="line">                    header.getZxid());</span><br><span class="line">        &#125; catch (KeeperException.NoNodeException e) &#123;</span><br><span class="line">            LOG.error(&quot;Failed to set parent cversion for: &quot; +</span><br><span class="line">                  parentName, e);</span><br><span class="line">            rc.err = e.code().intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (rc.err != Code.OK.intValue()) &#123;</span><br><span class="line">        LOG.debug(&quot;Ignoring processTxn failure hdr: &quot; + header.getType() +</span><br><span class="line">              &quot; : error: &quot; + rc.err);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、DataTree的createNode方法"><a href="#7、DataTree的createNode方法" class="headerlink" title="7、DataTree的createNode方法"></a>7、DataTree的createNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void createNode(final String path, byte data[], List&lt;ACL&gt; acl,</span><br><span class="line">        long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat)</span><br><span class="line">        throws KeeperException.NoNodeException,</span><br><span class="line">        KeeperException.NodeExistsException &#123;</span><br><span class="line">    int lastSlash = path.lastIndexOf(&apos;/&apos;);</span><br><span class="line">    String parentName = path.substring(0, lastSlash);</span><br><span class="line">    String childName = path.substring(lastSlash + 1);</span><br><span class="line">    StatPersisted stat = new StatPersisted();</span><br><span class="line">    stat.setCtime(time);</span><br><span class="line">    stat.setMtime(time);</span><br><span class="line">    stat.setCzxid(zxid);</span><br><span class="line">    stat.setMzxid(zxid);</span><br><span class="line">    stat.setPzxid(zxid);</span><br><span class="line">    stat.setVersion(0);</span><br><span class="line">    stat.setAversion(0);</span><br><span class="line">    stat.setEphemeralOwner(ephemeralOwner);</span><br><span class="line">    //父节点</span><br><span class="line">    DataNode parent = nodes.get(parentName);</span><br><span class="line">    if (parent == null) &#123;</span><br><span class="line">        throw new KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (parent) &#123;</span><br><span class="line">        //父节点的子节点集合</span><br><span class="line">        Set&lt;String&gt; children = parent.getChildren();</span><br><span class="line">        if (children.contains(childName)) &#123;</span><br><span class="line">            throw new KeeperException.NodeExistsException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentCVersion == -1) &#123;</span><br><span class="line">            parentCVersion = parent.stat.getCversion();</span><br><span class="line">            parentCVersion++;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.stat.setCversion(parentCVersion);</span><br><span class="line">        parent.stat.setPzxid(zxid);</span><br><span class="line">        Long longval = aclCache.convertAcls(acl);</span><br><span class="line">        //创建节点</span><br><span class="line">        DataNode child = new DataNode(data, longval, stat);</span><br><span class="line">        //添加子节点名</span><br><span class="line">        parent.addChild(childName);</span><br><span class="line">        //添加子节点</span><br><span class="line">        nodes.put(path, child);</span><br><span class="line">        //节点类型</span><br><span class="line">        EphemeralType ephemeralType = EphemeralType.get(ephemeralOwner);</span><br><span class="line">        if (ephemeralType == EphemeralType.CONTAINER) &#123;</span><br><span class="line">            containers.add(path);</span><br><span class="line">        &#125; else if (ephemeralType == EphemeralType.TTL) &#123;</span><br><span class="line">            ttls.add(path);</span><br><span class="line">        &#125; else if (ephemeralOwner != 0) &#123;</span><br><span class="line">            //添加入零时节点</span><br><span class="line">            HashSet&lt;String&gt; list = ephemerals.get(ephemeralOwner);</span><br><span class="line">            if (list == null) &#123;</span><br><span class="line">                list = new HashSet&lt;String&gt;();</span><br><span class="line">                ephemerals.put(ephemeralOwner, list);</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (list) &#123;</span><br><span class="line">                list.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (outputStat != null) &#123;</span><br><span class="line">            child.copyStat(outputStat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // now check if its one of the zookeeper node child</span><br><span class="line">    if (parentName.startsWith(quotaZookeeper)) &#123;</span><br><span class="line">        // now check if its the limit node</span><br><span class="line">        if (Quotas.limitNode.equals(childName)) &#123;</span><br><span class="line">            // this is the limit node</span><br><span class="line">            // get the parent and add it to the trie</span><br><span class="line">            pTrie.addPath(parentName.substring(quotaZookeeper.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (Quotas.statNode.equals(childName)) &#123;</span><br><span class="line">            updateQuotaForPath(parentName</span><br><span class="line">                    .substring(quotaZookeeper.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // also check to update the quotas for this node</span><br><span class="line">    String lastPrefix = getMaxPrefixWithQuota(path);</span><br><span class="line">    if(lastPrefix != null) &#123;</span><br><span class="line">        // ok we have some match and need to update</span><br><span class="line">        updateCount(lastPrefix, 1);</span><br><span class="line">        updateBytes(lastPrefix, data == null ? 0 : data.length);</span><br><span class="line">    &#125;</span><br><span class="line">    //触发该事件对应的监听器</span><br><span class="line">    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);</span><br><span class="line">    childWatches.triggerWatch(parentName.equals(&quot;&quot;) ? &quot;/&quot; : parentName,</span><br><span class="line">            Event.EventType.NodeChildrenChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建节点到这里就结束了</p>
<h3 id="四、exists请求添加监听器，处理过程"><a href="#四、exists请求添加监听器，处理过程" class="headerlink" title="四、exists请求添加监听器，处理过程"></a>四、exists请求添加监听器，处理过程</h3><h4 id="1、接（三、5）PrepRequestProcessor的processRequest方法"><a href="#1、接（三、5）PrepRequestProcessor的processRequest方法" class="headerlink" title="1、接（三、5）PrepRequestProcessor的processRequest方法"></a>1、接（三、5）PrepRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case OpCode.exists: &#123;</span><br><span class="line">            lastOp = &quot;EXIS&quot;;</span><br><span class="line">            // TODO we need to figure out the security requirement for this!</span><br><span class="line">            ExistsRequest existsRequest = new ExistsRequest();</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                    existsRequest);</span><br><span class="line">            String path = existsRequest.getPath();</span><br><span class="line">            if (path.indexOf(&apos;\0&apos;) != -1) &#123;</span><br><span class="line">                throw new KeeperException.BadArgumentsException();</span><br><span class="line">            &#125;</span><br><span class="line">            //注册监听器</span><br><span class="line">            Stat stat = zks.getZKDatabase().statNode(path, existsRequest</span><br><span class="line">                    .getWatch() ? cnxn : null);</span><br><span class="line">            rsp = new ExistsResponse(stat);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">    ReplyHeader hdr =</span><br><span class="line">        new ReplyHeader(request.cxid, lastZxid, err.intValue());</span><br><span class="line"></span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,</span><br><span class="line">                request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //发送返回数据</span><br><span class="line">        cnxn.sendResponse(hdr, rsp, &quot;response&quot;);</span><br><span class="line">        if (request.type == OpCode.closeSession) &#123;</span><br><span class="line">            cnxn.sendCloseSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;FIXMSG&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、DataTree的statNode方法"><a href="#2、DataTree的statNode方法" class="headerlink" title="2、DataTree的statNode方法"></a>2、DataTree的statNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Stat statNode(String path, Watcher watcher)</span><br><span class="line">        throws KeeperException.NoNodeException &#123;</span><br><span class="line">    Stat stat = new Stat();</span><br><span class="line">    //快速获取节点</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    if (watcher != null) &#123;</span><br><span class="line">        //监听器添加到集合中</span><br><span class="line">        dataWatches.addWatch(path, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == null) &#123;</span><br><span class="line">        throw new KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (n) &#123;</span><br><span class="line">        //获取节点状态信息</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        return stat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册监听器，到这儿就结束了。<br>单机版服务端源码介绍到此就结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码单机版服务端/" data-id="cjix6ii8o001negueyn6ky0e7" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-zookeeper源码/zookeeper源码分布式服务端（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（2）/" class="article-date">
  <time datetime="2018-04-07T04:44:43.469Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（2）/">zookeeper源码分布式服务端（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper源码分布服务端（2）-分布式CREATE事务处理过程"><a href="#zookeeper源码分布服务端（2）-分布式CREATE事务处理过程" class="headerlink" title="zookeeper源码分布服务端（2） 分布式CREATE事务处理过程"></a>zookeeper源码分布服务端（2） 分布式CREATE事务处理过程</h2><h3 id="一、分布式CREATE事务处理过程Leader部分"><a href="#一、分布式CREATE事务处理过程Leader部分" class="headerlink" title="一、分布式CREATE事务处理过程Leader部分"></a>一、分布式CREATE事务处理过程Leader部分</h3><h4 id="1、LeaderRequestProcessor的run方法"><a href="#1、LeaderRequestProcessor的run方法" class="headerlink" title="1、LeaderRequestProcessor的run方法"></a>1、LeaderRequestProcessor的run方法</h4><p>前面与单机版相同，分布式Leader的firstProcessor为LeaderRequestProcessor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void processRequest(Request request)</span><br><span class="line">        throws RequestProcessorException &#123;</span><br><span class="line">    Request upgradeRequest = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        upgradeRequest = lzks.checkUpgradeSession(request);</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (upgradeRequest != null) &#123;</span><br><span class="line">        nextProcessor.processRequest(upgradeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    //PrepRequestProcessor继续处理请求</span><br><span class="line">    nextProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、PrepRequestProcessor的run方法"><a href="#2、PrepRequestProcessor的run方法" class="headerlink" title="2、PrepRequestProcessor的run方法"></a>2、PrepRequestProcessor的run方法</h4><p>leader接受到follower转发的事务后PrepRequestProcessor来处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Request request = submittedRequests.take();</span><br><span class="line">            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">            if (request.type == OpCode.ping) &#123;</span><br><span class="line">                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Request.requestOfDeath == request) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RequestProcessorException e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;PrepRequestProcessor exited loop!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pRequest(request)与单机版相同，调用ProposalRequestProcessor继续处理request</p>
<h4 id="3、ProposalRequestProcessor的processRequest方法"><a href="#3、ProposalRequestProcessor的processRequest方法" class="headerlink" title="3、ProposalRequestProcessor的processRequest方法"></a>3、ProposalRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">    if (request instanceof LearnerSyncRequest)&#123;</span><br><span class="line">        zks.getLeader().processSync((LearnerSyncRequest)request);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //先交给CommitProcessor处理下，此时还未提交  </span><br><span class="line">        nextProcessor.processRequest(request);</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //发起一个事务投票</span><br><span class="line">                zks.getLeader().propose(request);</span><br><span class="line">            &#125; catch (XidRolloverException e) &#123;</span><br><span class="line">                throw new RequestProcessorException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            //事务写进log，并完成投票</span><br><span class="line">            syncProcessor.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、CommitProcessor的run方法"><a href="#4、CommitProcessor的run方法" class="headerlink" title="4、CommitProcessor的run方法"></a>4、CommitProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int requestsToProcess = 0;</span><br><span class="line">        boolean commitIsWaiting = false;</span><br><span class="line">        do &#123;</span><br><span class="line">            //有投票完成的事务需要commit</span><br><span class="line">            commitIsWaiting = !committedRequests.isEmpty();</span><br><span class="line">            //需要处理的事务</span><br><span class="line">            requestsToProcess =  queuedRequests.size();</span><br><span class="line">            if (requestsToProcess == 0 &amp;&amp; !commitIsWaiting)&#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    //没有事务待处理，等待</span><br><span class="line">                    while (!stopped &amp;&amp; requestsToProcess == 0</span><br><span class="line">                            &amp;&amp; !commitIsWaiting) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                        commitIsWaiting = !committedRequests.isEmpty();</span><br><span class="line">                        requestsToProcess = queuedRequests.size();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            Request request = null;</span><br><span class="line">            while (!stopped &amp;&amp; requestsToProcess &gt; 0</span><br><span class="line">                    &amp;&amp; (request = queuedRequests.poll()) != null) &#123;</span><br><span class="line">                requestsToProcess--;</span><br><span class="line">                //事务请求需要投票,该session有事务请求，则非事务请求也要按顺序处理</span><br><span class="line">                if (needCommit(request)</span><br><span class="line">                        || pendingRequests.containsKey(request.sessionId)) &#123;</span><br><span class="line">                    // Add request to pending</span><br><span class="line">                    LinkedList&lt;Request&gt; requests = pendingRequests</span><br><span class="line">                            .get(request.sessionId);</span><br><span class="line">                    if (requests == null) &#123;</span><br><span class="line">                        requests = new LinkedList&lt;Request&gt;();</span><br><span class="line">                        pendingRequests.put(request.sessionId, requests);</span><br><span class="line">                    &#125;</span><br><span class="line">                    requests.addLast(request);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //ToBeAppliedRequestProcessor继续处理</span><br><span class="line">                    sendToNextProcessor(request);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!pendingRequests.isEmpty() &amp;&amp; !committedRequests.isEmpty())&#123;</span><br><span class="line">                    //有投票完成，待处理的事务</span><br><span class="line">                    commitIsWaiting = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (commitIsWaiting &amp;&amp; !stopped)&#123;</span><br><span class="line">                //有事务正在处理，等待</span><br><span class="line">                waitForEmptyPool();</span><br><span class="line"></span><br><span class="line">                if (stopped)&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process committed head</span><br><span class="line">                if ((request = committedRequests.poll()) == null) &#123;</span><br><span class="line">                    throw new IOException(&quot;Error: committed head is null&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //该session下所有待处理的请求</span><br><span class="line">                LinkedList&lt;Request&gt; sessionQueue = pendingRequests</span><br><span class="line">                        .get(request.sessionId);</span><br><span class="line">                if (sessionQueue != null) &#123;</span><br><span class="line">                    // If session queue != null, then it is also not empty.</span><br><span class="line">                    Request topPending = sessionQueue.poll();</span><br><span class="line">                    if (request.cxid != topPending.cxid) &#123;</span><br><span class="line">                        sessionQueue.addFirst(topPending);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        topPending.setHdr(request.getHdr());</span><br><span class="line">                        topPending.setTxn(request.getTxn());</span><br><span class="line">                        topPending.zxid = request.zxid;</span><br><span class="line">                        request = topPending;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //ToBeAppliedRequestProcessor继续处理</span><br><span class="line">                sendToNextProcessor(request);</span><br><span class="line"></span><br><span class="line">                waitForEmptyPool();</span><br><span class="line"></span><br><span class="line">                //继续处理该session下的非事务请求</span><br><span class="line">                if (sessionQueue != null) &#123;</span><br><span class="line">                    while (!stopped &amp;&amp; !sessionQueue.isEmpty()</span><br><span class="line">                            &amp;&amp; !needCommit(sessionQueue.peek())) &#123;</span><br><span class="line">                        sendToNextProcessor(sessionQueue.poll());</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Remove empty queues</span><br><span class="line">                    if (sessionQueue.isEmpty()) &#123;</span><br><span class="line">                        pendingRequests.remove(request.sessionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!stoppedMainLoop);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;CommitProcessor exited loop!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（一、3）Leader的propose方法"><a href="#5、接（一、3）Leader的propose方法" class="headerlink" title="5、接（一、3）Leader的propose方法"></a>5、接（一、3）Leader的propose方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Proposal propose(Request request) throws XidRolloverException &#123;</span><br><span class="line">    //事务zxid超过32位，重新选举Leader</span><br><span class="line">    if ((request.zxid &amp; 0xffffffffL) == 0xffffffffL) &#123;</span><br><span class="line">        String msg =</span><br><span class="line">                &quot;zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start&quot;;</span><br><span class="line">        shutdown(msg);</span><br><span class="line">        throw new XidRolloverException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">    try &#123;</span><br><span class="line">        request.getHdr().serialize(boa, &quot;hdr&quot;);</span><br><span class="line">        if (request.getTxn() != null) &#123;</span><br><span class="line">            request.getTxn().serialize(boa, &quot;txn&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.warn(&quot;This really should be impossible&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,</span><br><span class="line">            baos.toByteArray(), null);</span><br><span class="line"></span><br><span class="line">    Proposal p = new Proposal();</span><br><span class="line">    p.packet = pp;</span><br><span class="line">    p.request = request;                </span><br><span class="line">    </span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">       p.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">               </span><br><span class="line">       if (request.getHdr().getType() == OpCode.reconfig)&#123;</span><br><span class="line">           self.setLastSeenQuorumVerifier(request.qv, true);                       </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if (self.getQuorumVerifier().getVersion()&lt;self.getLastSeenQuorumVerifier().getVersion()) &#123;</span><br><span class="line">           p.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">       &#125;</span><br><span class="line">               </span><br><span class="line">        lastProposed = p.packet.getZxid();</span><br><span class="line">        //leader发起提议的集合</span><br><span class="line">        outstandingProposals.put(lastProposed, p);</span><br><span class="line">        //向follower发送提议</span><br><span class="line">        sendPacket(pp);</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、AckRequestProcessor的processRequest方法"><a href="#6、AckRequestProcessor的processRequest方法" class="headerlink" title="6、AckRequestProcessor的processRequest方法"></a>6、AckRequestProcessor的processRequest方法</h4><p>syncProcessor将事务写入日志与单机版相同，之后AckRequestProcessor继续处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    QuorumPeer self = leader.self;</span><br><span class="line">    if(self != null)</span><br><span class="line">        //处理投票</span><br><span class="line">        leader.processAck(self.getId(), request.zxid, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、Leader的processAck方法"><a href="#7、Leader的processAck方法" class="headerlink" title="7、Leader的processAck方法"></a>7、Leader的processAck方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void processAck(long sid, long zxid, SocketAddress followerAddr) &#123;        </span><br><span class="line">    if (!allowedToCommit) return; // last op committed was a leader change - from now on </span><br><span class="line">                                 // the new leader should commit       </span><br><span class="line">    if ((zxid &amp; 0xffffffffL) == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;     </span><br><span class="line">    //没有待处理的提议   </span><br><span class="line">    if (outstandingProposals.size() == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //提议已被处理</span><br><span class="line">    if (lastCommitted &gt;= zxid) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //待投票的提议</span><br><span class="line">    Proposal p = outstandingProposals.get(zxid);</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //向提议中添加服务器</span><br><span class="line">    p.addAck(sid);        </span><br><span class="line">    </span><br><span class="line">    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);</span><br><span class="line"></span><br><span class="line">    if (hasCommitted &amp;&amp; p.request!=null &amp;&amp; p.request.getHdr().getType() == OpCode.reconfig)&#123;</span><br><span class="line">           long curZxid = zxid;</span><br><span class="line">       while (allowedToCommit &amp;&amp; hasCommitted &amp;&amp; p!=null)&#123;</span><br><span class="line">           curZxid++;</span><br><span class="line">           p = outstandingProposals.get(curZxid);</span><br><span class="line">           if (p !=null) hasCommitted = tryToCommit(p, curZxid, null);             </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、Leader的tryToCommit方法"><a href="#8、Leader的tryToCommit方法" class="headerlink" title="8、Leader的tryToCommit方法"></a>8、Leader的tryToCommit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">synchronized public boolean tryToCommit(Proposal p, long zxid, SocketAddress followerAddr) &#123;       </span><br><span class="line">   </span><br><span class="line">   if (outstandingProposals.containsKey(zxid - 1)) return false;</span><br><span class="line">   </span><br><span class="line">   //判断是否超过半数follower完成投票</span><br><span class="line">    if (!p.hasAllQuorums()) &#123;</span><br><span class="line">       return false;                 </span><br><span class="line">    &#125;  </span><br><span class="line">    //从待投票的集合中移除</span><br><span class="line">    outstandingProposals.remove(zxid);</span><br><span class="line">    </span><br><span class="line">    if (p.request != null) &#123;</span><br><span class="line">         //已投票待commit的request</span><br><span class="line">         toBeApplied.add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (p.request == null) &#123;</span><br><span class="line">        LOG.warn(&quot;Going to commmit null: &quot; + p);</span><br><span class="line">    &#125; else if (p.request.getHdr().getType() == OpCode.reconfig) &#123;       </span><br><span class="line">        Long designatedLeader = getDesignatedLeader(p, zxid);</span><br><span class="line">       </span><br><span class="line">        QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size()-1).getQuorumVerifier();</span><br><span class="line">   </span><br><span class="line">        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);</span><br><span class="line"></span><br><span class="line">        if (designatedLeader != self.getId()) &#123;</span><br><span class="line">            allowedToCommit = false;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        commitAndActivate(zxid, designatedLeader);</span><br><span class="line">        informAndActivate(p, designatedLeader);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //向follower发送commit</span><br><span class="line">        commit(zxid);</span><br><span class="line">        inform(p);</span><br><span class="line">    &#125;</span><br><span class="line">    //commit该事务</span><br><span class="line">    zk.commitProcessor.commit(p.request);</span><br><span class="line">    if(pendingSyncs.containsKey(zxid))&#123;</span><br><span class="line">        for(LearnerSyncRequest r: pendingSyncs.remove(zxid)) &#123;</span><br><span class="line">            sendSync(r);</span><br><span class="line">        &#125;               </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    return  true;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、CommitProcessor的commit方法"><a href="#9、CommitProcessor的commit方法" class="headerlink" title="9、CommitProcessor的commit方法"></a>9、CommitProcessor的commit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void commit(Request request) &#123;</span><br><span class="line">    if (stopped || request == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //事务加入已commit集合</span><br><span class="line">    committedRequests.add(request);</span><br><span class="line">    wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ToBeAppliedRequestProcessor的processRequest方法"><a href="#10、ToBeAppliedRequestProcessor的processRequest方法" class="headerlink" title="10、ToBeAppliedRequestProcessor的processRequest方法"></a>10、ToBeAppliedRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">        //FinalRequestProcessor处理请求，修改内存db结构，与单机版相同</span><br><span class="line">        next.processRequest(request);</span><br><span class="line"></span><br><span class="line">        // 事务请求,处理完内存之后将事务提议从toBeApplied集合中删除</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            long zxid = request.getHdr().getZxid();</span><br><span class="line">            Iterator&lt;Proposal&gt; iter = leader.toBeApplied.iterator();</span><br><span class="line">            if (iter.hasNext()) &#123;</span><br><span class="line">                Proposal p = iter.next();</span><br><span class="line">                if (p.request != null &amp;&amp; p.request.zxid == zxid) &#123;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、分布式CREATE事务处理过程Follower部分"><a href="#二、分布式CREATE事务处理过程Follower部分" class="headerlink" title="二、分布式CREATE事务处理过程Follower部分"></a>二、分布式CREATE事务处理过程Follower部分</h3><h4 id="1、FollowerRequestProcessor的run方法"><a href="#1、FollowerRequestProcessor的run方法" class="headerlink" title="1、FollowerRequestProcessor的run方法"></a>1、FollowerRequestProcessor的run方法</h4><p>前面的处理于单机版相同，分布式Follower的firstProcessor为FollowerRequestProcessor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!finished) &#123;</span><br><span class="line">            Request request = queuedRequests.take();</span><br><span class="line">            if (request == Request.requestOfDeath) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //先交给CommitProcessor，最终投票通过后，会通过CommitProcessor的commit方法最终提交事务 </span><br><span class="line">            nextProcessor.processRequest(request);</span><br><span class="line"></span><br><span class="line">            //只有事务请求才转发给leader，进行投票  </span><br><span class="line">            switch (request.type) &#123;</span><br><span class="line">            case OpCode.sync:</span><br><span class="line">                zks.pendingSyncs.add(request);</span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                break;</span><br><span class="line">            case OpCode.create:</span><br><span class="line">            case OpCode.create2:</span><br><span class="line">            case OpCode.createTTL:</span><br><span class="line">            case OpCode.createContainer:</span><br><span class="line">            case OpCode.delete:</span><br><span class="line">            case OpCode.deleteContainer:</span><br><span class="line">            case OpCode.setData:</span><br><span class="line">            case OpCode.reconfig:</span><br><span class="line">            case OpCode.setACL:</span><br><span class="line">            case OpCode.multi:</span><br><span class="line">            case OpCode.check:</span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                break;</span><br><span class="line">            case OpCode.createSession:</span><br><span class="line">            case OpCode.closeSession:</span><br><span class="line">                // Don&apos;t forward local sessions to the leader.</span><br><span class="line">                if (!request.isLocalSession()) &#123;</span><br><span class="line">                    zks.getFollower().request(request);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、Learner的request方法"><a href="#2、Learner的request方法" class="headerlink" title="2、Learner的request方法"></a>2、Learner的request方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void request(Request request) throws IOException &#123;</span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    DataOutputStream oa = new DataOutputStream(baos);</span><br><span class="line">    oa.writeLong(request.sessionId);</span><br><span class="line">    oa.writeInt(request.cxid);</span><br><span class="line">    oa.writeInt(request.type);</span><br><span class="line">    if (request.request != null) &#123;</span><br><span class="line">        request.request.rewind();</span><br><span class="line">        int len = request.request.remaining();</span><br><span class="line">        byte b[] = new byte[len];</span><br><span class="line">        request.request.get(b);</span><br><span class="line">        request.request.rewind();</span><br><span class="line">        oa.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">    oa.close();</span><br><span class="line">    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos</span><br><span class="line">            .toByteArray(), request.authInfo);</span><br><span class="line">    //转发事务请求给leader</span><br><span class="line">    writePacket(qp, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、Follower的readPacket方法"><a href="#3、Follower的readPacket方法" class="headerlink" title="3、Follower的readPacket方法"></a>3、Follower的readPacket方法</h4><p>Follower的followLeader的中的主循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void readPacket(QuorumPacket pp) throws IOException &#123;</span><br><span class="line">    synchronized (leaderIs) &#123;</span><br><span class="line">        //读取leader返回数据</span><br><span class="line">        leaderIs.readRecord(pp, &quot;packet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;</span><br><span class="line">    if (pp.getType() == Leader.PING) &#123;</span><br><span class="line">        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">        ZooTrace.logQuorumPacket(LOG, traceMask, &apos;i&apos;, pp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、Follower的processPacket方法"><a href="#4、Follower的processPacket方法" class="headerlink" title="4、Follower的processPacket方法"></a>4、Follower的processPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected void processPacket(QuorumPacket qp) throws Exception&#123;</span><br><span class="line">     switch (qp.getType()) &#123;</span><br><span class="line">     case Leader.PING:            </span><br><span class="line">         ping(qp);            </span><br><span class="line">         break;</span><br><span class="line">     case Leader.PROPOSAL:           </span><br><span class="line">         TxnHeader hdr = new TxnHeader();</span><br><span class="line">         Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);</span><br><span class="line">         lastQueued = hdr.getZxid();</span><br><span class="line">         </span><br><span class="line">         if (hdr.getType() == OpCode.reconfig)&#123;</span><br><span class="line">            SetDataTxn setDataTxn = (SetDataTxn) txn;       </span><br><span class="line">            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));</span><br><span class="line">            self.setLastSeenQuorumVerifier(qv, true);                               </span><br><span class="line">         &#125;</span><br><span class="line">         //添加日志文件，并完成投票</span><br><span class="line">         fzk.logRequest(hdr, txn);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.COMMIT:</span><br><span class="line">         //Leader完成事务投票，发来commit</span><br><span class="line">         fzk.commit(qp.getZxid());</span><br><span class="line">         break;            </span><br><span class="line">     case Leader.COMMITANDACTIVATE:</span><br><span class="line">        // get the new configuration from the request</span><br><span class="line">        Request request = fzk.pendingTxns.element();</span><br><span class="line">        SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();                                                                                                      </span><br><span class="line">        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                                </span><br><span class="line"> </span><br><span class="line">        // get new designated leader from (current) leader&apos;s message</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    </span><br><span class="line">        long suggestedLeaderId = buffer.getLong();</span><br><span class="line">         boolean majorChange = </span><br><span class="line">                self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);</span><br><span class="line">        // commit (writes the new config to ZK tree (/zookeeper/config)                     </span><br><span class="line">        fzk.commit(qp.getZxid());</span><br><span class="line">         if (majorChange) &#123;</span><br><span class="line">            throw new Exception(&quot;changes proposed in reconfig&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">     case Leader.UPTODATE:</span><br><span class="line">         LOG.error(&quot;Received an UPTODATE message after Follower started&quot;);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.REVALIDATE:</span><br><span class="line">         revalidate(qp);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.SYNC:</span><br><span class="line">         fzk.sync();</span><br><span class="line">         break;</span><br><span class="line">     default:</span><br><span class="line">         LOG.warn(&quot;Unknown packet type: &#123;&#125;&quot;, LearnerHandler.packetToString(qp));</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、FollowerZooKeeperServer的logRequest方法"><a href="#5、FollowerZooKeeperServer的logRequest方法" class="headerlink" title="5、FollowerZooKeeperServer的logRequest方法"></a>5、FollowerZooKeeperServer的logRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void logRequest(TxnHeader hdr, Record txn) &#123;</span><br><span class="line">    Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());</span><br><span class="line">    if ((request.zxid &amp; 0xffffffffL) != 0) &#123;</span><br><span class="line">        pendingTxns.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    syncProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower的SyncRequestProcessor与Leader相同，后续处理器为SendAckRequestProcessor</p>
<h4 id="6、SendAckRequestProcessor的processRequest方法"><a href="#6、SendAckRequestProcessor的processRequest方法" class="headerlink" title="6、SendAckRequestProcessor的processRequest方法"></a>6、SendAckRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request si) &#123;</span><br><span class="line">    if(si.type != OpCode.sync)&#123;</span><br><span class="line">        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null,</span><br><span class="line">            null);</span><br><span class="line">        try &#123;</span><br><span class="line">            //向leader发送事务成功的投票信息</span><br><span class="line">            learner.writePacket(qp, false);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>follower接到Leader发来的commit之后，CommitProcessor完成commit，FinalRequestProcessor将事务写进内存db。<br>Create事务到此就结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（2）/" data-id="cjix6ii7b000tegueb89odjg6" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-zookeeper源码/zookeeper源码分布式服务端（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（1）/" class="article-date">
  <time datetime="2018-04-07T04:44:43.467Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（1）/">zookeeper源码分布式服务端（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper源码分布服务端（1）-服务端启动过程"><a href="#zookeeper源码分布服务端（1）-服务端启动过程" class="headerlink" title="zookeeper源码分布服务端（1） 服务端启动过程"></a>zookeeper源码分布服务端（1） 服务端启动过程</h2><h3 id="一、LEADER选举过程"><a href="#一、LEADER选举过程" class="headerlink" title="一、LEADER选举过程"></a>一、LEADER选举过程</h3><h4 id="1、QuorumPeerMain的runFromConfig方法"><a href="#1、QuorumPeerMain的runFromConfig方法" class="headerlink" title="1、QuorumPeerMain的runFromConfig方法"></a>1、QuorumPeerMain的runFromConfig方法</h4><p>分布式zookeeper启动入口为QuorumPeerMain的main方法，之后调用了runFromConfig方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public void runFromConfig(QuorumPeerConfig config)</span><br><span class="line">        throws IOException, AdminServerException</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  try &#123;</span><br><span class="line">      ServerCnxnFactory cnxnFactory = null;</span><br><span class="line">      ServerCnxnFactory secureCnxnFactory = null;</span><br><span class="line">      //创建连接工厂与单机版相同</span><br><span class="line">      if (config.getClientPortAddress() != null) &#123;</span><br><span class="line">          cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">          cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                  config.getMaxClientCnxns(),</span><br><span class="line">                  false);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (config.getSecureClientPortAddress() != null) &#123;</span><br><span class="line">          secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">          secureCnxnFactory.configure(config.getSecureClientPortAddress(),</span><br><span class="line">                  config.getMaxClientCnxns(),</span><br><span class="line">                  true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      quorumPeer = getQuorumPeer();</span><br><span class="line">      //设置日志及快照文件</span><br><span class="line">      quorumPeer.setTxnFactory(new FileTxnSnapLog(</span><br><span class="line">                  config.getDataLogDir(),</span><br><span class="line">                  config.getDataDir()));</span><br><span class="line">      quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());</span><br><span class="line">      quorumPeer.enableLocalSessionsUpgrading(</span><br><span class="line">          config.isLocalSessionsUpgradingEnabled());</span><br><span class="line">      //集群机器地址</span><br><span class="line">      quorumPeer.setQuorumPeers(config.getAllMembers());</span><br><span class="line">      //leader选择器类型</span><br><span class="line">      quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">      //本机的集群编号</span><br><span class="line">      quorumPeer.setMyid(config.getServerId());</span><br><span class="line">      //服务器单位时间</span><br><span class="line">      quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">      quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">      quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">      //LF初始通信时限</span><br><span class="line">      quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">      //LF同步通信时限</span><br><span class="line">      quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">      quorumPeer.setConfigFileName(config.getConfigFilename());</span><br><span class="line">      //内存数据</span><br><span class="line">      quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));</span><br><span class="line">      //投票决定方式，默认超过半数就通过  </span><br><span class="line">      quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);</span><br><span class="line">      if (config.getLastSeenQuorumVerifier()!=null) &#123;</span><br><span class="line">          quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);</span><br><span class="line">      &#125;</span><br><span class="line">      quorumPeer.initConfigInZKDatabase();</span><br><span class="line">      //设置连接工厂</span><br><span class="line">      quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">      quorumPeer.setSecureCnxnFactory(secureCnxnFactory);</span><br><span class="line">      quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line">      quorumPeer.setSyncEnabled(config.getSyncEnabled());</span><br><span class="line">      quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</span><br><span class="line"></span><br><span class="line">      // sets quorum sasl authentication configurations</span><br><span class="line">      quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</span><br><span class="line">      if(quorumPeer.isQuorumSaslAuthEnabled())&#123;</span><br><span class="line">          quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</span><br><span class="line">          quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</span><br><span class="line">          quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</span><br><span class="line">          quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</span><br><span class="line">          quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</span><br><span class="line">      &#125;</span><br><span class="line">      quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</span><br><span class="line">      quorumPeer.initialize();</span><br><span class="line">      //启动主线程 </span><br><span class="line">      quorumPeer.start();</span><br><span class="line">      quorumPeer.join();</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      // warn, but generally this is ok</span><br><span class="line">      LOG.warn(&quot;Quorum Peer interrupted&quot;, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、QuorumPeer的start方法"><a href="#2、QuorumPeer的start方法" class="headerlink" title="2、QuorumPeer的start方法"></a>2、QuorumPeer的start方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    if (!getView().containsKey(myid)) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //恢复本机数据</span><br><span class="line">    loadDataBase();</span><br><span class="line">    //启动连接工厂</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    try &#123;</span><br><span class="line">        //内嵌的管理控制台是通过jetty启动,占用8080 端口</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; catch (AdminServerException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //开始投票</span><br><span class="line">    startLeaderElection();</span><br><span class="line">    //主流程</span><br><span class="line">    super.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、QuorumPeer的startLeaderElection方法"><a href="#3、QuorumPeer的startLeaderElection方法" class="headerlink" title="3、QuorumPeer的startLeaderElection方法"></a>3、QuorumPeer的startLeaderElection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void startLeaderElection() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            //首次投票给自己</span><br><span class="line">            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        throw re;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建选举器</span><br><span class="line">    this.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、QuorumPeer的createElectionAlgorithm方法"><a href="#4、QuorumPeer的createElectionAlgorithm方法" class="headerlink" title="4、QuorumPeer的createElectionAlgorithm方法"></a>4、QuorumPeer的createElectionAlgorithm方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> protected Election createElectionAlgorithm(int electionAlgorithm)&#123;</span><br><span class="line">    Election le=null;</span><br><span class="line">    //TODO: use a factory rather than a switch</span><br><span class="line">    switch (electionAlgorithm) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        le = new AuthFastLeaderElection(this);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        le = new AuthFastLeaderElection(this, true);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        //leader选举通信管理类</span><br><span class="line">        qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        if(listener != null)&#123;</span><br><span class="line">            //启动已绑定3888端口的选举线程，等待集群其他机器连接</span><br><span class="line">            listener.start();</span><br><span class="line">            //基于TCP的选举算法</span><br><span class="line">            FastLeaderElection fle = new FastLeaderElection(this, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG.error(&quot;Null listener when initializing cnx manager&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        assert false;</span><br><span class="line">    &#125;</span><br><span class="line">    return le;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、实例化QuorumCnxManager"><a href="#5、实例化QuorumCnxManager" class="headerlink" title="5、实例化QuorumCnxManager"></a>5、实例化QuorumCnxManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public QuorumCnxManager(QuorumPeer self,</span><br><span class="line">                        final long mySid,</span><br><span class="line">                        Map&lt;Long,QuorumPeer.QuorumServer&gt; view,</span><br><span class="line">                        QuorumAuthServer authServer,</span><br><span class="line">                        QuorumAuthLearner authLearner,</span><br><span class="line">                        int socketTimeout,</span><br><span class="line">                        boolean listenOnAllIPs,</span><br><span class="line">                        int quorumCnxnThreadsSize,</span><br><span class="line">                        boolean quorumSaslAuthEnabled) &#123;</span><br><span class="line">    //接收到的投票消息队列</span><br><span class="line">    this.recvQueue = new ArrayBlockingQueue&lt;Message&gt;(RECV_CAPACITY);</span><br><span class="line">    //往其他服务器待发送消息队列</span><br><span class="line">    this.queueSendMap = new ConcurrentHashMap&lt;Long, ArrayBlockingQueue&lt;ByteBuffer&gt;&gt;();</span><br><span class="line">    //往其他服务器发送消息线程</span><br><span class="line">    this.senderWorkerMap = new ConcurrentHashMap&lt;Long, SendWorker&gt;();</span><br><span class="line">    //往其他服务器发送的最新消息</span><br><span class="line">    this.lastMessageSent = new ConcurrentHashMap&lt;Long, ByteBuffer&gt;();</span><br><span class="line">    </span><br><span class="line">    String cnxToValue = System.getProperty(&quot;zookeeper.cnxTimeout&quot;);</span><br><span class="line">    if(cnxToValue != null)&#123;</span><br><span class="line">        this.cnxTO = Integer.parseInt(cnxToValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.self = self;</span><br><span class="line"></span><br><span class="line">    this.mySid = mySid;</span><br><span class="line">    this.socketTimeout = socketTimeout;</span><br><span class="line">    this.view = view;</span><br><span class="line">    //各服务器ip</span><br><span class="line">    this.listenOnAllIPs = listenOnAllIPs;</span><br><span class="line"></span><br><span class="line">    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,</span><br><span class="line">            quorumSaslAuthEnabled);</span><br><span class="line"></span><br><span class="line">    //等待其他服务器连接的线程</span><br><span class="line">    listener = new Listener();</span><br><span class="line">    listener.setName(&quot;QuorumPeerListener&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（一、4）Listener的run方法"><a href="#6、接（一、4）Listener的run方法" class="headerlink" title="6、接（一、4）Listener的run方法"></a>6、接（一、4）Listener的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //重连次数</span><br><span class="line">    int numRetries = 0;</span><br><span class="line">    InetSocketAddress addr;</span><br><span class="line">    Socket client = null;</span><br><span class="line">    while((!shutdown) &amp;&amp; (numRetries &lt; 3))&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //启动Socket服务端</span><br><span class="line">            ss = new ServerSocket();</span><br><span class="line">            ss.setReuseAddress(true);</span><br><span class="line">            if (self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">                int port = self.getElectionAddress().getPort();</span><br><span class="line">                addr = new InetSocketAddress(port);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Resolve hostname for this server in case the</span><br><span class="line">                // underlying ip address has changed.</span><br><span class="line">                self.recreateSocketAddresses(self.getId());</span><br><span class="line">                addr = self.getElectionAddress();</span><br><span class="line">            &#125;</span><br><span class="line">            setName(addr.toString());</span><br><span class="line">            ss.bind(addr);</span><br><span class="line">            while (!shutdown) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    client = ss.accept();</span><br><span class="line">                    setSockOpts(client);</span><br><span class="line">                    LOG.info(&quot;Received connection request &quot;</span><br><span class="line">                             + client.getRemoteSocketAddress());</span><br><span class="line">                    if (quorumSaslAuthEnabled) &#123;</span><br><span class="line">                        receiveConnectionAsync(client);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //处理接收到的连接</span><br><span class="line">                        receiveConnection(client);</span><br><span class="line">                    &#125;</span><br><span class="line">                    numRetries = 0;</span><br><span class="line">                &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (shutdown) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            numRetries++;</span><br><span class="line">            try &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch </span><br><span class="line">            ...</span><br><span class="line">            closeSocket(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、Listener的receiveConnection方法"><a href="#7、Listener的receiveConnection方法" class="headerlink" title="7、Listener的receiveConnection方法"></a>7、Listener的receiveConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void receiveConnection(final Socket sock) &#123;</span><br><span class="line">    DataInputStream din = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        din = new DataInputStream(</span><br><span class="line">                new BufferedInputStream(sock.getInputStream()));</span><br><span class="line">        //处理收到连接的数据</span><br><span class="line">        handleConnection(sock, din);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、Listener的handleConnection方法"><a href="#8、Listener的handleConnection方法" class="headerlink" title="8、Listener的handleConnection方法"></a>8、Listener的handleConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private void handleConnection(Socket sock, DataInputStream din)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    Long sid = null, protocolVersion = null;</span><br><span class="line">    InetSocketAddress electionAddr = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //协议版本号</span><br><span class="line">        protocolVersion = din.readLong();</span><br><span class="line">        if (protocolVersion &gt;= 0) &#123; // this is a server id and not a protocol version</span><br><span class="line">            sid = protocolVersion;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                InitialMessage init = InitialMessage.parse(protocolVersion, din);</span><br><span class="line">                sid = init.sid;</span><br><span class="line">                //连接地址</span><br><span class="line">                electionAddr = init.electionAddr;</span><br><span class="line">            &#125; catch (InitialMessage.InitialMessageException ex) &#123;</span><br><span class="line">                LOG.error(ex.toString());</span><br><span class="line">                closeSocket(sock);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //连接的是只读服务器</span><br><span class="line">        if (sid == QuorumPeer.OBSERVER_ID) &#123;</span><br><span class="line">            sid = observerCounter.getAndDecrement();</span><br><span class="line">            LOG.info(&quot;Setting arbitrary identifier to observer: &quot; + sid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do authenticating learner</span><br><span class="line">    authServer.authenticate(sock, din);</span><br><span class="line"></span><br><span class="line">    //由序号大的服务器向小的发起连接</span><br><span class="line">    if (sid &lt; self.getId()) &#123;</span><br><span class="line">        //关掉发送消息线程</span><br><span class="line">        SendWorker sw = senderWorkerMap.get(sid);</span><br><span class="line">        if (sw != null) &#123;</span><br><span class="line">            sw.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭连接</span><br><span class="line">        closeSocket(sock);</span><br><span class="line"></span><br><span class="line">        if (electionAddr != null) &#123;</span><br><span class="line">            //发起连接</span><br><span class="line">            connectOne(sid, electionAddr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            connectOne(sid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123; // Otherwise start worker threads to receive data.</span><br><span class="line">        //发送消息线程</span><br><span class="line">        SendWorker sw = new SendWorker(sock, sid);</span><br><span class="line">        //接受消息线程</span><br><span class="line">        RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span><br><span class="line">        sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">        SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line">        //关闭旧线程</span><br><span class="line">        if (vsw != null) &#123;</span><br><span class="line">            vsw.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        //添加新线程</span><br><span class="line">        senderWorkerMap.put(sid, sw);</span><br><span class="line">        //等待发送的投票信息</span><br><span class="line">        queueSendMap.putIfAbsent(sid,</span><br><span class="line">                new ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));</span><br><span class="line">        </span><br><span class="line">        sw.start();</span><br><span class="line">        rw.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、Listener的connectOne方法"><a href="#9、Listener的connectOne方法" class="headerlink" title="9、Listener的connectOne方法"></a>9、Listener的connectOne方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">synchronized private boolean connectOne(long sid, InetSocketAddress electionAddr)&#123;</span><br><span class="line">    if (senderWorkerMap.get(sid) != null) &#123;</span><br><span class="line">        //发送消息线程已存在，则已连接上</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Socket sock = null;</span><br><span class="line">    try &#123;</span><br><span class="line">         sock = new Socket();</span><br><span class="line">         setSockOpts(sock);</span><br><span class="line">         //发起连接</span><br><span class="line">         sock.connect(electionAddr, cnxTO);</span><br><span class="line">        if (quorumSaslAuthEnabled) &#123;</span><br><span class="line">            initiateConnectionAsync(sock, sid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //初始化连接</span><br><span class="line">            initiateConnection(sock, sid);</span><br><span class="line">        &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125; catch (UnresolvedAddressException e) &#123;</span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         throw e;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、Listener的startConnection方法"><a href="#10、Listener的startConnection方法" class="headerlink" title="10、Listener的startConnection方法"></a>10、Listener的startConnection方法</h4><p>initiateConnection方法调用startConnection方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private boolean startConnection(Socket sock, Long sid)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    DataOutputStream dout = null;</span><br><span class="line">    DataInputStream din = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        dout = new DataOutputStream(buf);</span><br><span class="line">        //发送协议版本号</span><br><span class="line">        dout.writeLong(PROTOCOL_VERSION);</span><br><span class="line">        //发送服务器编号</span><br><span class="line">        dout.writeLong(self.getId());</span><br><span class="line">        String addr = self.getElectionAddress().getHostString() + &quot;:&quot; + self.getElectionAddress().getPort();</span><br><span class="line">        byte[] addr_bytes = addr.getBytes();</span><br><span class="line">        //发送本机地址</span><br><span class="line">        dout.writeInt(addr_bytes.length);</span><br><span class="line">        dout.write(addr_bytes);</span><br><span class="line">        dout.flush();</span><br><span class="line"></span><br><span class="line">        din = new DataInputStream(</span><br><span class="line">                new BufferedInputStream(sock.getInputStream()));</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // authenticate learner</span><br><span class="line">    QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);</span><br><span class="line">    if (qps != null) &#123;</span><br><span class="line">        // TODO - investigate why reconfig makes qps null.</span><br><span class="line">        authLearner.authenticate(sock, qps.hostname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 序号大的服务器向序号小的服务器发起连接</span><br><span class="line">    if (sid &gt; self.getId()) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        // Otherwise proceed with the connection</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //发送数据线程</span><br><span class="line">        SendWorker sw = new SendWorker(sock, sid);</span><br><span class="line">        //接受数据线程</span><br><span class="line">        RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span><br><span class="line">        sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">        SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line">        </span><br><span class="line">        if(vsw != null)</span><br><span class="line">            vsw.finish();</span><br><span class="line">        //发送消息线程Map</span><br><span class="line">        senderWorkerMap.put(sid, sw);</span><br><span class="line">        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">                    SEND_CAPACITY));</span><br><span class="line">        </span><br><span class="line">        sw.start();</span><br><span class="line">        rw.start();</span><br><span class="line">        </span><br><span class="line">        return true;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="11、SendWorker的run方法"><a href="#11、SendWorker的run方法" class="headerlink" title="11、SendWorker的run方法"></a>11、SendWorker的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //线程数量加一</span><br><span class="line">            threadCnt.incrementAndGet();</span><br><span class="line">            try &#123;</span><br><span class="line">                //待发送的数据队列</span><br><span class="line">                ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">                if (bq == null || isSendQueueEmpty(bq)) &#123;</span><br><span class="line">                    //无待发送数据，发送上次发送的数据</span><br><span class="line">                   ByteBuffer b = lastMessageSent.get(sid);</span><br><span class="line">                   if (b != null) &#123;</span><br><span class="line">                       send(b);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                this.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                while (running &amp;&amp; !shutdown &amp;&amp; sock != null) &#123;</span><br><span class="line"></span><br><span class="line">                    ByteBuffer b = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap</span><br><span class="line">                                .get(sid);</span><br><span class="line">                        if (bq != null) &#123;</span><br><span class="line">                            //获取待发送数据</span><br><span class="line">                            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if(b != null)&#123;</span><br><span class="line">                            lastMessageSent.put(sid, b);</span><br><span class="line">                            //发送数据</span><br><span class="line">                            send(b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            this.finish();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、接（一、10）RecvWorker的run方法"><a href="#12、接（一、10）RecvWorker的run方法" class="headerlink" title="12、接（一、10）RecvWorker的run方法"></a>12、接（一、10）RecvWorker的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //线程数量加一</span><br><span class="line">    threadCnt.incrementAndGet();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (running &amp;&amp; !shutdown &amp;&amp; sock != null) &#123;</span><br><span class="line">            //消息长度</span><br><span class="line">            int length = din.readInt();</span><br><span class="line">            if (length &lt;= 0 || length &gt; PACKETMAXSIZE) &#123;</span><br><span class="line">                throw new IOException(</span><br><span class="line">                        &quot;Received packet with invalid packet: &quot;</span><br><span class="line">                                + length);</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * Allocates a new ByteBuffer to receive the message</span><br><span class="line">             */</span><br><span class="line">            byte[] msgArray = new byte[length];</span><br><span class="line">            din.readFully(msgArray, 0, length);</span><br><span class="line">            ByteBuffer message = ByteBuffer.wrap(msgArray);</span><br><span class="line">            //读取到的数据包转换成投票消息加入队列</span><br><span class="line">            addToRecvQueue(new Message(message.duplicate(), sid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">        sw.finish();</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、接（一、4）FastLeaderElection实例化"><a href="#13、接（一、4）FastLeaderElection实例化" class="headerlink" title="13、接（一、4）FastLeaderElection实例化"></a>13、接（一、4）FastLeaderElection实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager)&#123;</span><br><span class="line">    this.stop = false;</span><br><span class="line">    this.manager = manager;</span><br><span class="line">    starter(self, manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、FastLeaderElection的starter方法"><a href="#14、FastLeaderElection的starter方法" class="headerlink" title="14、FastLeaderElection的starter方法"></a>14、FastLeaderElection的starter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void starter(QuorumPeer self, QuorumCnxManager manager) &#123;</span><br><span class="line">    this.self = self;</span><br><span class="line">    proposedLeader = -1;</span><br><span class="line">    proposedZxid = -1;</span><br><span class="line"></span><br><span class="line">    //待发送的消息队列</span><br><span class="line">    sendqueue = new LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">    //接收到的消息队列</span><br><span class="line">    recvqueue = new LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">    this.messenger = new Messenger(manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、Messenger的start方法"><a href="#15、Messenger的start方法" class="headerlink" title="15、Messenger的start方法"></a>15、Messenger的start方法</h4><p>FastLeaderElection的start方法调用Messenger的start方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void start()&#123;</span><br><span class="line">    //WorkerSender发送投票消息线程</span><br><span class="line">    this.wsThread.start();</span><br><span class="line">    //WorkerReceiver接受投票消息线程</span><br><span class="line">    this.wrThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="16、WorkerSender的run方法"><a href="#16、WorkerSender的run方法" class="headerlink" title="16、WorkerSender的run方法"></a>16、WorkerSender的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    while (!stop) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //从待发送消息队列获取消息</span><br><span class="line">            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);</span><br><span class="line">            if(m == null) continue;</span><br><span class="line">            //处理待发送消息</span><br><span class="line">            process(m);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、WorkerSender的process方法"><a href="#17、WorkerSender的process方法" class="headerlink" title="17、WorkerSender的process方法"></a>17、WorkerSender的process方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void process(ToSend m) &#123;</span><br><span class="line">    //待发送投票消息转换为字节数据</span><br><span class="line">    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),</span><br><span class="line">                                        m.leader,</span><br><span class="line">                                        m.zxid,</span><br><span class="line">                                        m.electionEpoch,</span><br><span class="line">                                        m.peerEpoch,</span><br><span class="line">                                        m.configData);</span><br><span class="line">    //发送处理转换后的数据</span><br><span class="line">    manager.toSend(m.sid, requestBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18、WorkerSender的toSend方法"><a href="#18、WorkerSender的toSend方法" class="headerlink" title="18、WorkerSender的toSend方法"></a>18、WorkerSender的toSend方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void toSend(Long sid, ByteBuffer b) &#123;</span><br><span class="line">    if (this.mySid == sid) &#123;</span><br><span class="line">        //发送给自己的数据，直接添加入接受到的数据队列</span><br><span class="line">         b.position(0);</span><br><span class="line">         addToRecvQueue(new Message(b.duplicate(), sid));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //Start a new connection if doesn&apos;t have one already.</span><br><span class="line">          </span><br><span class="line">        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = new ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">            SEND_CAPACITY);</span><br><span class="line">        //如果没有，添加该服务器待发送数据队列</span><br><span class="line">        ArrayBlockingQueue&lt;ByteBuffer&gt; oldq = queueSendMap.putIfAbsent(sid, bq);</span><br><span class="line">        //将待发送数据加入队列</span><br><span class="line">        if (oldq != null) &#123;</span><br><span class="line">            addToSendQueue(oldq, b);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addToSendQueue(bq, b);</span><br><span class="line">        &#125;</span><br><span class="line">        //发起连接</span><br><span class="line">        connectOne(sid);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19、（接一、15）WorkerReceiver的run方法"><a href="#19、（接一、15）WorkerReceiver的run方法" class="headerlink" title="19、（接一、15）WorkerReceiver的run方法"></a>19、（接一、15）WorkerReceiver的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    Message response;</span><br><span class="line">    while (!stop) &#123;</span><br><span class="line">        // Sleeps on receive</span><br><span class="line">        try &#123;</span><br><span class="line">            //接收到的数据</span><br><span class="line">            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);</span><br><span class="line">            if(response == null) continue;</span><br><span class="line"></span><br><span class="line">            // The current protocol and two previous generations all send at least 28 bytes</span><br><span class="line">            if (response.buffer.capacity() &lt; 28) &#123;</span><br><span class="line">                LOG.error(&quot;Got a short response: &quot; + response.buffer.capacity());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // this is the backwardCompatibility mode in place before ZK-107</span><br><span class="line">            // It is for a version of the protocol in which we didn&apos;t send peer epoch</span><br><span class="line">            // With peer epoch and version the message became 40 bytes</span><br><span class="line">            boolean backCompatibility28 = (response.buffer.capacity() == 28);</span><br><span class="line"></span><br><span class="line">            // this is the backwardCompatibility mode for no version information</span><br><span class="line">            boolean backCompatibility40 = (response.buffer.capacity() == 40);</span><br><span class="line">            </span><br><span class="line">            response.buffer.clear();</span><br><span class="line"></span><br><span class="line">            //实例化消息对象</span><br><span class="line">            Notification n = new Notification();</span><br><span class="line"></span><br><span class="line">            int rstate = response.buffer.getInt();</span><br><span class="line">            long rleader = response.buffer.getLong();</span><br><span class="line">            long rzxid = response.buffer.getLong();</span><br><span class="line">            long relectionEpoch = response.buffer.getLong();</span><br><span class="line">            long rpeerepoch;</span><br><span class="line"></span><br><span class="line">            int version = 0x0;</span><br><span class="line">            if (!backCompatibility28) &#123;</span><br><span class="line">                rpeerepoch = response.buffer.getLong();</span><br><span class="line">                if (!backCompatibility40) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * Version added in 3.4.6</span><br><span class="line">                     */</span><br><span class="line">                    </span><br><span class="line">                    version = response.buffer.getInt();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    LOG.info(&quot;Backward compatibility mode (36 bits), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.info(&quot;Backward compatibility mode (28 bits), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QuorumVerifier rqv = null;</span><br><span class="line"></span><br><span class="line">            //消息中含有配置文件</span><br><span class="line">            if (version &gt; 0x1) &#123;</span><br><span class="line">                ...  </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.info(&quot;Backward compatibility mode (before reconfig), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            //该服务器不具有选举权限</span><br><span class="line">            if(!self.getCurrentAndNextConfigVoters().contains(response.sid)) &#123;</span><br><span class="line">                Vote current = self.getCurrentVote();</span><br><span class="line">                QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                ToSend notmsg = new ToSend(ToSend.mType.notification,</span><br><span class="line">                        current.getId(),</span><br><span class="line">                        current.getZxid(),</span><br><span class="line">                        logicalclock.get(),</span><br><span class="line">                        self.getPeerState(),</span><br><span class="line">                        response.sid,</span><br><span class="line">                        current.getPeerEpoch(),</span><br><span class="line">                        qv.toString().getBytes());</span><br><span class="line">                //直接发送本机的投票信息</span><br><span class="line">                sendqueue.offer(notmsg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //投票服务器的状态</span><br><span class="line">                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                switch (rstate) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.FOLLOWING;</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.LEADING;</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.OBSERVING;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //初始化投票信息</span><br><span class="line">                n.leader = rleader;</span><br><span class="line">                n.zxid = rzxid;</span><br><span class="line">                n.electionEpoch = relectionEpoch;</span><br><span class="line">                n.state = ackstate;</span><br><span class="line">                n.sid = response.sid;</span><br><span class="line">                n.peerEpoch = rpeerepoch;</span><br><span class="line">                n.version = version;</span><br><span class="line">                n.qv = rqv;</span><br><span class="line">                //本机是选举状态</span><br><span class="line">                if(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                    //消息添加到接受队列</span><br><span class="line">                    recvqueue.offer(n);</span><br><span class="line">                    //发送消息的服务器为选举状态</span><br><span class="line">                    if((ackstate == QuorumPeer.ServerState.LOOKING)</span><br><span class="line">                            &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;</span><br><span class="line">                        Vote v = getVote();</span><br><span class="line">                        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                        ToSend notmsg = new ToSend(ToSend.mType.notification,</span><br><span class="line">                                v.getId(),</span><br><span class="line">                                v.getZxid(),</span><br><span class="line">                                logicalclock.get(),</span><br><span class="line">                                self.getPeerState(),</span><br><span class="line">                                response.sid,</span><br><span class="line">                                v.getPeerEpoch(),</span><br><span class="line">                                qv.toString().getBytes());</span><br><span class="line">                        //发送本机的选票</span><br><span class="line">                        sendqueue.offer(notmsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //本机非选举状态直接发送当前选举结果</span><br><span class="line">                    Vote current = self.getCurrentVote();</span><br><span class="line">                    if(ackstate == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                        if(LOG.isDebugEnabled())&#123;</span><br><span class="line">                            LOG.debug(&quot;Sending new notification. My id =&#123;&#125; recipient=&#123;&#125; zxid=0x&#123;&#125; leader=&#123;&#125; config version = &#123;&#125;&quot;,</span><br><span class="line">                                    self.getId(),</span><br><span class="line">                                    response.sid,</span><br><span class="line">                                    Long.toHexString(current.getZxid()),</span><br><span class="line">                                    current.getId(),</span><br><span class="line">                                    Long.toHexString(self.getQuorumVerifier().getVersion()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                        ToSend notmsg = new ToSend(</span><br><span class="line">                                ToSend.mType.notification,</span><br><span class="line">                                current.getId(),</span><br><span class="line">                                current.getZxid(),</span><br><span class="line">                                current.getElectionEpoch(),</span><br><span class="line">                                self.getPeerState(),</span><br><span class="line">                                response.sid,</span><br><span class="line">                                current.getPeerEpoch(),</span><br><span class="line">                                qv.toString().getBytes());</span><br><span class="line">                        sendqueue.offer(notmsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20、接（一、2）QuorumPeer的run方法"><a href="#20、接（一、2）QuorumPeer的run方法" class="headerlink" title="20、接（一、2）QuorumPeer的run方法"></a>20、接（一、2）QuorumPeer的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    updateThreadName();</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Main loop</span><br><span class="line">         */</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            //本机状态</span><br><span class="line">            switch (getPeerState()) &#123;</span><br><span class="line">            case LOOKING:</span><br><span class="line">                //本机为只读服务器</span><br><span class="line">                if (Boolean.getBoolean(&quot;readonlymode.enabled&quot;)) &#123;</span><br><span class="line">                    LOG.info(&quot;Attempting to start ReadOnlyZooKeeperServer&quot;);</span><br><span class="line"></span><br><span class="line">                    // Create read-only server but don&apos;t start it immediately</span><br><span class="line">                    final ReadOnlyZooKeeperServer roZk =</span><br><span class="line">                        new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);</span><br><span class="line"></span><br><span class="line">                    //等待两秒钟启动服务器</span><br><span class="line">                    Thread roZkMgr = new Thread() &#123;</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                // lower-bound grace period to 2 secs</span><br><span class="line">                                sleep(Math.max(2000, tickTime));</span><br><span class="line">                                if (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;);</span><br><span class="line">                            &#125; catch (Exception e) &#123;</span><br><span class="line">                                LOG.error(&quot;FAILED to start ReadOnlyZooKeeperServer&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        if (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = false;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        //选举并设置当前投票</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        if (shuttingDownLE) &#123;</span><br><span class="line">                           shuttingDownLE = false;</span><br><span class="line">                           startLeaderElection();</span><br><span class="line">                           &#125;</span><br><span class="line">                        //选举并设置当前选举结果</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;                        </span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case OBSERVING:</span><br><span class="line">                try &#123;</span><br><span class="line">                    LOG.info(&quot;OBSERVING&quot;);</span><br><span class="line">                    setObserver(makeObserver(logFactory));</span><br><span class="line">                    //只读服务器初始化</span><br><span class="line">                    observer.observeLeader();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    LOG.warn(&quot;Unexpected exception&quot;,e );</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    observer.shutdown();</span><br><span class="line">                    setObserver(null);  </span><br><span class="line">                   updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case FOLLOWING:</span><br><span class="line">                try &#123;</span><br><span class="line">                   LOG.info(&quot;FOLLOWING&quot;);</span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    //初始化</span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                   LOG.warn(&quot;Unexpected exception&quot;,e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                   follower.shutdown();</span><br><span class="line">                   setFollower(null);</span><br><span class="line">                   updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case LEADING:</span><br><span class="line">                LOG.info(&quot;LEADING&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    setLeader(makeLeader(logFactory));</span><br><span class="line">                    //初始化</span><br><span class="line">                    leader.lead();</span><br><span class="line">                    setLeader(null);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    LOG.warn(&quot;Unexpected exception&quot;,e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (leader != null) &#123;</span><br><span class="line">                        leader.shutdown(&quot;Forcing shutdown&quot;);</span><br><span class="line">                        setLeader(null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            start_fle = Time.currentElapsedTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21、FastLeaderElection的lookForLeader方法选举LEADER"><a href="#21、FastLeaderElection的lookForLeader方法选举LEADER" class="headerlink" title="21、FastLeaderElection的lookForLeader方法选举LEADER"></a>21、FastLeaderElection的lookForLeader方法选举LEADER</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">public Vote lookForLeader() throws InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    //选举开始时间</span><br><span class="line">    if (self.start_fle == 0) &#123;</span><br><span class="line">       self.start_fle = Time.currentElapsedTime();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //收到的投票</span><br><span class="line">        Map&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line">        Map&lt;Long, Vote&gt; outofelection = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        int notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            //选举轮次加一</span><br><span class="line">            logicalclock.incrementAndGet();</span><br><span class="line">            //更新投票提议，默认投自己</span><br><span class="line">            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //广播本机选票</span><br><span class="line">        sendNotifications();</span><br><span class="line">        //本机处于选举状态且为停止</span><br><span class="line">        while ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop))&#123;</span><br><span class="line">            //取出接收到的消息</span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                    TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            //未收到投票</span><br><span class="line">            if(n == null)&#123;</span><br><span class="line">                //投票已发送</span><br><span class="line">                if(manager.haveDelivered())&#123;</span><br><span class="line">                    //重新发送</span><br><span class="line">                    sendNotifications();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //投票未发送，重新连接</span><br><span class="line">                    manager.connectAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * Exponential backoff</span><br><span class="line">                 */</span><br><span class="line">                int tmpTimeOut = notTimeout*2;</span><br><span class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</span><br><span class="line">                        tmpTimeOut : maxNotificationInterval);</span><br><span class="line">                LOG.info(&quot;Notification time out: &quot; + notTimeout);</span><br><span class="line">            &#125; </span><br><span class="line">            else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) &#123;</span><br><span class="line">                switch (n.state) &#123;</span><br><span class="line">                //投票的服务器处于选举状态</span><br><span class="line">                case LOOKING:</span><br><span class="line">                    //-1说明加载数据出错，不处理</span><br><span class="line">                    if (getInitLastLoggedZxid() == -1) &#123;</span><br><span class="line">                        LOG.debug(&quot;Ignoring notification as our zxid is -1&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (n.zxid == -1) &#123;</span><br><span class="line">                        LOG.debug(&quot;Ignoring notification from member with -1 zxid&quot; + n.sid);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //发消息的服务器选举轮次大于本机轮次</span><br><span class="line">                    if (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                        //更新轮次</span><br><span class="line">                        logicalclock.set(n.electionEpoch);</span><br><span class="line">                        //废弃所有收到的选票</span><br><span class="line">                        recvset.clear();</span><br><span class="line">                        //选举PK，更新当前的提议为胜出者</span><br><span class="line">                        if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            updateProposal(getInitId(),</span><br><span class="line">                                    getInitLastLoggedZxid(),</span><br><span class="line">                                    getPeerEpoch());</span><br><span class="line">                        &#125;</span><br><span class="line">                        //发送选票</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; else if (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                        //发消息的服务器选举轮次小于本机轮次，不处理，跳出switch</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                            proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                        //同一轮次，选票PK，更新胜出者为当前提议</span><br><span class="line">                        updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        //发送消息</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //当前选票信息，添加到map中</span><br><span class="line">                    recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                    //若当前提议超过半数</span><br><span class="line">                    if (termPredicate(recvset,</span><br><span class="line">                            new Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                    logicalclock.get(), proposedEpoch))) &#123;</span><br><span class="line"></span><br><span class="line">                        //检查投票中，是否有PK胜出当前提议的投票</span><br><span class="line">                        while((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                TimeUnit.MILLISECONDS)) != null)&#123;</span><br><span class="line">                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                    proposedLeader, proposedZxid, proposedEpoch))&#123;</span><br><span class="line">                                recvqueue.put(n);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (n == null) &#123;</span><br><span class="line">                            //当前提议为最终结果，若提以为自己，则本机当选LEADER</span><br><span class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                            //设置最终选票</span><br><span class="line">                            Vote endVote = new Vote(proposedLeader,</span><br><span class="line">                                    proposedZxid, proposedEpoch);</span><br><span class="line">                            //清除选票容器</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            //返回最终选票</span><br><span class="line">                            return endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case OBSERVING:</span><br><span class="line">                    //当前状态为观察者，不参与处理</span><br><span class="line">                    break;</span><br><span class="line">                case FOLLOWING:</span><br><span class="line">                case LEADING:</span><br><span class="line">                    //发出消息的服务器，与本机轮次相同</span><br><span class="line">                    if(n.electionEpoch == logicalclock.get())&#123;</span><br><span class="line">                        //保存收到的选票</span><br><span class="line">                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                        //若n的选票超过半数，并且n的状态为Leader，并且n不为本机，则更新本机状态、选举结果</span><br><span class="line">                        if(termPredicate(recvset, new Vote(n.leader,</span><br><span class="line">                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                                        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line"></span><br><span class="line">                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            return endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    outofelection.put(n.sid, new Vote(n.leader, </span><br><span class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</span><br><span class="line">                    if (termPredicate(outofelection, new Vote(n.leader,</span><br><span class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</span><br><span class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</span><br><span class="line">                        synchronized(this)&#123;</span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        leaveInstance(endVote);</span><br><span class="line">                        return endVote;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    LOG.warn(&quot;Notification state unrecoginized: &quot; + n.state</span><br><span class="line">                          + &quot; (n.state), &quot; + n.sid + &quot; (n.sid)&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring notification from non-cluster member &quot; + n.sid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此leader选举就完成了;</p>
<h3 id="二、LEADER初始化过程"><a href="#二、LEADER初始化过程" class="headerlink" title="二、LEADER初始化过程"></a>二、LEADER初始化过程</h3><h4 id="1、实例化Leader"><a href="#1、实例化Leader" class="headerlink" title="1、实例化Leader"></a>1、实例化Leader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Leader(QuorumPeer self,LeaderZooKeeperServer zk) throws IOException &#123;</span><br><span class="line">    this.self = self;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">            ss = new ServerSocket(self.getQuorumAddress().getPort());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //socket服务器等待follower连接</span><br><span class="line">            ss = new ServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">        ss.setReuseAddress(true);</span><br><span class="line">        if (!self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">            //监听地址</span><br><span class="line">            ss.bind(self.getQuorumAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (BindException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    //leader服务器</span><br><span class="line">    this.zk = zk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、LEADER的lead方法"><a href="#2、LEADER的lead方法" class="headerlink" title="2、LEADER的lead方法"></a>2、LEADER的lead方法</h4><p>lead方法实现初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">void lead() throws IOException, InterruptedException &#123;</span><br><span class="line">    self.end_fle = Time.currentElapsedTime();</span><br><span class="line">    //leader选举所花的时间</span><br><span class="line">    long electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">    self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">    self.start_fle = 0;</span><br><span class="line">    self.end_fle = 0;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //leader计时器</span><br><span class="line">        self.tick.set(0);</span><br><span class="line">        //恢复数据</span><br><span class="line">        zk.loadData();</span><br><span class="line">        //leader服务器最新的事务状态</span><br><span class="line">        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());</span><br><span class="line"></span><br><span class="line">        // 等待follower接入的线程</span><br><span class="line">        cnxAcceptor = new LearnerCnxAcceptor();</span><br><span class="line">        cnxAcceptor.start();</span><br><span class="line">        //等待足够多的follower进来，代表自己确实是leader，此处lead线程可能会等待 </span><br><span class="line">        //返回最新的批次加一</span><br><span class="line">        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());</span><br><span class="line">        //用最新的批次创建事务序号</span><br><span class="line">        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));</span><br><span class="line"></span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            //最新提交的事务序号</span><br><span class="line">            lastProposed = zk.getZxid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),</span><br><span class="line">               null, null);</span><br><span class="line"></span><br><span class="line">        //新批次的事务序号不是从零开始</span><br><span class="line">        if ((newLeaderProposal.packet.getZxid() &amp; 0xffffffffL) != 0) &#123;</span><br><span class="line">            LOG.info(&quot;NEWLEADER proposal has Zxid of &quot;</span><br><span class="line">                    + Long.toHexString(newLeaderProposal.packet.getZxid()));</span><br><span class="line">        &#125;</span><br><span class="line">        //校验器</span><br><span class="line">        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">        QuorumVerifier curQV = self.getQuorumVerifier();</span><br><span class="line">        if (curQV.getVersion() == 0 &amp;&amp; curQV.getVersion() == lastSeenQV.getVersion()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               QuorumVerifier newQV = self.configFromString(curQV.toString());</span><br><span class="line">               newQV.setVersion(zk.getZxid());</span><br><span class="line">               self.setLastSeenQuorumVerifier(newQV, true);    </span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               throw new IOException(e);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">        if (self.getLastSeenQuorumVerifier().getVersion() &gt; self.getQuorumVerifier().getVersion())&#123;</span><br><span class="line">           newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         //等待足够多的follower确认，leader的事务为最新的事务</span><br><span class="line">         waitForEpochAck(self.getId(), leaderStateSummary);</span><br><span class="line">         //设置当前批次</span><br><span class="line">         self.setCurrentEpoch(epoch);    </span><br><span class="line">        </span><br><span class="line">         try &#123;</span><br><span class="line">             //等待最少半数follower同步数据完成</span><br><span class="line">             waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //启动LeaderZooKeeperServer</span><br><span class="line">         startZkServer();</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">        // We ping twice a tick, so we only update the tick every other</span><br><span class="line">        // iteration</span><br><span class="line">        boolean tickSkip = true;</span><br><span class="line">        // If not null then shutdown this leader</span><br><span class="line">        String shutdownMessage = null;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                long start = Time.currentElapsedTime();</span><br><span class="line">                long cur = start;</span><br><span class="line">                long end = start + self.tickTime / 2;</span><br><span class="line">                while (cur &lt; end) &#123;</span><br><span class="line">                    //等待</span><br><span class="line">                    wait(end - cur);</span><br><span class="line">                    cur = Time.currentElapsedTime();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!tickSkip) &#123;</span><br><span class="line">                    计时器加一</span><br><span class="line">                    self.tick.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //未超时的服务器的id集合</span><br><span class="line">                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();</span><br><span class="line">                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">                if (self.getLastSeenQuorumVerifier() != null</span><br><span class="line">                        &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self</span><br><span class="line">                                .getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">                    syncedAckSet.addQuorumVerifier(self</span><br><span class="line">                            .getLastSeenQuorumVerifier());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                syncedAckSet.addAck(self.getId());</span><br><span class="line"></span><br><span class="line">                for (LearnerHandler f : getLearners()) &#123;</span><br><span class="line">                    //连接未超时</span><br><span class="line">                    if (f.synced()) &#123;</span><br><span class="line">                        syncedAckSet.addAck(f.getSid());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // check leader running status</span><br><span class="line">                if (!this.isRunning()) &#123;</span><br><span class="line">                    // set shutdown flag</span><br><span class="line">                    shutdownMessage = &quot;Unexpected internal error&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //未超时的连接小于半数，则退出主循环</span><br><span class="line">                if (!tickSkip &amp;&amp; !syncedAckSet.hasAllQuorums()) &#123;</span><br><span class="line">                    shutdownMessage = &quot;Not sufficient followers synced, only synced with sids: [ &quot;</span><br><span class="line">                            + syncedAckSet.ackSetsToString() + &quot; ]&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                tickSkip = !tickSkip;</span><br><span class="line">            &#125;</span><br><span class="line">            for (LearnerHandler f : getLearners()) &#123;</span><br><span class="line">                //心跳检测</span><br><span class="line">                f.ping();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shutdownMessage != null) &#123;</span><br><span class="line">            shutdown(shutdownMessage);</span><br><span class="line">            // leader goes in looking state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        zk.unregisterJMX(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、LearnerCnxAcceptor线程的run方法"><a href="#3、LearnerCnxAcceptor线程的run方法" class="headerlink" title="3、LearnerCnxAcceptor线程的run方法"></a>3、LearnerCnxAcceptor线程的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stop) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                //接受follower连接</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                // start with the initLimit, once the ack is processed</span><br><span class="line">                // in LearnerHandler switch to the syncLimit</span><br><span class="line">                s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">                s.setTcpNoDelay(nodelay);</span><br><span class="line"></span><br><span class="line">                BufferedInputStream is = new BufferedInputStream(</span><br><span class="line">                        s.getInputStream());</span><br><span class="line">                //处理follower数据的线程</span><br><span class="line">                LearnerHandler fh = new LearnerHandler(s, is, Leader.this);</span><br><span class="line">                fh.start();</span><br><span class="line">            &#125; catch</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Exception while accepting follower&quot;, e.getMessage());</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、LearnerHandler线程的run方法"><a href="#4、LearnerHandler线程的run方法" class="headerlink" title="4、LearnerHandler线程的run方法"></a>4、LearnerHandler线程的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        leader.addLearnerHandler(this);</span><br><span class="line">        //超时时间</span><br><span class="line">        tickOfNextAckDeadline = leader.self.tick.get()</span><br><span class="line">                + leader.self.initLimit + leader.self.syncLimit;</span><br><span class="line"></span><br><span class="line">        ia = BinaryInputArchive.getArchive(bufferedInput);</span><br><span class="line">        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        oa = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line"></span><br><span class="line">        QuorumPacket qp = new QuorumPacket();</span><br><span class="line">        ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line">        //检查数据类型</span><br><span class="line">        if(qp.getType() != Leader.FOLLOWERINFO &amp;&amp; qp.getType() != Leader.OBSERVERINFO)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte learnerInfoData[] = qp.getData();</span><br><span class="line">        if (learnerInfoData != null) &#123;</span><br><span class="line">            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);</span><br><span class="line">            if (learnerInfoData.length &gt;= 8) &#123;</span><br><span class="line">                this.sid = bbsid.getLong();</span><br><span class="line">            &#125;</span><br><span class="line">            if (learnerInfoData.length &gt;= 12) &#123;</span><br><span class="line">                this.version = bbsid.getInt(); // protocolVersion</span><br><span class="line">            &#125;</span><br><span class="line">            if (learnerInfoData.length &gt;= 20) &#123;</span><br><span class="line">                long configVersion = bbsid.getLong();</span><br><span class="line">                if (configVersion &gt; leader.self.getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">                    throw new IOException(&quot;Follower is ahead of the leader (has a later activated configuration)&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.sid = leader.followerCounter.getAndDecrement();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (qp.getType() == Leader.OBSERVERINFO) &#123;</span><br><span class="line">              learnerType = LearnerType.OBSERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //follwer的最新批次</span><br><span class="line">        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">        long peerLastZxid;</span><br><span class="line">        StateSummary ss = null;</span><br><span class="line">        long zxid = qp.getZxid();</span><br><span class="line">        //等待足够多的follower进来，代表自己确实是leader，此处lead线程可能会等待 </span><br><span class="line">        //返回最新的批次加一</span><br><span class="line">        long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);</span><br><span class="line">        //最新批次事务序号</span><br><span class="line">        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);</span><br><span class="line"></span><br><span class="line">        if (this.getVersion() &lt; 0x10000) &#123;</span><br><span class="line">            // we are going to have to extrapolate the epoch information</span><br><span class="line">            long epoch = ZxidUtils.getEpochFromZxid(zxid);</span><br><span class="line">            //该follower的最新事务批次、最大事务序号</span><br><span class="line">            ss = new StateSummary(epoch, zxid);</span><br><span class="line">            //确认follower的事务序号小于leader，需等待半数follower完成</span><br><span class="line">            leader.waitForEpochAck(this.getSid(), ss);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte ver[] = new byte[4];</span><br><span class="line">            ByteBuffer.wrap(ver).putInt(0x10000);</span><br><span class="line">            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);</span><br><span class="line">            oa.writeRecord(newEpochPacket, &quot;packet&quot;);</span><br><span class="line">            bufferedOutput.flush();</span><br><span class="line">            QuorumPacket ackEpochPacket = new QuorumPacket();</span><br><span class="line">            ia.readRecord(ackEpochPacket, &quot;packet&quot;);</span><br><span class="line">            if (ackEpochPacket.getType() != Leader.ACKEPOCH) &#123;</span><br><span class="line">                LOG.error(ackEpochPacket.toString()</span><br><span class="line">                        + &quot; is not ACKEPOCH&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());</span><br><span class="line">            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());</span><br><span class="line">            leader.waitForEpochAck(this.getSid(), ss);</span><br><span class="line">        &#125;</span><br><span class="line">        //该follwer最新的事务序号</span><br><span class="line">        peerLastZxid = ss.getLastZxid();</span><br><span class="line">       </span><br><span class="line">        //向该follower同步数据</span><br><span class="line">        boolean needSnap = syncFollower(peerLastZxid, leader.zk.getZKDatabase(), leader);</span><br><span class="line">    </span><br><span class="line">        // 发送newleader给follower</span><br><span class="line">        if (getVersion() &lt; 0x10000) &#123;</span><br><span class="line">            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,</span><br><span class="line">                    newLeaderZxid, null, null);</span><br><span class="line">            oa.writeRecord(newLeaderQP, &quot;packet&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,</span><br><span class="line">                    newLeaderZxid, leader.self.getLastSeenQuorumVerifier()</span><br><span class="line">                            .toString().getBytes(), null);</span><br><span class="line">            queuedPackets.add(newLeaderQP);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">        /* if we are not truncating or sending a diff just send a snapshot */</span><br><span class="line">        if (needSnap) &#123;</span><br><span class="line">            boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;</span><br><span class="line">            LearnerSnapshot snapshot = </span><br><span class="line">                    leader.getLearnerSnapshotThrottler().beginSnapshot(exemptFromThrottle);</span><br><span class="line">            try &#123;</span><br><span class="line">                long zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), &quot;packet&quot;);</span><br><span class="line">                bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">                // 向follower发送快照</span><br><span class="line">                leader.zk.getZKDatabase().serializeSnapshot(oa);</span><br><span class="line">                oa.writeString(&quot;BenWasHere&quot;, &quot;signature&quot;);</span><br><span class="line">                bufferedOutput.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                snapshot.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动发送数据包的线程,发送queuedPackets中数据</span><br><span class="line">        startSendingPackets();</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * Have to wait for the first ACK, wait until</span><br><span class="line">         * the leader is ready, and only then we can</span><br><span class="line">         * start processing messages.</span><br><span class="line">         */</span><br><span class="line">        qp = new QuorumPacket();</span><br><span class="line">        ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line">        if(qp.getType() != Leader.ACK)&#123;</span><br><span class="line">            ...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //follower同步数据完成，检查follower最新事务序号是否与leader相同，等待半数follower完成</span><br><span class="line">        leader.waitForNewLeaderAck(getSid(), qp.getZxid(), getLearnerType());</span><br><span class="line"></span><br><span class="line">        //等待时间限制</span><br><span class="line">        syncLimitCheck.start();</span><br><span class="line">        </span><br><span class="line">        // now that the ack has been processed expect the syncLimit</span><br><span class="line">        sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);</span><br><span class="line"></span><br><span class="line">        //等待LeaderZooKeeperServer启动</span><br><span class="line">        synchronized(leader.zk)&#123;</span><br><span class="line">            while(!leader.zk.isRunning() &amp;&amp; !this.isInterrupted())&#123;</span><br><span class="line">                leader.zk.wait(20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //通知follower退出同步数据循环     </span><br><span class="line">        queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));</span><br><span class="line">        //主循环</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            qp = new QuorumPacket();</span><br><span class="line">            //读取follower发来的数据</span><br><span class="line">            ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line"></span><br><span class="line">            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;</span><br><span class="line">            if (qp.getType() == Leader.PING) &#123;</span><br><span class="line">                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            tickOfNextAckDeadline = leader.self.tick.get() + leader.self.syncLimit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ByteBuffer bb;</span><br><span class="line">            long sessionId;</span><br><span class="line">            int cxid;</span><br><span class="line">            int type;</span><br><span class="line"></span><br><span class="line">            switch (qp.getType()) &#123;</span><br><span class="line">            case Leader.ACK:</span><br><span class="line">                //刷新时间</span><br><span class="line">                syncLimitCheck.updateAck(qp.getZxid());</span><br><span class="line">                //处理follower对提议返回的投票</span><br><span class="line">                leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());</span><br><span class="line">                break;</span><br><span class="line">            case Leader.PING:</span><br><span class="line">                // 心跳信息</span><br><span class="line">                ByteArrayInputStream bis = new ByteArrayInputStream(qp</span><br><span class="line">                        .getData());</span><br><span class="line">                DataInputStream dis = new DataInputStream(bis);</span><br><span class="line">                while (dis.available() &gt; 0) &#123;</span><br><span class="line">                    long sess = dis.readLong();</span><br><span class="line">                    int to = dis.readInt();</span><br><span class="line">                    //更新session的有效时间</span><br><span class="line">                    leader.zk.touch(sess, to);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case Leader.REVALIDATE:</span><br><span class="line">                bis = new ByteArrayInputStream(qp.getData());</span><br><span class="line">                dis = new DataInputStream(bis);</span><br><span class="line">                long id = dis.readLong();</span><br><span class="line">                int to = dis.readInt();</span><br><span class="line">                ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">                DataOutputStream dos = new DataOutputStream(bos);</span><br><span class="line">                dos.writeLong(id);</span><br><span class="line">                boolean valid = leader.zk.checkIfValidGlobalSession(id, to);</span><br><span class="line">                if (valid) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //set the session owner</span><br><span class="line">                        // as the follower that</span><br><span class="line">                        // owns the session</span><br><span class="line">                        leader.zk.setOwner(id, this);</span><br><span class="line">                    &#125; catch (SessionExpiredException e) &#123;</span><br><span class="line">                        LOG.error(&quot;Somehow session &quot; + Long.toHexString(id) +</span><br><span class="line">                                &quot; expired right after being renewed! (impossible)&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dos.writeBoolean(valid);</span><br><span class="line">                qp.setData(bos.toByteArray());</span><br><span class="line">                queuedPackets.add(qp);</span><br><span class="line">                break;</span><br><span class="line">            case Leader.REQUEST:</span><br><span class="line">	      //Follower转发过来的请求</span><br><span class="line">                bb = ByteBuffer.wrap(qp.getData());</span><br><span class="line">                sessionId = bb.getLong();</span><br><span class="line">                cxid = bb.getInt();</span><br><span class="line">                type = bb.getInt();</span><br><span class="line">                bb = bb.slice();</span><br><span class="line">                Request si;</span><br><span class="line">                if(type == OpCode.sync)&#123;</span><br><span class="line">                    si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());</span><br><span class="line">                &#125;</span><br><span class="line">                si.setOwner(this);</span><br><span class="line">                //调用prepRequestProcessor处理request</span><br><span class="line">                leader.zk.submitLearnerRequest(si);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                LOG.warn(&quot;unexpected quorum packet, type: &#123;&#125;&quot;, packetToString(qp));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、Leader的getEpochToPropose方法"><a href="#5、Leader的getEpochToPropose方法" class="headerlink" title="5、Leader的getEpochToPropose方法"></a>5、Leader的getEpochToPropose方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException &#123;</span><br><span class="line">        synchronized(connectingFollowers) &#123;</span><br><span class="line">            if (!waitingForNewEpoch) &#123;</span><br><span class="line">                return epoch;</span><br><span class="line">            &#125;</span><br><span class="line">            //follower最新批次大于等于当前批次</span><br><span class="line">            if (lastAcceptedEpoch &gt;= epoch) &#123;</span><br><span class="line">                epoch = lastAcceptedEpoch+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //已连接的follower集合</span><br><span class="line">            connectingFollowers.add(sid);</span><br><span class="line">            QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">            //已连接的follower是否超过半数</span><br><span class="line">            if (connectingFollowers.contains(self.getId()) &amp;&amp;</span><br><span class="line">                                            verifier.containsQuorum(connectingFollowers)) &#123;</span><br><span class="line">                waitingForNewEpoch = false;</span><br><span class="line">                self.setAcceptedEpoch(epoch);</span><br><span class="line">                connectingFollowers.notifyAll();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //不超过半数，则等待其他follower接入</span><br><span class="line">                long start = Time.currentElapsedTime();</span><br><span class="line">                long cur = start;</span><br><span class="line">                long end = start + self.getInitLimit()*self.getTickTime();</span><br><span class="line">                while(waitingForNewEpoch &amp;&amp; cur &lt; end) &#123;</span><br><span class="line">                    connectingFollowers.wait(end - cur);</span><br><span class="line">                    cur = Time.currentElapsedTime();</span><br><span class="line">                &#125;</span><br><span class="line">                if (waitingForNewEpoch) &#123;</span><br><span class="line">                    throw new InterruptedException(&quot;Timeout while waiting for epoch from quorum&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return epoch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（二、4）Leader的waitForEpochAck方法"><a href="#6、接（二、4）Leader的waitForEpochAck方法" class="headerlink" title="6、接（二、4）Leader的waitForEpochAck方法"></a>6、接（二、4）Leader的waitForEpochAck方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException &#123;</span><br><span class="line">    synchronized(electingFollowers) &#123;</span><br><span class="line">        if (electionFinished) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ss.getCurrentEpoch() != -1) &#123;</span><br><span class="line">            //follower的事务大于leader</span><br><span class="line">            if (ss.isMoreRecentThan(leaderStateSummary)) &#123;</span><br><span class="line">                throw new IOException(&quot;Follower is ahead of the leader, leader summary: &quot; </span><br><span class="line">                                                + leaderStateSummary.getCurrentEpoch()</span><br><span class="line">                                                + &quot; (current epoch), &quot;</span><br><span class="line">                                                + leaderStateSummary.getLastZxid()</span><br><span class="line">                                                + &quot; (last zxid)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ss.getLastZxid() != -1) &#123;</span><br><span class="line">                //已完成确认的follower的集合</span><br><span class="line">                electingFollowers.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">        //是否有半数的follower完成确认</span><br><span class="line">        if (electingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(electingFollowers)) &#123;</span><br><span class="line">            electionFinished = true;</span><br><span class="line">            electingFollowers.notifyAll();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long start = Time.currentElapsedTime();</span><br><span class="line">            long cur = start;</span><br><span class="line">            long end = start + self.getInitLimit()*self.getTickTime();</span><br><span class="line">            while(!electionFinished &amp;&amp; cur &lt; end) &#123;</span><br><span class="line">                electingFollowers.wait(end - cur);</span><br><span class="line">                cur = Time.currentElapsedTime();</span><br><span class="line">            &#125;</span><br><span class="line">            if (!electionFinished) &#123;</span><br><span class="line">                throw new InterruptedException(&quot;Timeout while waiting for epoch to be acked by quorum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、接（二、4）LearnerHandler的syncFollower方法"><a href="#7、接（二、4）LearnerHandler的syncFollower方法" class="headerlink" title="7、接（二、4）LearnerHandler的syncFollower方法"></a>7、接（二、4）LearnerHandler的syncFollower方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) &#123;</span><br><span class="line">    //follower的事务于leader一致</span><br><span class="line">    boolean isPeerNewEpochZxid = (peerLastZxid &amp; 0xffffffffL) == 0;</span><br><span class="line">    //follower的当前事务序号</span><br><span class="line">    long currentZxid = peerLastZxid;</span><br><span class="line">    boolean needSnap = true;</span><br><span class="line">    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();</span><br><span class="line">    ReentrantReadWriteLock lock = db.getLogLock();</span><br><span class="line">    ReadLock rl = lock.readLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        rl.lock();</span><br><span class="line">        long maxCommittedLog = db.getmaxCommittedLog();</span><br><span class="line">        long minCommittedLog = db.getminCommittedLog();</span><br><span class="line">        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();</span><br><span class="line"></span><br><span class="line">        //最近一段时间内执行的事务</span><br><span class="line">        if (db.getCommittedLog().isEmpty()) &#123;</span><br><span class="line">            minCommittedLog = lastProcessedZxid;</span><br><span class="line">            maxCommittedLog = lastProcessedZxid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (forceSnapSync) &#123;</span><br><span class="line">            // Force leader to use snapshot to sync with follower</span><br><span class="line">            LOG.warn(&quot;Forcing snapshot sync - should not see this in production&quot;);</span><br><span class="line">        &#125; else if (lastProcessedZxid == peerLastZxid) &#123;</span><br><span class="line">            //follower的事务与leader相等，无需同步，将Leader.DIFF类型的数据包，加入待发送队列</span><br><span class="line">            queueOpPacket(Leader.DIFF, peerLastZxid);</span><br><span class="line">            needOpPacket = false;</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if (peerLastZxid &gt; maxCommittedLog &amp;&amp; !isPeerNewEpochZxid) &#123;</span><br><span class="line">            // follower事务序号超出了leader，废弃掉超出的部分</span><br><span class="line">            queueOpPacket(Leader.TRUNC, maxCommittedLog);</span><br><span class="line">            currentZxid = maxCommittedLog;</span><br><span class="line">            needOpPacket = false;</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if ((maxCommittedLog &gt;= peerLastZxid)</span><br><span class="line">                &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</span><br><span class="line">            //Follower的事务序号在CommittedLog之间</span><br><span class="line">            Iterator&lt;Proposal&gt; itr = db.getCommittedLog().iterator();</span><br><span class="line">            //向follower同步事务</span><br><span class="line">            currentZxid = queueCommittedProposals(itr, peerLastZxid,</span><br><span class="line">                                                 null, maxCommittedLog);</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if (peerLastZxid &lt; minCommittedLog &amp;&amp; txnLogSyncEnabled) &#123;</span><br><span class="line">            //从事务日志中可取回的事务的数量限制</span><br><span class="line">            long sizeLimit = db.calculateTxnLogSizeLimit();</span><br><span class="line">            //若peerLastZxid超出当前限制，则返回null</span><br><span class="line">            Iterator&lt;Proposal&gt; txnLogItr = db.getProposalsFromTxnLog(</span><br><span class="line">                    peerLastZxid, sizeLimit);</span><br><span class="line">            if (txnLogItr.hasNext()) &#123;</span><br><span class="line">                //同步事务</span><br><span class="line">                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid,</span><br><span class="line">                                                     minCommittedLog, maxCommittedLog);</span><br><span class="line"></span><br><span class="line">                //同步事务</span><br><span class="line">                Iterator&lt;Proposal&gt; committedLogItr = db.getCommittedLog().iterator();</span><br><span class="line">                currentZxid = queueCommittedProposals(committedLogItr, currentZxid,</span><br><span class="line">                                                     null, maxCommittedLog);</span><br><span class="line">                needSnap = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // closing the resources</span><br><span class="line">            if (txnLogItr instanceof TxnLogProposalIterator) &#123;</span><br><span class="line">                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;</span><br><span class="line">                txnProposalItr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG.warn(&quot;Unhandled scenario for peer sid: &quot; +  getSid());</span><br><span class="line">        &#125;</span><br><span class="line">        //处理leader中未完成的事务，将handler加入集合</span><br><span class="line">        leaderLastZxid = leader.startForwarding(this, currentZxid);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        rl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needOpPacket &amp;&amp; !needSnap) &#123;</span><br><span class="line">        // This should never happen, but we should fall back to sending</span><br><span class="line">        // snapshot just in case. 事务同步失败，直接同步快照</span><br><span class="line">        needSnap = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return needSnap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、LearnerHandler的queueCommittedProposals方法"><a href="#8、LearnerHandler的queueCommittedProposals方法" class="headerlink" title="8、LearnerHandler的queueCommittedProposals方法"></a>8、LearnerHandler的queueCommittedProposals方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">protected long queueCommittedProposals(Iterator&lt;Proposal&gt; itr,</span><br><span class="line">        long peerLastZxid, Long maxZxid, Long lastCommittedZxid) &#123;</span><br><span class="line">    //follower的事务序号，已更新为最新</span><br><span class="line">    boolean isPeerNewEpochZxid = (peerLastZxid &amp; 0xffffffffL) == 0;</span><br><span class="line">    long queuedZxid = peerLastZxid;</span><br><span class="line">    // as we look through proposals, this variable keeps track of previous</span><br><span class="line">    // proposal Id.</span><br><span class="line">    long prevProposalZxid = -1;</span><br><span class="line">    while (itr.hasNext()) &#123;</span><br><span class="line">        //取出下个事务</span><br><span class="line">        Proposal propose = itr.next();</span><br><span class="line"></span><br><span class="line">        long packetZxid = propose.packet.getZxid();</span><br><span class="line">        //同步事务序号的上限</span><br><span class="line">        if ((maxZxid != null) &amp;&amp; (packetZxid &gt; maxZxid)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 小于follower的事务无需同步</span><br><span class="line">        if (packetZxid &lt; peerLastZxid) &#123;</span><br><span class="line">            prevProposalZxid = packetZxid;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //默认true</span><br><span class="line">        if (needOpPacket) &#123;</span><br><span class="line"></span><br><span class="line">            // follower同步完成</span><br><span class="line">            if (packetZxid == peerLastZxid) &#123;</span><br><span class="line">                //通知follower，无需同步snaphot</span><br><span class="line">                queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">                needOpPacket = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //follower事务序号为最新批次序号，无需同步</span><br><span class="line">            if (isPeerNewEpochZxid) &#123;</span><br><span class="line">               queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">               needOpPacket = false;</span><br><span class="line">            &#125; else if (packetZxid &gt; peerLastZxid  ) &#123;</span><br><span class="line">                //不是同一批次，无法同步</span><br><span class="line">                if (ZxidUtils.getEpochFromZxid(packetZxid) !=</span><br><span class="line">                        ZxidUtils.getEpochFromZxid(peerLastZxid)) &#123;</span><br><span class="line">                    return queuedZxid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //废弃掉follower的peerLastZxid之后的事务</span><br><span class="line">                queueOpPacket(Leader.TRUNC, prevProposalZxid);</span><br><span class="line">                needOpPacket = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (packetZxid &lt;= queuedZxid) &#123;</span><br><span class="line">            // We can get here, if we don&apos;t have op packet to queue</span><br><span class="line">            // or there is a duplicate txn in a given iterator</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //向follower发出事务提议</span><br><span class="line">        queuePacket(propose.packet);</span><br><span class="line">        //向follower发出事务确认</span><br><span class="line">        queueOpPacket(Leader.COMMIT, packetZxid);</span><br><span class="line">        queuedZxid = packetZxid;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needOpPacket &amp;&amp; isPeerNewEpochZxid) &#123;</span><br><span class="line">        queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">        needOpPacket = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return queuedZxid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、接（二、7）Leader的startForwarding方法"><a href="#9、接（二、7）Leader的startForwarding方法" class="headerlink" title="9、接（二、7）Leader的startForwarding方法"></a>9、接（二、7）Leader的startForwarding方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">synchronized public long startForwarding(LearnerHandler handler,</span><br><span class="line">        long lastSeenZxid) &#123;</span><br><span class="line">    //leader有尚未</span><br><span class="line">    if (lastProposed &gt; lastSeenZxid) &#123;</span><br><span class="line">        //leader中完成投票，并未commit的事务</span><br><span class="line">        for (Proposal p : toBeApplied) &#123;</span><br><span class="line">            if (p.packet.getZxid() &lt;= lastSeenZxid) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            handler.queuePacket(p.packet);</span><br><span class="line">            QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet</span><br><span class="line">                    .getZxid(), null, null);</span><br><span class="line">            handler.queuePacket(qp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (handler.getLearnerType() == LearnerType.PARTICIPANT) &#123;</span><br><span class="line">            //尚未投票通过的提议</span><br><span class="line">            List&lt;Long&gt;zxids = new ArrayList&lt;Long&gt;(outstandingProposals.keySet());</span><br><span class="line">            Collections.sort(zxids);</span><br><span class="line">            for (Long zxid: zxids) &#123;</span><br><span class="line">                if (zxid &lt;= lastSeenZxid) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                handler.queuePacket(outstandingProposals.get(zxid).packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handler.getLearnerType() == LearnerType.PARTICIPANT) </span><br><span class="line">        addForwardingFollower(handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addObserverLearnerHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lastProposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、接（二、2）Leader的startZkServer方法"><a href="#10、接（二、2）Leader的startZkServer方法" class="headerlink" title="10、接（二、2）Leader的startZkServer方法"></a>10、接（二、2）Leader的startZkServer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void startZkServer() &#123;</span><br><span class="line">    // Update lastCommitted and Db&apos;s zxid to a value representing the new epoch</span><br><span class="line">    lastCommitted = zk.getZxid();</span><br><span class="line"></span><br><span class="line">    QuorumVerifier newQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">    </span><br><span class="line">    //获取最合适的备用Leader服务器的id</span><br><span class="line">    Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());                                         </span><br><span class="line"></span><br><span class="line">    self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);</span><br><span class="line">    if (designatedLeader != self.getId()) &#123;</span><br><span class="line">        allowedToCommit = false;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动leader服务器</span><br><span class="line">    zk.startup();</span><br><span class="line">    self.updateElectionVote(getEpoch());</span><br><span class="line"></span><br><span class="line">    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、ZooKeeperServer的startup方法"><a href="#11、ZooKeeperServer的startup方法" class="headerlink" title="11、ZooKeeperServer的startup方法"></a>11、ZooKeeperServer的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  public synchronized void startup() &#123;</span><br><span class="line">    if (sessionTracker == null) &#123;</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    &#125;</span><br><span class="line">    startSessionTracker();</span><br><span class="line">    //启动处理器</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    setState(State.RUNNING);</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、LeaderZooKeeperServer的setupRequestProcessors方法"><a href="#12、LeaderZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="12、LeaderZooKeeperServer的setupRequestProcessors方法"></a>12、LeaderZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">    RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());</span><br><span class="line">    commitProcessor = new CommitProcessor(toBeAppliedProcessor,</span><br><span class="line">            Long.toString(getServerId()), false,</span><br><span class="line">            getZooKeeperServerListener());</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this,</span><br><span class="line">            commitProcessor);</span><br><span class="line">    proposalProcessor.initialize();</span><br><span class="line">    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);</span><br><span class="line">    prepRequestProcessor.start();</span><br><span class="line">    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);</span><br><span class="line"></span><br><span class="line">    setupContainerManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leader初始化结束</p>
<p>###三、FOLLOWER初始化过程</p>
<h4 id="1、FOLLOWER的followLeader方法"><a href="#1、FOLLOWER的followLeader方法" class="headerlink" title="1、FOLLOWER的followLeader方法"></a>1、FOLLOWER的followLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void followLeader() throws InterruptedException &#123;</span><br><span class="line">        self.end_fle = Time.currentElapsedTime();</span><br><span class="line">        long electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">        self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">        self.start_fle = 0;</span><br><span class="line">        self.end_fle = 0;</span><br><span class="line">        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);</span><br><span class="line">        try &#123;</span><br><span class="line">            //找到leader服务器id</span><br><span class="line">            QuorumServer leaderServer = findLeader();</span><br><span class="line">            try &#123;</span><br><span class="line">                //连接leader服务器</span><br><span class="line">                connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">                //follower注册到leader服务器，返回leader最新的事务zxid</span><br><span class="line">                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line"></span><br><span class="line">                //check to see if the leader zxid is lower than ours</span><br><span class="line">                //this should never happen but is just a safety check</span><br><span class="line">                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);</span><br><span class="line">                if (newEpoch &lt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">                    LOG.error(&quot;Proposed leader epoch &quot; + ZxidUtils.zxidToString(newEpochZxid)</span><br><span class="line">                            + &quot; is less than our accepted epoch &quot; + ZxidUtils.zxidToString(self.getAcceptedEpoch()));</span><br><span class="line">                    throw new IOException(&quot;Error: Epoch of leader is lower&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                //和Leader同步数据</span><br><span class="line">                syncWithLeader(newEpochZxid);                </span><br><span class="line">                QuorumPacket qp = new QuorumPacket();</span><br><span class="line">                //主循环</span><br><span class="line">                while (this.isRunning()) &#123;</span><br><span class="line">                    readPacket(qp);</span><br><span class="line">                    processPacket(qp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                ...</span><br><span class="line">                // clear pending revalidations</span><br><span class="line">                pendingRevalidations.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            zk.unregisterJMX((Learner)this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、FOLLOWER的registerWithLeader方法"><a href="#2、FOLLOWER的registerWithLeader方法" class="headerlink" title="2、FOLLOWER的registerWithLeader方法"></a>2、FOLLOWER的registerWithLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">protected long registerWithLeader(int pktType) throws IOException&#123;</span><br><span class="line">    //将follower的事务序号及follower的id</span><br><span class="line">    long lastLoggedZxid = self.getLastLoggedZxid();</span><br><span class="line">    QuorumPacket qp = new QuorumPacket();                </span><br><span class="line">    qp.setType(pktType);</span><br><span class="line">    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));</span><br><span class="line"></span><br><span class="line">    //Add sid to payload</span><br><span class="line">    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());</span><br><span class="line">    ByteArrayOutputStream bsid = new ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);</span><br><span class="line">    boa.writeRecord(li, &quot;LearnerInfo&quot;);</span><br><span class="line">    qp.setData(bsid.toByteArray());</span><br><span class="line">    //发送数据包</span><br><span class="line">    writePacket(qp, true);</span><br><span class="line">    //读取返回信息</span><br><span class="line">    readPacket(qp);        </span><br><span class="line">    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line">    if (qp.getType() == Leader.LEADERINFO) &#123;</span><br><span class="line">        // we are connected to a 1.0 server so accept the new epoch and read the next packet</span><br><span class="line">        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();</span><br><span class="line">        byte epochBytes[] = new byte[4];</span><br><span class="line">        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);</span><br><span class="line">        if (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">            //更新事务批次</span><br><span class="line">            wrappedEpochBytes.putInt((int)self.getCurrentEpoch());</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        &#125; else if (newEpoch == self.getAcceptedEpoch()) &#123;</span><br><span class="line">            wrappedEpochBytes.putInt(-1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Leaders epoch, &quot; + newEpoch + &quot; is less than accepted epoch, &quot; + self.getAcceptedEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);</span><br><span class="line">        writePacket(ackNewEpoch, true);</span><br><span class="line">        //返回leader的最新事务zxid</span><br><span class="line">        return ZxidUtils.makeZxid(newEpoch, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">            //更新事务批次</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        if (qp.getType() != Leader.NEWLEADER) &#123;</span><br><span class="line">            LOG.error(&quot;First packet should have been NEWLEADER&quot;);</span><br><span class="line">            throw new IOException(&quot;First packet should have been NEWLEADER&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回leader的最新事务zxid</span><br><span class="line">        return qp.getZxid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、接（三、1）FOLLOWER的syncWithLeader方法"><a href="#3、接（三、1）FOLLOWER的syncWithLeader方法" class="headerlink" title="3、接（三、1）FOLLOWER的syncWithLeader方法"></a>3、接（三、1）FOLLOWER的syncWithLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">protected void syncWithLeader(long newLeaderZxid) throws Exception&#123;</span><br><span class="line">    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);</span><br><span class="line">    QuorumPacket qp = new QuorumPacket();</span><br><span class="line">    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);</span><br><span class="line">    </span><br><span class="line">    QuorumVerifier newLeaderQV = null;</span><br><span class="line">    </span><br><span class="line">    boolean snapshotNeeded = true;</span><br><span class="line">    boolean syncSnapshot = false;</span><br><span class="line">    readPacket(qp);</span><br><span class="line">    LinkedList&lt;Long&gt; packetsCommitted = new LinkedList&lt;Long&gt;();</span><br><span class="line">    LinkedList&lt;PacketInFlight&gt; packetsNotCommitted = new LinkedList&lt;PacketInFlight&gt;();</span><br><span class="line">    synchronized (zk) &#123;</span><br><span class="line">        if (qp.getType() == Leader.DIFF) &#123;</span><br><span class="line">            //无需同步snaphot</span><br><span class="line">            snapshotNeeded = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (qp.getType() == Leader.SNAP) &#123;</span><br><span class="line">            //Leader给follower发送的是SNAP文件</span><br><span class="line">            //follower将SNAP文件替换到内存</span><br><span class="line">            zk.getZKDatabase().deserializeSnapshot(leaderIs);</span><br><span class="line">            ...</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">            syncSnapshot = true;</span><br><span class="line">        &#125; else if (qp.getType() == Leader.TRUNC) &#123;</span><br><span class="line">            //follower废弃大于Zxid的事务</span><br><span class="line">            boolean truncated=zk.getZKDatabase().truncateLog(qp.getZxid());</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());</span><br><span class="line">        //创建Session管理器</span><br><span class="line">        zk.createSessionTracker();            </span><br><span class="line">        long lastQueued = 0;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        boolean isPreZAB1_0 = true;</span><br><span class="line">        //同步SNAP则不需要同步事务</span><br><span class="line">        boolean writeToTxnLog = !snapshotNeeded;</span><br><span class="line">        //开始同步事务</span><br><span class="line">        outerLoop:</span><br><span class="line">        while (self.isRunning()) &#123;</span><br><span class="line">            readPacket(qp);</span><br><span class="line">            switch(qp.getType()) &#123;</span><br><span class="line">            case Leader.PROPOSAL:</span><br><span class="line">                //leader发来的提议</span><br><span class="line">                PacketInFlight pif = new PacketInFlight();</span><br><span class="line">                pif.hdr = new TxnHeader();</span><br><span class="line">                pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);</span><br><span class="line">                //加入到未commit队列</span><br><span class="line">                packetsNotCommitted.add(pif);</span><br><span class="line">                break;</span><br><span class="line">            case Leader.COMMIT:</span><br><span class="line">            case Leader.COMMITANDACTIVATE:</span><br><span class="line">                pif = packetsNotCommitted.peekFirst();</span><br><span class="line">                //已同步snaphot则不需同步事务</span><br><span class="line">                if (!writeToTxnLog) &#123;</span><br><span class="line">                    if (pif.hdr.getZxid() != qp.getZxid()) &#123;</span><br><span class="line">                        LOG.warn(&quot;Committing &quot; + qp.getZxid() + &quot;, but next proposal is &quot; + pif.hdr.getZxid());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //事务处理到内存db</span><br><span class="line">                        zk.processTxn(pif.hdr, pif.rec);</span><br><span class="line">                        packetsNotCommitted.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    packetsCommitted.add(qp.getZxid());</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case Leader.INFORM:</span><br><span class="line">            case Leader.INFORMANDACTIVATE:</span><br><span class="line">                ...                   </span><br><span class="line">                break;                </span><br><span class="line">            case Leader.UPTODATE:</span><br><span class="line">                ...</span><br><span class="line">                self.setZooKeeperServer(zk);</span><br><span class="line">                self.adminServer.setZooKeeperServer(zk);</span><br><span class="line">                //跳出同步数据循环</span><br><span class="line">                break outerLoop;</span><br><span class="line">            case Leader.NEWLEADER: // Getting NEWLEADER here instead of in discovery </span><br><span class="line">                // means this is Zab 1.0</span><br><span class="line">               if (qp.getData()!=null &amp;&amp; qp.getData().length &gt; 1) &#123;</span><br><span class="line">                   try &#123;                       </span><br><span class="line">                       QuorumVerifier qv = self.configFromString(new String(qp.getData()));</span><br><span class="line">                       self.setLastSeenQuorumVerifier(qv, true);</span><br><span class="line">                       newLeaderQV = qv;</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //将从leader获取到的内存文件保存到磁盘</span><br><span class="line">               if (snapshotNeeded) &#123;</span><br><span class="line">                   zk.takeSnapshot(syncSnapshot);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">                self.setCurrentEpoch(newEpoch);</span><br><span class="line">                writeToTxnLog = true; //Anything after this needs to go to the transaction log, not applied directly in memory</span><br><span class="line">                isPreZAB1_0 = false;</span><br><span class="line">                //同步数据完成给leader发送确认信息</span><br><span class="line">                writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));</span><br><span class="line">    //同步数据完成给leader发送确认信息</span><br><span class="line">    writePacket(ack, true);</span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.syncLimit);</span><br><span class="line">    //启动FollowerZooKeeperServer</span><br><span class="line">    zk.startup();</span><br><span class="line">    //更新选票事务批次</span><br><span class="line">    self.updateElectionVote(newEpoch);</span><br><span class="line"></span><br><span class="line">    // We need to log the stuff that came in between the snapshot and the uptodate</span><br><span class="line">    if (zk instanceof FollowerZooKeeperServer) &#123;</span><br><span class="line">        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer)zk;</span><br><span class="line">        //处理未投票事务</span><br><span class="line">        for(PacketInFlight p: packetsNotCommitted) &#123;</span><br><span class="line">            fzk.logRequest(p.hdr, p.rec);</span><br><span class="line">        &#125;</span><br><span class="line">        for(Long zxid: packetsCommitted) &#123;</span><br><span class="line">            //处理已投票事务</span><br><span class="line">            fzk.commit(zxid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (zk instanceof ObserverZooKeeperServer) &#123;</span><br><span class="line">        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;</span><br><span class="line">        for (PacketInFlight p : packetsNotCommitted) &#123;</span><br><span class="line">            Long zxid = packetsCommitted.peekFirst();</span><br><span class="line">            if (p.hdr.getZxid() != zxid) &#123;</span><br><span class="line">                // log warning message if there is no matching commit</span><br><span class="line">                // old leader send outstanding proposal to observer</span><br><span class="line">                LOG.warn(&quot;Committing &quot; + Long.toHexString(zxid)</span><br><span class="line">                        + &quot;, but next proposal is &quot;</span><br><span class="line">                        + Long.toHexString(p.hdr.getZxid()));</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            packetsCommitted.remove();</span><br><span class="line">            Request request = new Request(null, p.hdr.getClientId(),</span><br><span class="line">                    p.hdr.getCxid(), p.hdr.getType(), null, null);</span><br><span class="line">            request.setTxn(p.rec);</span><br><span class="line">            request.setHdr(p.hdr);</span><br><span class="line">            ozk.commitRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // New server type need to handle in-flight packets</span><br><span class="line">        throw new UnsupportedOperationException(&quot;Unknown server type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、FollowerZooKeeperServer的setupRequestProcessors方法"><a href="#2、FollowerZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="2、FollowerZooKeeperServer的setupRequestProcessors方法"></a>2、FollowerZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">    RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">    commitProcessor = new CommitProcessor(finalProcessor,</span><br><span class="line">            Long.toString(getServerId()), true, getZooKeeperServerListener());</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    firstProcessor = new FollowerRequestProcessor(this, commitProcessor);</span><br><span class="line">    ((FollowerRequestProcessor) firstProcessor).start();</span><br><span class="line">    syncProcessor = new SyncRequestProcessor(this,</span><br><span class="line">            new SendAckRequestProcessor((Learner)getFollower()));</span><br><span class="line">    syncProcessor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>follower的初始化，到这儿就结束了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码分布式服务端（1）/" data-id="cjix6ii8i001iegueh4wphbuy" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-helloworld/hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/21/helloworld/hello-world/" class="article-date">
  <time datetime="2018-02-21T14:31:07.107Z" itemprop="datePublished">2018-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/编程/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/21/helloworld/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&lt; !– more –&gt;<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/21/helloworld/hello-world/" data-id="cjix6ii6u000beguen0iwwnvr" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java-util-concurrent/">java.util.concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis3/">mybatis3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码整合MyBatis/">spring源码整合MyBatis</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(2) /">spring源码XmlBeanFactory(2)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(1)/">spring源码XmlBeanFactory(1)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码Transaction/">spring源码Transaction</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码SpringMVC/">spring源码SpringMVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>