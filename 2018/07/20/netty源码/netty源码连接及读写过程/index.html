<!DOCTYPE html>
<html lang="default">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="demonetty客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class EchoClient &amp;#123;    private final String "/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="netty源码连接及读写过程"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="demonetty客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class EchoClient &amp;#123;    private final String "/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>netty源码连接及读写过程 - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>netty源码连接及读写过程</h1>
                    
                    <h2 class="post-subheading">
                        建立连接、读写数据及基于分隔符的解码器
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-07-20
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/netty/">netty</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>netty客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class EchoClient &#123;</span><br><span class="line">    private final String host;</span><br><span class="line">    private final int port;</span><br><span class="line">    </span><br><span class="line">    public EchoClient(String host, int port)&#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">        this.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void start() throws Exception&#123;</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            //创建Bootstrap</span><br><span class="line">            Bootstrap b = new Bootstrap();  </span><br><span class="line">            //指定EventLoopGroup来处理客户端事件</span><br><span class="line">            b.group(group)  </span><br><span class="line">             //指定channel类型</span><br><span class="line">             .channel(NioSocketChannel.class)     </span><br><span class="line">             //设置服务器的InetSocketAddress  </span><br><span class="line">             .remoteAddress(new InetSocketAddress(host, port))   </span><br><span class="line">             //连接初始化器，成功connect后，初始化channel的pipeline</span><br><span class="line">             .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(&quot;framer&quot;,new DelimiterBasedFrameDecoder(1024,Delimiters.lineDelimiter()));</span><br><span class="line">                    ch.pipeline().addLast(&quot;decoder&quot;, new StringDecoder());</span><br><span class="line">                    ch.pipeline().addLast(&quot;encoder&quot;, new StringEncoder());</span><br><span class="line">                    ch.pipeline().addLast(new EchoClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            //连接到远端，一直等到连接完成</span><br><span class="line">            ChannelFuture f = b.connect().sync();</span><br><span class="line">            //一直阻塞到Channel关闭           </span><br><span class="line">            f.channel().closeFuture().sync();               </span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //关闭所有连接池，释放所有资源</span><br><span class="line">            group.shutdownGracefully().sync();              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        new EchoClient(&quot;localhost&quot;, 12000).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器，向服务器发送信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Sharable</span><br><span class="line">//标记这个类的实例可以被多个Channel共享                       </span><br><span class="line">public class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //和服务器的连接建立起来后被调用                          </span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        //当收到连接成功的通知，发送一条消息</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Netty rocks!&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    //从服务器收到一条消息时被调用                           </span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</span><br><span class="line">        //打印收到的消息到日志</span><br><span class="line">        System.out.println(&quot;Client received: &quot; + msg.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    //处理过程中异常发生时被调用                           </span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        //异常发生时，记录错误日志，关闭Channel</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、客户端发起连接"><a href="#一、客户端发起连接" class="headerlink" title="一、客户端发起连接"></a>一、客户端发起连接</h3><h4 id="1、Bootstrap的connect方法"><a href="#1、Bootstrap的connect方法" class="headerlink" title="1、Bootstrap的connect方法"></a>1、Bootstrap的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ChannelFuture connect() &#123;</span><br><span class="line">    //校验group、channelFactory、handler不为空</span><br><span class="line">    validate();</span><br><span class="line">    SocketAddress remoteAddress = this.remoteAddress;</span><br><span class="line">    if (remoteAddress == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;remoteAddress not set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化并建立连接</span><br><span class="line">    return doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、Bootstrap的doResolveAndConnect方法"><a href="#2、Bootstrap的doResolveAndConnect方法" class="headerlink" title="2、Bootstrap的doResolveAndConnect方法"></a>2、Bootstrap的doResolveAndConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;</span><br><span class="line">    //初始化并且注册channel，channel为NioSocketChannel，其余操作与客户端类似</span><br><span class="line">    final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    final Channel channel = regFuture.channel();</span><br><span class="line">    //已注册</span><br><span class="line">    if (regFuture.isDone()) &#123;</span><br><span class="line">        //注册失败</span><br><span class="line">        if (!regFuture.isSuccess()) &#123;</span><br><span class="line">            return regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        //建立连接</span><br><span class="line">        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Registration future is almost always fulfilled already, but just in case it&apos;s not.</span><br><span class="line">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">        //添加监听器，待注册成功再建立连接</span><br><span class="line">        regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                // Directly obtain the cause and do a null check so we only need one volatile read in case of a</span><br><span class="line">                // failure.</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                //注册失败</span><br><span class="line">                if (cause != null) &#123;</span><br><span class="line">                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br><span class="line">                    // IllegalStateException once we try to access the EventLoop of the Channel.</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Registration was successful, so set the correct executor to use.</span><br><span class="line">                    // See https://github.com/netty/netty/issues/2586</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    //建立连接</span><br><span class="line">                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、Bootstrap的doResolveAndConnect方法"><a href="#3、Bootstrap的doResolveAndConnect方法" class="headerlink" title="3、Bootstrap的doResolveAndConnect方法"></a>3、Bootstrap的doResolveAndConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,</span><br><span class="line">                                           final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取channel注册的线程</span><br><span class="line">        final EventLoop eventLoop = channel.eventLoop();</span><br><span class="line">        //获取与此EventLoop相关联的地址解析器，InetSocketAddressResolver</span><br><span class="line">        final AddressResolver&lt;SocketAddress&gt; resolver = this.resolver.getResolver(eventLoop);</span><br><span class="line">        //解析器不支持，或者已经解析了，直接建立连接</span><br><span class="line">        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;</span><br><span class="line">            // Resolver has no idea about what to do with the specified remote address or it&apos;s resolved already.</span><br><span class="line">            //建立连接</span><br><span class="line">            doConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析器解析远程地址</span><br><span class="line">        final Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);</span><br><span class="line">        //已解析完成</span><br><span class="line">        if (resolveFuture.isDone()) &#123;</span><br><span class="line">            final Throwable resolveFailureCause = resolveFuture.cause();</span><br><span class="line">            //解析失败</span><br><span class="line">            if (resolveFailureCause != null) &#123;</span><br><span class="line">                // Failed to resolve immediately</span><br><span class="line">                channel.close();</span><br><span class="line">                promise.setFailure(resolveFailureCause);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Succeeded to resolve immediately; cached? (or did a blocking lookup)</span><br><span class="line">                //建立连接</span><br><span class="line">                doConnect(resolveFuture.getNow(), localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Wait until the name resolution is finished.</span><br><span class="line">        //添加监听器，待解析完成再建立连接</span><br><span class="line">        resolveFuture.addListener(new FutureListener&lt;SocketAddress&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(Future&lt;SocketAddress&gt; future) throws Exception &#123;</span><br><span class="line">                if (future.cause() != null) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    promise.setFailure(future.cause());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    doConnect(future.getNow(), localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable cause) &#123;</span><br><span class="line">        promise.tryFailure(cause);</span><br><span class="line">    &#125;</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、Bootstrap的doConnect方法"><a href="#4、Bootstrap的doConnect方法" class="headerlink" title="4、Bootstrap的doConnect方法"></a>4、Bootstrap的doConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void doConnect(</span><br><span class="line">        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) &#123;</span><br><span class="line"></span><br><span class="line">    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span><br><span class="line">    // the pipeline in its channelRegistered() implementation.</span><br><span class="line">    //获取channel,NioSocketChannel</span><br><span class="line">    final Channel channel = connectPromise.channel();</span><br><span class="line">    //向线程提交任务</span><br><span class="line">    channel.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (localAddress == null) &#123;</span><br><span class="line">                //建立连接</span><br><span class="line">                channel.connect(remoteAddress, connectPromise);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">            &#125;</span><br><span class="line">            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、AbstractChannel的connect方法"><a href="#5、AbstractChannel的connect方法" class="headerlink" title="5、AbstractChannel的connect方法"></a>5、AbstractChannel的connect方法</h4><p>NioSocketChannel的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress) &#123;</span><br><span class="line">    return pipeline.connect(remoteAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6、DefaultChannelPipeline的connect方法"><a href="#6、DefaultChannelPipeline的connect方法" class="headerlink" title="6、DefaultChannelPipeline的connect方法"></a>6、DefaultChannelPipeline的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final ChannelFuture connect(SocketAddress remoteAddress) &#123;</span><br><span class="line">    return tail.connect(remoteAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、AbstractChannelHandlerContext的connect方法"><a href="#7、AbstractChannelHandlerContext的connect方法" class="headerlink" title="7、AbstractChannelHandlerContext的connect方法"></a>7、AbstractChannelHandlerContext的connect方法</h4><p>TailContext的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress) &#123;</span><br><span class="line">    return connect(remoteAddress, newPromise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">    return connect(remoteAddress, null, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture connect(</span><br><span class="line">        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    //远程地址为空</span><br><span class="line">    if (remoteAddress == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;remoteAddress&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //channel已失效</span><br><span class="line">    if (isNotValidPromise(promise, false)) &#123;</span><br><span class="line">        // cancelled</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">    //往前查找第一个outbound类型的handler，默认会查出HeadContext</span><br><span class="line">    final AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    //当前线程为channel注册线程</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        //执行handler的connect方法</span><br><span class="line">        next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        safeExecute(executor, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, null);</span><br><span class="line">    &#125;</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、HeadContext的connect方法"><a href="#8、HeadContext的connect方法" class="headerlink" title="8、HeadContext的connect方法"></a>8、HeadContext的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void connect(</span><br><span class="line">        ChannelHandlerContext ctx,</span><br><span class="line">        SocketAddress remoteAddress, SocketAddress localAddress,</span><br><span class="line">        ChannelPromise promise) throws Exception &#123;</span><br><span class="line">    //unsafe为NioSocketChannelUnsafe</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、AbstractNioUnsafe的connect方法"><a href="#9、AbstractNioUnsafe的connect方法" class="headerlink" title="9、AbstractNioUnsafe的connect方法"></a>9、AbstractNioUnsafe的connect方法</h4><p>NioSocketChannelUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void connect(</span><br><span class="line">        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    //channel已关闭</span><br><span class="line">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //已连接</span><br><span class="line">        if (connectPromise != null) &#123;</span><br><span class="line">            // Already a connect in process.</span><br><span class="line">            throw new ConnectionPendingException();</span><br><span class="line">        &#125;</span><br><span class="line">        //已连接成功</span><br><span class="line">        boolean wasActive = isActive();</span><br><span class="line">        //建立连接</span><br><span class="line">        if (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            //连接成功后续处理</span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">            // Schedule connect timeout.</span><br><span class="line">            int connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">            if (connectTimeoutMillis &gt; 0) &#123;</span><br><span class="line">                //添加延时任务，检查如30秒仍未连接成功，则关闭连接</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;</span><br><span class="line">                        ConnectTimeoutException cause =</span><br><span class="line">                                new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);</span><br><span class="line">                        if (connectPromise != null &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            //监听器，连接操作完成之后检测是否失败，失败则关闭连接</span><br><span class="line">            promise.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    if (future.isCancelled()) &#123;</span><br><span class="line">                        if (connectTimeoutFuture != null) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = null;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10、NioSocketChannel的doConnect方法"><a href="#10、NioSocketChannel的doConnect方法" class="headerlink" title="10、NioSocketChannel的doConnect方法"></a>10、NioSocketChannel的doConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">    //绑定本地端口</span><br><span class="line">    if (localAddress != null) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        //建立连接</span><br><span class="line">        boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        if (!connected) &#123;</span><br><span class="line">            //关注CONNECT就绪</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = true;</span><br><span class="line">        return connected;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、服务端获取连接"><a href="#二、服务端获取连接" class="headerlink" title="二、服务端获取连接"></a>二、服务端获取连接</h3><h4 id="1、NioMessageUnsafe的read方法"><a href="#1、NioMessageUnsafe的read方法" class="headerlink" title="1、NioMessageUnsafe的read方法"></a>1、NioMessageUnsafe的read方法</h4><p>服务端获取连接ACCEPT就绪会执行该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void read() &#123;</span><br><span class="line">    assert eventLoop().inEventLoop();</span><br><span class="line">    //获取channel配置，NioServerSocketChannelConfig</span><br><span class="line">    final ChannelConfig config = config();</span><br><span class="line">    //获取pipeline，DefaultChannelPipeline</span><br><span class="line">    final ChannelPipeline pipeline = pipeline();</span><br><span class="line">    //获取缓存处理器，默认AdaptiveRecvByteBufAllocator的内部类HandleImpl  </span><br><span class="line">    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    //重置allocHandle</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    boolean closed = false;</span><br><span class="line">    Throwable exception = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                //获取连接加入readBuf</span><br><span class="line">                int localRead = doReadMessages(readBuf);</span><br><span class="line">                //等于0表示没有连接进来</span><br><span class="line">                if (localRead == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //已经关闭，则返回-1</span><br><span class="line">                if (localRead &lt; 0) &#123;</span><br><span class="line">                    closed = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //更新读取数据总数totalMessages</span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            //判断是否继续读取数据，读取messages是否小于maxMessagesPerRead</span><br><span class="line">            &#125; while (allocHandle.continueReading());</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int size = readBuf.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = false;</span><br><span class="line">            //从head开始，依次执行handler的channelRead方法</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        //清空readBuf</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        //从head开始，依次执行handler的channelReadComplete方法</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        //发生异常</span><br><span class="line">        if (exception != null) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line">            //依次执行handler的exceptionCaught方法</span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭NioServerSocketChannel</span><br><span class="line">        if (closed) &#123;</span><br><span class="line">            inputShutdown = true;</span><br><span class="line">            if (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // Check if there is a readPending which was not processed yet.</span><br><span class="line">        // This could be for two reasons:</span><br><span class="line">        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br><span class="line">        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br><span class="line">        //</span><br><span class="line">        // See https://github.com/netty/netty/issues/2254</span><br><span class="line">        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、NioServerSocketChannel的doReadMessages方法"><a href="#2、NioServerSocketChannel的doReadMessages方法" class="headerlink" title="2、NioServerSocketChannel的doReadMessages方法"></a>2、NioServerSocketChannel的doReadMessages方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</span><br><span class="line">    //获取连接</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (ch != null) &#123;</span><br><span class="line">            //加入buf</span><br><span class="line">            buf.add(new NioSocketChannel(this, ch));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (Throwable t2) &#123;</span><br><span class="line">            logger.warn(&quot;Failed to close a socket.&quot;, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、接（二、1）ServerBootstrapAcceptor的channelRead方法"><a href="#3、接（二、1）ServerBootstrapAcceptor的channelRead方法" class="headerlink" title="3、接（二、1）ServerBootstrapAcceptor的channelRead方法"></a>3、接（二、1）ServerBootstrapAcceptor的channelRead方法</h4><p>ServerBootstrapAcceptor为初始化NioServerSocketChannel时，添加的处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    //读取到的NioSocketChannel</span><br><span class="line">    final Channel child = (Channel) msg;</span><br><span class="line">    //将childHandler加入child的pipeline</span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    //设置channel的option</span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    //设置channel的attr</span><br><span class="line">    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //将child注册到childGroup线程池</span><br><span class="line">        childGroup.register(child).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                if (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、AbstractNioUnsafe的finishConnect方法"><a href="#4、AbstractNioUnsafe的finishConnect方法" class="headerlink" title="4、AbstractNioUnsafe的finishConnect方法"></a>4、AbstractNioUnsafe的finishConnect方法</h4><p>NioMessageUnsafe、NioSocketChannelUnsafe的父类，客户端及服务端CONNECT就绪都会执行该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void finishConnect() &#123;</span><br><span class="line">    // Note this method is invoked by the event loop only if the connection attempt was</span><br><span class="line">    // neither cancelled nor timed out.</span><br><span class="line"></span><br><span class="line">    assert eventLoop().inEventLoop();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        boolean wasActive = isActive();</span><br><span class="line">        //完成建立连接</span><br><span class="line">        doFinishConnect();</span><br><span class="line">        //连接成功后续处理</span><br><span class="line">        fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &gt; 0 is used</span><br><span class="line">        // See https://github.com/netty/netty/issues/1770</span><br><span class="line">        if (connectTimeoutFuture != null) &#123;</span><br><span class="line">            connectTimeoutFuture.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        connectPromise = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5、AbstractNioUnsafe的fulfillConnectPromise方法"><a href="#5、AbstractNioUnsafe的fulfillConnectPromise方法" class="headerlink" title="5、AbstractNioUnsafe的fulfillConnectPromise方法"></a>5、AbstractNioUnsafe的fulfillConnectPromise方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) &#123;</span><br><span class="line">    if (promise == null) &#123;</span><br><span class="line">        // Closed via cancellation and the promise has been notified already.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span><br><span class="line">    // We still need to ensure we call fireChannelActive() in this case.</span><br><span class="line">    //是否连接成功</span><br><span class="line">    boolean active = isActive();</span><br><span class="line"></span><br><span class="line">    // trySuccess() will return false if a user cancelled the connection attempt.</span><br><span class="line">    //设置连接成功</span><br><span class="line">    boolean promiseSet = promise.trySuccess();</span><br><span class="line"></span><br><span class="line">    // Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span><br><span class="line">    // because what happened is what happened.</span><br><span class="line">    if (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        //从head开始，依次执行handler的channelActive方法</span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If a user cancelled the connection attempt, close the channel, which is followed by channelInactive().</span><br><span class="line">    //失败关闭连接</span><br><span class="line">    if (!promiseSet) &#123;</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、客户端与服务端读写数据过程"><a href="#三、客户端与服务端读写数据过程" class="headerlink" title="三、客户端与服务端读写数据过程"></a>三、客户端与服务端读写数据过程</h3><h4 id="1、EchoClientHandler的channelActive方法"><a href="#1、EchoClientHandler的channelActive方法" class="headerlink" title="1、EchoClientHandler的channelActive方法"></a>1、EchoClientHandler的channelActive方法</h4><p>客户端发送数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override                           </span><br><span class="line">//和服务器的连接建立起来后被调用</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    //当收到连接成功的通知，发送一条消息</span><br><span class="line">    ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Netty rocks!&quot;, CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、AbstractChannelHandlerContext的writeAndFlush方法"><a href="#2、AbstractChannelHandlerContext的writeAndFlush方法" class="headerlink" title="2、AbstractChannelHandlerContext的writeAndFlush方法"></a>2、AbstractChannelHandlerContext的writeAndFlush方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture writeAndFlush(Object msg) &#123;</span><br><span class="line">    //将数据写入 channel并刷新到服务端</span><br><span class="line">    return writeAndFlush(msg, newPromise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) &#123;</span><br><span class="line">    if (msg == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;msg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isNotValidPromise(promise, true)) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        // cancelled</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">    //将数据写入 channel并刷新到服务端</span><br><span class="line">    write(msg, true, promise);</span><br><span class="line"></span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、AbstractChannelHandlerContext的write方法"><a href="#3、AbstractChannelHandlerContext的write方法" class="headerlink" title="3、AbstractChannelHandlerContext的write方法"></a>3、AbstractChannelHandlerContext的write方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</span><br><span class="line">    //获取上一个Outbound类型的处理器,最后一个为HeadContext</span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    final Object m = pipeline.touch(msg, next);</span><br><span class="line">    //获取下一个处理器的工作线程</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    //执行下一个Outbound类型处理器的write、flush方法</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  else &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、HeadContext的write方法"><a href="#4、HeadContext的write方法" class="headerlink" title="4、HeadContext的write方法"></a>4、HeadContext的write方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span><br><span class="line">    //unsafe为NioSocketChannelUnsafe</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、AbstractUnsafe的write方法"><a href="#5、AbstractUnsafe的write方法" class="headerlink" title="5、AbstractUnsafe的write方法"></a>5、AbstractUnsafe的write方法</h4><p>NioSocketChannelUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void write(Object msg, ChannelPromise promise) &#123;</span><br><span class="line">        assertEventLoop();</span><br><span class="line"></span><br><span class="line">        ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">        if (outboundBuffer == null) &#123;</span><br><span class="line">            // If the outboundBuffer is null we know the channel was closed and so</span><br><span class="line">            // need to fail the future right away. If it is not null the handling of the rest</span><br><span class="line">            // will be done in flush0()</span><br><span class="line">            // See https://github.com/netty/netty/issues/2362</span><br><span class="line">            safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">            // release message now to prevent resource-leak</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int size;</span><br><span class="line">        try &#123;</span><br><span class="line">            //默认为空</span><br><span class="line">            msg = filterOutboundMessage(msg);</span><br><span class="line">            //计算msg大小</span><br><span class="line">            size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">            if (size &lt; 0) &#123;</span><br><span class="line">                size = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //数据加入缓存outboundBuffer</span><br><span class="line">        outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6、HeadContext的flush方法"><a href="#6、HeadContext的flush方法" class="headerlink" title="6、HeadContext的flush方法"></a>6、HeadContext的flush方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、AbstractUnsafe的flush方法"><a href="#7、AbstractUnsafe的flush方法" class="headerlink" title="7、AbstractUnsafe的flush方法"></a>7、AbstractUnsafe的flush方法</h4><p>NioSocketChannelUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void flush() &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    if (outboundBuffer == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //标记刷新</span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    //数据刷新到服务端</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="8、NioByteUnsafe的read方法"><a href="#8、NioByteUnsafe的read方法" class="headerlink" title="8、NioByteUnsafe的read方法"></a>8、NioByteUnsafe的read方法</h4><p>服务端读取数据,NioSocketChannelUnsafe的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void read() &#123;</span><br><span class="line">    final ChannelConfig config = config();</span><br><span class="line">    final ChannelPipeline pipeline = pipeline();</span><br><span class="line">    //缓存分配器，默认UnpooledByteBufAllocator</span><br><span class="line">    final ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    //获取缓存处理器，默认AdaptiveRecvByteBufAllocator的内部类HandleImpl  </span><br><span class="line">    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    //重置allocHandle</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = null;</span><br><span class="line">    boolean close = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            //分配缓存</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            //将socketChannel数据写入缓存，并更新totalBytesRead</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            //0表示没有读取到数据，-1表示已经关闭连接</span><br><span class="line">            if (allocHandle.lastBytesRead() &lt;= 0) &#123;</span><br><span class="line">                // nothing was read. release the buffer.</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = null;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; 0;</span><br><span class="line">                if (close) &#123;</span><br><span class="line">                    // There is nothing left to read as we received an EOF.</span><br><span class="line">                    readPending = false;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //totalMessages加1</span><br><span class="line">            allocHandle.incMessagesRead(1);</span><br><span class="line">            readPending = false;</span><br><span class="line">            //从head开始，依次调用handler的channelRead方法</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = null;</span><br><span class="line">        //判断是否继续读取，读取totalMessages是否小于maxMessagesPerRead</span><br><span class="line">        &#125; while (allocHandle.continueReading());</span><br><span class="line">        //调整下次读取时缓存大小，根据本次totalBytesRead调整</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        //从head开始，依次调用handler的channelReadComplete方法</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        //关闭连接</span><br><span class="line">        if (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // Check if there is a readPending which was not processed yet.</span><br><span class="line">        // This could be for two reasons:</span><br><span class="line">        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br><span class="line">        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br><span class="line">        //</span><br><span class="line">        // See https://github.com/netty/netty/issues/2254</span><br><span class="line">        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9、EchoServerHandler的channelRead方法"><a href="#9、EchoServerHandler的channelRead方法" class="headerlink" title="9、EchoServerHandler的channelRead方法"></a>9、EchoServerHandler的channelRead方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">//每次收到消息时被调用</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    //把消息打印到控制台</span><br><span class="line">    System.out.println(&quot;Server received: &quot; + in.toString(CharsetUtil.UTF_8)); </span><br><span class="line">    //将收到的消息写入发送方，不刷新输出消息      </span><br><span class="line">    ctx.write(in);              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、接（三、8）EchoServerHandler的channelRead方法"><a href="#10、接（三、8）EchoServerHandler的channelRead方法" class="headerlink" title="10、接（三、8）EchoServerHandler的channelRead方法"></a>10、接（三、8）EchoServerHandler的channelRead方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override                       </span><br><span class="line">//用来通知handler上一个ChannelRead()是被这批消息中的最后一个消息调用</span><br><span class="line">public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    //刷新缓存的数据到远端，然后关闭Channel</span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、分隔符解码器"><a href="#四、分隔符解码器" class="headerlink" title="四、分隔符解码器"></a>四、分隔符解码器</h3><h4 id="1、实例化DelimiterBasedFrameDecoder"><a href="#1、实例化DelimiterBasedFrameDecoder" class="headerlink" title="1、实例化DelimiterBasedFrameDecoder"></a>1、实例化DelimiterBasedFrameDecoder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters) &#123;</span><br><span class="line">    this(maxFrameLength, true, delimiters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public DelimiterBasedFrameDecoder(</span><br><span class="line">        int maxFrameLength, boolean stripDelimiter, ByteBuf... delimiters) &#123;</span><br><span class="line">    this(maxFrameLength, stripDelimiter, true, delimiters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public DelimiterBasedFrameDecoder(</span><br><span class="line">        int maxFrameLength, boolean stripDelimiter, boolean failFast, ByteBuf... delimiters) &#123;</span><br><span class="line">    //解码数据的最大长度,大于0</span><br><span class="line">    validateMaxFrameLength(maxFrameLength);</span><br><span class="line">    if (delimiters == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;delimiters&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (delimiters.length == 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;empty delimiters&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //分隔符为换行符</span><br><span class="line">    if (isLineBased(delimiters) &amp;&amp; !isSubclass()) &#123;</span><br><span class="line">        //创建LineBasedFrameDecoder</span><br><span class="line">        lineBasedDecoder = new LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);</span><br><span class="line">        this.delimiters = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.delimiters = new ByteBuf[delimiters.length];</span><br><span class="line">        for (int i = 0; i &lt; delimiters.length; i ++) &#123;</span><br><span class="line">            ByteBuf d = delimiters[i];</span><br><span class="line">            validateDelimiter(d);</span><br><span class="line">            this.delimiters[i] = d.slice(d.readerIndex(), d.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        lineBasedDecoder = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxFrameLength = maxFrameLength;</span><br><span class="line">    this.stripDelimiter = stripDelimiter;</span><br><span class="line">    this.failFast = failFast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、实例化LineBasedFrameDecoder"><a href="#2、实例化LineBasedFrameDecoder" class="headerlink" title="2、实例化LineBasedFrameDecoder"></a>2、实例化LineBasedFrameDecoder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public LineBasedFrameDecoder(final int maxLength, final boolean stripDelimiter, final boolean failFast) &#123;</span><br><span class="line">    this.maxLength = maxLength;</span><br><span class="line">    this.failFast = failFast;</span><br><span class="line">    this.stripDelimiter = stripDelimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ByteToMessageDecoder的channelRead方法"><a href="#3、ByteToMessageDecoder的channelRead方法" class="headerlink" title="3、ByteToMessageDecoder的channelRead方法"></a>3、ByteToMessageDecoder的channelRead方法</h4><p>DelimiterBasedFrameDecoder的父类，读取数据后，会执行handler的channelRead方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    //读取数据为字节数组</span><br><span class="line">    if (msg instanceof ByteBuf) &#123;</span><br><span class="line">        CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">        try &#123;</span><br><span class="line">            ByteBuf data = (ByteBuf) msg;</span><br><span class="line">            first = cumulation == null;</span><br><span class="line">            if (first) &#123;</span><br><span class="line">                cumulation = data;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //将data合并到cumulation中</span><br><span class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">            &#125;</span><br><span class="line">            //解码</span><br><span class="line">            callDecode(ctx, cumulation, out);</span><br><span class="line">        &#125; catch (DecoderException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new DecoderException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //cumulation全部读完</span><br><span class="line">            if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">                numReads = 0;</span><br><span class="line">                //清空cumulation</span><br><span class="line">                cumulation.release();</span><br><span class="line">                cumulation = null;</span><br><span class="line">            &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">                // We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br><span class="line">                // See https://github.com/netty/netty/issues/4275</span><br><span class="line">                numReads = 0;</span><br><span class="line">                //默认超过16次仍未清空cumulation，</span><br><span class="line">                //当读索引超过容量的一半时，将readerIndex之后的数据移动到从0开始</span><br><span class="line">                discardSomeReadBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int size = out.size();</span><br><span class="line">            decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">            fireChannelRead(ctx, out, size);</span><br><span class="line">            //重置out</span><br><span class="line">            out.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //继续执行下一个handler的channelRead方法</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、ByteToMessageDecoder的callDecode方法"><a href="#4、ByteToMessageDecoder的callDecode方法" class="headerlink" title="4、ByteToMessageDecoder的callDecode方法"></a>4、ByteToMessageDecoder的callDecode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //存在待读取数据</span><br><span class="line">        while (in.isReadable()) &#123;</span><br><span class="line">            int outSize = out.size();</span><br><span class="line">            //out中有数据，则说明读取到一行数据，继续执行之后的handler的channelRead方法</span><br><span class="line">            if (outSize &gt; 0) &#123;</span><br><span class="line">                fireChannelRead(ctx, out, outSize);</span><br><span class="line">                out.clear();</span><br><span class="line"></span><br><span class="line">                // Check if this handler was removed before continuing with decoding.</span><br><span class="line">                // If it was removed, it is not safe to continue to operate on the buffer.</span><br><span class="line">                //</span><br><span class="line">                // See:</span><br><span class="line">                // - https://github.com/netty/netty/issues/4635</span><br><span class="line">                if (ctx.isRemoved()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                outSize = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            //可读取的数据总长度</span><br><span class="line">            int oldInputLength = in.readableBytes();</span><br><span class="line">            //读取一段数据，读至分隔符</span><br><span class="line">            decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line"></span><br><span class="line">            // Check if this handler was removed before continuing the loop.</span><br><span class="line">            // If it was removed, it is not safe to continue to operate on the buffer.</span><br><span class="line">            //</span><br><span class="line">            // See https://github.com/netty/netty/issues/1664</span><br><span class="line">            //处理器已被移除，跳出循环</span><br><span class="line">            if (ctx.isRemoved()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //out.size()未变，未读到数据</span><br><span class="line">            if (outSize == out.size()) &#123;</span><br><span class="line">                //未找到换行符，跳出循环</span><br><span class="line">                if (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //未读取数据，却解码出数据</span><br><span class="line">            if (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                throw new DecoderException(</span><br><span class="line">                        StringUtil.simpleClassName(getClass()) +</span><br><span class="line">                                &quot;.decode() did not read anything but decoded a message.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (isSingleDecode()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (DecoderException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception cause) &#123;</span><br><span class="line">        throw new DecoderException(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、ByteToMessageDecoder的decodeRemovalReentryProtection方法"><a href="#5、ByteToMessageDecoder的decodeRemovalReentryProtection方法" class="headerlink" title="5、ByteToMessageDecoder的decodeRemovalReentryProtection方法"></a>5、ByteToMessageDecoder的decodeRemovalReentryProtection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final void decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line">    //子类开始解码标记</span><br><span class="line">    decodeState = STATE_CALLING_CHILD_DECODE;</span><br><span class="line">    try &#123;</span><br><span class="line">        decode(ctx, in, out);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //在decodeState为STATE_CALLING_CHILD_DECODE的时候handlerRemoved被调用会更改decodeState的状态</span><br><span class="line">        boolean removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;</span><br><span class="line">        //重置该状态</span><br><span class="line">        decodeState = STATE_INIT;</span><br><span class="line">        //handler已被删除，继续处理剩余数据</span><br><span class="line">        if (removePending) &#123;</span><br><span class="line">            handlerRemoved(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、DelimiterBasedFrameDecoder的decode方法"><a href="#6、DelimiterBasedFrameDecoder的decode方法" class="headerlink" title="6、DelimiterBasedFrameDecoder的decode方法"></a>6、DelimiterBasedFrameDecoder的decode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">    //解码</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    //读到数据则加入out中</span><br><span class="line">    if (decoded != null) &#123;</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception &#123;</span><br><span class="line">    //使用换行符解码</span><br><span class="line">    if (lineBasedDecoder != null) &#123;</span><br><span class="line">        return lineBasedDecoder.decode(ctx, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    // Try all delimiters and choose the delimiter which yields the shortest frame.</span><br><span class="line">    int minFrameLength = Integer.MAX_VALUE;</span><br><span class="line">    ByteBuf minDelim = null;</span><br><span class="line">    //查找最小分隔长度</span><br><span class="line">    for (ByteBuf delim: delimiters) &#123;</span><br><span class="line">        int frameLength = indexOf(buffer, delim);</span><br><span class="line">        if (frameLength &gt;= 0 &amp;&amp; frameLength &lt; minFrameLength) &#123;</span><br><span class="line">            minFrameLength = frameLength;</span><br><span class="line">            minDelim = delim;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //找到分隔符</span><br><span class="line">    if (minDelim != null) &#123;</span><br><span class="line">        int minDelimLength = minDelim.capacity();</span><br><span class="line">        ByteBuf frame;</span><br><span class="line">        //上一轮因过长被废弃</span><br><span class="line">        if (discardingTooLongFrame) &#123;</span><br><span class="line">            // We&apos;ve just finished discarding a very large frame.</span><br><span class="line">            // Go back to the initial state.</span><br><span class="line">            discardingTooLongFrame = false;</span><br><span class="line">            //跳过被废弃的数据</span><br><span class="line">            buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line">            int tooLongFrameLength = this.tooLongFrameLength;</span><br><span class="line">            this.tooLongFrameLength = 0;</span><br><span class="line">            if (!failFast) &#123;</span><br><span class="line">                fail(tooLongFrameLength);</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //数据过长</span><br><span class="line">        if (minFrameLength &gt; maxFrameLength) &#123;</span><br><span class="line">            // Discard read frame.</span><br><span class="line">            //废弃该段数据</span><br><span class="line">            buffer.skipBytes(minFrameLength + minDelimLength);</span><br><span class="line">            fail(minFrameLength);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //读取数据</span><br><span class="line">        if (stripDelimiter) &#123;</span><br><span class="line">            frame = buffer.readRetainedSlice(minFrameLength);</span><br><span class="line">            buffer.skipBytes(minDelimLength);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return frame;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //未找到分隔符,</span><br><span class="line">        if (!discardingTooLongFrame) &#123;</span><br><span class="line">            //检查数据是否过长</span><br><span class="line">            if (buffer.readableBytes() &gt; maxFrameLength) &#123;</span><br><span class="line">                // Discard the content of the buffer until a delimiter is found.</span><br><span class="line">                tooLongFrameLength = buffer.readableBytes();</span><br><span class="line">                buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">                discardingTooLongFrame = true;</span><br><span class="line">                if (failFast) &#123;</span><br><span class="line">                    fail(tooLongFrameLength);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        //未找到分隔符,且上轮数据过长被废弃，直接废弃跳过数据</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Still discarding the buffer since a delimiter is not found.</span><br><span class="line">            tooLongFrameLength += buffer.readableBytes();</span><br><span class="line">            buffer.skipBytes(buffer.readableBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、LineBasedFrameDecoder的decode方法"><a href="#7、LineBasedFrameDecoder的decode方法" class="headerlink" title="7、LineBasedFrameDecoder的decode方法"></a>7、LineBasedFrameDecoder的decode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception &#123;</span><br><span class="line">    //查找换行符位置</span><br><span class="line">    final int eol = findEndOfLine(buffer);</span><br><span class="line">    //上一轮数据是否废弃</span><br><span class="line">    if (!discarding) &#123;</span><br><span class="line">        //存在分隔符</span><br><span class="line">        if (eol &gt;= 0) &#123;</span><br><span class="line">            final ByteBuf frame;</span><br><span class="line">            //待读取长度</span><br><span class="line">            final int length = eol - buffer.readerIndex();</span><br><span class="line">            //分隔符即换行符长度，Unix为“\n”、Windows为“\r\n”</span><br><span class="line">            final int delimLength = buffer.getByte(eol) == &apos;\r&apos;? 2 : 1;</span><br><span class="line">            //长度大于最大长度</span><br><span class="line">            if (length &gt; maxLength) &#123;</span><br><span class="line">                //更新读取标记，废弃数据至分隔符</span><br><span class="line">                buffer.readerIndex(eol + delimLength);</span><br><span class="line">                //广播异常</span><br><span class="line">                fail(ctx, length);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //是否删除分隔符</span><br><span class="line">            if (stripDelimiter) &#123;</span><br><span class="line">                //读取数据</span><br><span class="line">                frame = buffer.readRetainedSlice(length);</span><br><span class="line">                //跳过分隔符</span><br><span class="line">                buffer.skipBytes(delimLength);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //读取数据包括分隔符</span><br><span class="line">                frame = buffer.readRetainedSlice(length + delimLength);</span><br><span class="line">            &#125;</span><br><span class="line">            return frame;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //数据长度</span><br><span class="line">            final int length = buffer.readableBytes();</span><br><span class="line">            //长度大于最大长度</span><br><span class="line">            if (length &gt; maxLength) &#123;</span><br><span class="line">                //废弃该数据</span><br><span class="line">                discardedBytes = length;</span><br><span class="line">                //更新读取标记</span><br><span class="line">                buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">                //废弃该数据</span><br><span class="line">                discarding = true;</span><br><span class="line">                offset = 0;</span><br><span class="line">                if (failFast) &#123;</span><br><span class="line">                    fail(ctx, &quot;over &quot; + discardedBytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //上轮数据废弃，且找到分隔符，废弃数据至分隔符</span><br><span class="line">        if (eol &gt;= 0) &#123;</span><br><span class="line">            final int length = discardedBytes + eol - buffer.readerIndex();</span><br><span class="line">            final int delimLength = buffer.getByte(eol) == &apos;\r&apos;? 2 : 1;</span><br><span class="line">            //更新读取标记</span><br><span class="line">            buffer.readerIndex(eol + delimLength);</span><br><span class="line">            //清空废弃数据</span><br><span class="line">            discardedBytes = 0;</span><br><span class="line">            //废弃标记</span><br><span class="line">            discarding = false;</span><br><span class="line">            if (!failFast) &#123;</span><br><span class="line">                fail(ctx, length);</span><br><span class="line">            &#125;</span><br><span class="line">        //上轮数据废弃，且未找到分隔符，废弃数据</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //更新废弃的数据</span><br><span class="line">            discardedBytes += buffer.readableBytes();</span><br><span class="line">            //更新读取标记</span><br><span class="line">            buffer.readerIndex(buffer.writerIndex());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>