<!DOCTYPE html>
<html lang="default">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="一、请求处理过程1、NioEndpoint的setSocketOptions方法1234567891011121314151617181920212223242526272829303132333435363738394041protected boolean setSocketOptions(So"/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Tomcat源码请求处理过程"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="一、请求处理过程1、NioEndpoint的setSocketOptions方法1234567891011121314151617181920212223242526272829303132333435363738394041protected boolean setSocketOptions(So"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>Tomcat源码请求处理过程 - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Tomcat源码请求处理过程</h1>
                    
                    <h2 class="post-subheading">
                        请求处理过程、session管理及异步任务
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-07-11
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/tomcat/">tomcat</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="一、请求处理过程"><a href="#一、请求处理过程" class="headerlink" title="一、请求处理过程"></a>一、请求处理过程</h3><h4 id="1、NioEndpoint的setSocketOptions方法"><a href="#1、NioEndpoint的setSocketOptions方法" class="headerlink" title="1、NioEndpoint的setSocketOptions方法"></a>1、NioEndpoint的setSocketOptions方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected boolean setSocketOptions(SocketChannel socket) &#123;</span><br><span class="line">    // Process the connection</span><br><span class="line">    try &#123;</span><br><span class="line">        //disable blocking, APR style, we are gonna be polling it</span><br><span class="line">        //设置非阻塞</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        //设置属性</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line">        //获取NioChannel</span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        if (channel == null) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler = new SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            if (isSSLEnabled()) &#123;</span><br><span class="line">                channel = new SecureNioChannel(socket, bufhandler, selectorPool, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //创建NioChannel</span><br><span class="line">                channel = new NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //重置NioChannel</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        //依次向Poller中注册channel</span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        try &#123;</span><br><span class="line">            log.error(&quot;&quot;,t);</span><br><span class="line">        &#125; catch (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        // Tell to close the socket</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、Poller的register方法"><a href="#2、Poller的register方法" class="headerlink" title="2、Poller的register方法"></a>2、Poller的register方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void register(final NioChannel socket) &#123;</span><br><span class="line">    socket.setPoller(this);</span><br><span class="line">    NioSocketWrapper ka = new NioSocketWrapper(socket, NioEndpoint.this);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(this);</span><br><span class="line">    //超时时间</span><br><span class="line">    ka.setReadTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">    ka.setWriteTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">    //连接存活时间，默认100s</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    //获取任务缓存</span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    //设置interestOps</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.</span><br><span class="line">    //创建或重置任务</span><br><span class="line">    if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    else r.reset(socket,ka,OP_REGISTER);</span><br><span class="line">    //往Poller任务队列中添加</span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、Poller的run方法"><a href="#3、Poller的run方法" class="headerlink" title="3、Poller的run方法"></a>3、Poller的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // Loop until destroy() is called</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        boolean hasEvents = false;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (!close) &#123;</span><br><span class="line">                //注册PollerEvent中的任务</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                //查看就绪事件个数</span><br><span class="line">                if (wakeupCounter.getAndSet(-1) &gt; 0) &#123;</span><br><span class="line">                    //if we are here, means we have other stuff to do</span><br><span class="line">                    //do a non blocking select</span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                //重置wakeupCounter</span><br><span class="line">                wakeupCounter.set(0);</span><br><span class="line">            &#125;</span><br><span class="line">            //关闭Poller</span><br><span class="line">            if (close) &#123;</span><br><span class="line">                events();</span><br><span class="line">                timeout(0, false);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //关闭selector</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; catch (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;endpoint.nio.selectorCloseFail&quot;), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(&quot;&quot;,x);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //either we timed out or we woke up, process events first</span><br><span class="line">        if ( keyCount == 0 ) hasEvents = (hasEvents | events());</span><br><span class="line">        //获取就绪的事件</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;</span><br><span class="line">        // Walk through the collection of ready keys and dispatch</span><br><span class="line">        // any active event.</span><br><span class="line">        while (iterator != null &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            // Attachment may be null if another thread has called</span><br><span class="line">            // cancelledKey()</span><br><span class="line">            // 去除并处理该事件</span><br><span class="line">            if (attachment == null) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//while</span><br><span class="line"></span><br><span class="line">        //process timeouts</span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;//while</span><br><span class="line">    //stopLatch减一</span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、Poller的events方法"><a href="#4、Poller的events方法" class="headerlink" title="4、Poller的events方法"></a>4、Poller的events方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean events() &#123;</span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = null;</span><br><span class="line">    for (int i = 0, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != null; i++ ) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            //注册任务</span><br><span class="line">            pe.run();</span><br><span class="line">            //重置PollerEvent</span><br><span class="line">            pe.reset();</span><br><span class="line">            if (running &amp;&amp; !paused) &#123;</span><br><span class="line">                //加入缓存</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch ( Throwable x ) &#123;</span><br><span class="line">            log.error(&quot;&quot;,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、PollerEvent的run方法"><a href="#5、PollerEvent的run方法" class="headerlink" title="5、PollerEvent的run方法"></a>5、PollerEvent的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (interestOps == OP_REGISTER) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //向Poller的selector中注册OP_READ，关注读数据就绪事件 </span><br><span class="line">            socket.getIOChannel().register(</span><br><span class="line">                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125; catch (Exception x) &#123;</span><br><span class="line">            log.error(sm.getString(&quot;endpoint.nio.registerFail&quot;), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //获取注册到该Poller的selector上的key</span><br><span class="line">        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">        try &#123;</span><br><span class="line">            //该key已关闭</span><br><span class="line">            if (key == null) &#123;</span><br><span class="line">                // The key was cancelled (e.g. due to socket closure)</span><br><span class="line">                // and removed from the selector while it was being</span><br><span class="line">                // processed. Count down the connections at this point</span><br><span class="line">                // since it won&apos;t have been counted down when the socket</span><br><span class="line">                // closed.</span><br><span class="line">                // 连接数减一</span><br><span class="line">                socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                if (socketWrapper != null) &#123;</span><br><span class="line">                    //we are registering the key to start with, reset the fairness counter.</span><br><span class="line">                    //向Poller的selector中添加注册interestOps，添加关注interestOps数据就绪事件</span><br><span class="line">                    int ops = key.interestOps() | interestOps;</span><br><span class="line">                    socketWrapper.interestOps(ops);</span><br><span class="line">                    key.interestOps(ops);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //关闭该key</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (CancelledKeyException ckx) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                socket.getPoller().cancelledKey(key);</span><br><span class="line">            &#125; catch (Exception ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（一、3）Poller的processKey方法"><a href="#6、接（一、3）Poller的processKey方法" class="headerlink" title="6、接（一、3）Poller的processKey方法"></a>6、接（一、3）Poller的processKey方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">protected void processKey(SelectionKey sk, NioSocketWrapper attachment) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //Poller已关闭，关闭该key</span><br><span class="line">        if ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; else if ( sk.isValid() &amp;&amp; attachment != null ) &#123;</span><br><span class="line">            //读数据事件或者写数据事件就绪</span><br><span class="line">            if (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                //以文件形式发送给客户端</span><br><span class="line">                if ( attachment.getSendfileData() != null ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //去除对于已就绪事件的关注，防止socket变脏</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    boolean closeSocket = false;</span><br><span class="line">                    // Read goes before write</span><br><span class="line">                    // 处理读数据</span><br><span class="line">                    if (sk.isReadable()) &#123;</span><br><span class="line">                        if (!processSocket(attachment, SocketEvent.OPEN_READ, true)) &#123;</span><br><span class="line">                            closeSocket = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 处理写数据</span><br><span class="line">                    if (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        if (!processSocket(attachment, SocketEvent.OPEN_WRITE, true)) &#123;</span><br><span class="line">                            closeSocket = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //关闭socket</span><br><span class="line">                    if (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //invalid key</span><br><span class="line">            //关闭key</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        //关闭key</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(&quot;&quot;,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、AbstractEndpoint的processKey方法"><a href="#7、AbstractEndpoint的processKey方法" class="headerlink" title="7、AbstractEndpoint的processKey方法"></a>7、AbstractEndpoint<s>的processKey方法</s></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="line">        SocketEvent event, boolean dispatch) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (socketWrapper == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取处理器</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        //创建或重置处理器，默认SocketProcessor</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        //执行处理器</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        if (dispatch &amp;&amp; executor != null) &#123;</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(&quot;endpoint.executor.fail&quot;, socketWrapper) , ree);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        // This means we got an OOM or similar creating a thread, or that</span><br><span class="line">        // the pool and its queue are full</span><br><span class="line">        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;), t);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、SocketProcessor的doRun方法"><a href="#8、SocketProcessor的doRun方法" class="headerlink" title="8、SocketProcessor的doRun方法"></a>8、SocketProcessor的doRun方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRun() &#123;</span><br><span class="line">    NioChannel socket = socketWrapper.getSocket();</span><br><span class="line">    //获取注册到Poller的selector中的key</span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        int handshake = -1;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (key != null) &#123;</span><br><span class="line">                //默认返回true</span><br><span class="line">                if (socket.isHandshakeComplete()) &#123;</span><br><span class="line">                    // No TLS handshaking required. Let the handler</span><br><span class="line">                    // process this socket / event combination.</span><br><span class="line">                    handshake = 0;</span><br><span class="line">                &#125; else if (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||</span><br><span class="line">                        event == SocketEvent.ERROR) &#123;</span><br><span class="line">                    // Unable to complete the TLS handshake. Treat it as</span><br><span class="line">                    // if the handshake failed.</span><br><span class="line">                    handshake = -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    handshake = socket.handshake(key.isReadable(), key.isWritable());</span><br><span class="line">                    // The handshake process reads/writes from/to the</span><br><span class="line">                    // socket. status may therefore be OPEN_WRITE once</span><br><span class="line">                    // the handshake completes. However, the handshake</span><br><span class="line">                    // happens when the socket is opened so the status</span><br><span class="line">                    // must always be OPEN_READ after it completes. It</span><br><span class="line">                    // is OK to always set this as it is only used if</span><br><span class="line">                    // the handshake completes.</span><br><span class="line">                    event = SocketEvent.OPEN_READ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException x) &#123;</span><br><span class="line">            handshake = -1;</span><br><span class="line">            if (log.isDebugEnabled()) log.debug(&quot;Error during SSL handshake&quot;,x);</span><br><span class="line">        &#125; catch (CancelledKeyException ckx) &#123;</span><br><span class="line">            handshake = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (handshake == 0) &#123;</span><br><span class="line">            SocketState state = SocketState.OPEN;</span><br><span class="line">            // Process the request from this socket</span><br><span class="line">            if (event == null) &#123;</span><br><span class="line">                state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //获取ConnectionHandler，处理socket</span><br><span class="line">                state = getHandler().process(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            if (state == SocketState.CLOSED) &#123;</span><br><span class="line">                //关闭socket</span><br><span class="line">                close(socket, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (handshake == -1 ) &#123;</span><br><span class="line">            //关闭socket</span><br><span class="line">            close(socket, key);</span><br><span class="line">        &#125; else if (handshake == SelectionKey.OP_READ)&#123;</span><br><span class="line">            //注册关注读数据就绪事件</span><br><span class="line">            socketWrapper.registerReadInterest();</span><br><span class="line">        &#125; else if (handshake == SelectionKey.OP_WRITE)&#123;</span><br><span class="line">            //注册关注写数据就绪事件</span><br><span class="line">            socketWrapper.registerWriteInterest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (CancelledKeyException cx) &#123;</span><br><span class="line">        socket.getPoller().cancelledKey(key);</span><br><span class="line">    &#125; catch (VirtualMachineError vme) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(vme);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        log.error(&quot;&quot;, t);</span><br><span class="line">        socket.getPoller().cancelledKey(key);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        socketWrapper = null;</span><br><span class="line">        event = null;</span><br><span class="line">        //return to cache</span><br><span class="line">        if (running &amp;&amp; !paused) &#123;</span><br><span class="line">            processorCache.push(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ConnectionHandler的process方法"><a href="#9、ConnectionHandler的process方法" class="headerlink" title="9、ConnectionHandler的process方法"></a>9、ConnectionHandler的process方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SocketState process(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status) &#123;</span><br><span class="line">    if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">        getLog().debug(sm.getString(&quot;abstractConnectionHandler.process&quot;,</span><br><span class="line">                wrapper.getSocket(), status));</span><br><span class="line">    &#125;</span><br><span class="line">    // Socket已关闭</span><br><span class="line">    if (wrapper == null) &#123;</span><br><span class="line">        // Nothing to do. Socket has been closed.</span><br><span class="line">        return SocketState.CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S socket = wrapper.getSocket();</span><br><span class="line"></span><br><span class="line">    //获取socket对应的处理器，获取到说明该请求为异步任务</span><br><span class="line">    Processor processor = connections.get(socket);</span><br><span class="line">    if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">        getLog().debug(sm.getString(&quot;abstractConnectionHandler.connectionsGet&quot;,</span><br><span class="line">                processor, socket));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (processor != null) &#123;</span><br><span class="line">        // Make sure an async timeout doesn&apos;t fire</span><br><span class="line">        //从等待处理完成的异步任务集合中，去除该socket的异步任务</span><br><span class="line">        getProtocol().removeWaitingProcessor(processor);</span><br><span class="line">    &#125; else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) &#123;</span><br><span class="line">        // Nothing to do. Endpoint requested a close and there is no</span><br><span class="line">        // longer a processor associated with this socket.</span><br><span class="line">        return SocketState.CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContainerThreadMarker.set();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (processor == null) &#123;</span><br><span class="line">            //获取协商协议</span><br><span class="line">            String negotiatedProtocol = wrapper.getNegotiatedProtocol();</span><br><span class="line">            if (negotiatedProtocol != null) &#123;</span><br><span class="line">                UpgradeProtocol upgradeProtocol =</span><br><span class="line">                        getProtocol().getNegotiatedProtocol(negotiatedProtocol);</span><br><span class="line">                if (upgradeProtocol != null) &#123;</span><br><span class="line">                    processor = upgradeProtocol.getProcessor(</span><br><span class="line">                            wrapper, getProtocol().getAdapter());</span><br><span class="line">                &#125; else if (negotiatedProtocol.equals(&quot;http/1.1&quot;)) &#123;</span><br><span class="line">                    // Explicitly negotiated the default protocol.</span><br><span class="line">                    // Obtain a processor below.</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // TODO:</span><br><span class="line">                    // OpenSSL 1.0.2&apos;s ALPN callback doesn&apos;t support</span><br><span class="line">                    // failing the handshake with an error if no</span><br><span class="line">                    // protocol can be negotiated. Therefore, we need to</span><br><span class="line">                    // fail the connection here. Once this is fixed,</span><br><span class="line">                    // replace the code below with the commented out</span><br><span class="line">                    // block.</span><br><span class="line">                    if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                        getLog().debug(sm.getString(</span><br><span class="line">                            &quot;abstractConnectionHandler.negotiatedProcessor.fail&quot;,</span><br><span class="line">                            negotiatedProtocol));</span><br><span class="line">                    &#125;</span><br><span class="line">                    return SocketState.CLOSED;</span><br><span class="line">                    /*</span><br><span class="line">                     * To replace the code above once OpenSSL 1.1.0 is</span><br><span class="line">                     * used.</span><br><span class="line">                    // Failed to create processor. This is a bug.</span><br><span class="line">                    throw new IllegalStateException(sm.getString(</span><br><span class="line">                            &quot;abstractConnectionHandler.negotiatedProcessor.fail&quot;,</span><br><span class="line">                            negotiatedProtocol));</span><br><span class="line">                    */</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (processor == null) &#123;</span><br><span class="line">            //从队列中获取processor,processor在处理完任务之后会被重置并加入该队列</span><br><span class="line">            processor = recycledProcessors.pop();</span><br><span class="line">            if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                getLog().debug(sm.getString(&quot;abstractConnectionHandler.processorPop&quot;,</span><br><span class="line">                        processor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建处理器，默认Http11Processor</span><br><span class="line">        if (processor == null) &#123;</span><br><span class="line">            processor = getProtocol().createProcessor();</span><br><span class="line">            register(processor);</span><br><span class="line">        &#125;</span><br><span class="line">        //是否支持ssl协议</span><br><span class="line">        processor.setSslSupport(</span><br><span class="line">                wrapper.getSslSupport(getProtocol().getClientCertProvider()));</span><br><span class="line"></span><br><span class="line">        // Associate the processor with the connection</span><br><span class="line">        // 建立socket与processor映射</span><br><span class="line">        connections.put(socket, processor);</span><br><span class="line"></span><br><span class="line">        SocketState state = SocketState.CLOSED;</span><br><span class="line">        do &#123;</span><br><span class="line">            //处理socket</span><br><span class="line">            state = processor.process(wrapper, status);</span><br><span class="line">            //使用HTTP/2协议处理该请求</span><br><span class="line">            if (state == SocketState.UPGRADING) &#123;</span><br><span class="line">                // Get the HTTP upgrade handler</span><br><span class="line">                UpgradeToken upgradeToken = processor.getUpgradeToken();</span><br><span class="line">                // Retrieve leftover input</span><br><span class="line">                ByteBuffer leftOverInput = processor.getLeftoverInput();</span><br><span class="line">                if (upgradeToken == null) &#123;</span><br><span class="line">                    // Assume direct HTTP/2 connection</span><br><span class="line">                    UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(&quot;h2c&quot;);</span><br><span class="line">                    if (upgradeProtocol != null) &#123;</span><br><span class="line">                        processor = upgradeProtocol.getProcessor(</span><br><span class="line">                                wrapper, getProtocol().getAdapter());</span><br><span class="line">                        wrapper.unRead(leftOverInput);</span><br><span class="line">                        // Associate with the processor with the connection</span><br><span class="line">                        connections.put(socket, processor);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                            getLog().debug(sm.getString(</span><br><span class="line">                                &quot;abstractConnectionHandler.negotiatedProcessor.fail&quot;,</span><br><span class="line">                                &quot;h2c&quot;));</span><br><span class="line">                        &#125;</span><br><span class="line">                        return SocketState.CLOSED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();</span><br><span class="line">                    // Release the Http11 processor to be re-used</span><br><span class="line">                    release(processor);</span><br><span class="line">                    // Create the upgrade processor</span><br><span class="line">                    processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);</span><br><span class="line">                    if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">                        getLog().debug(sm.getString(&quot;abstractConnectionHandler.upgradeCreate&quot;,</span><br><span class="line">                                processor, wrapper));</span><br><span class="line">                    &#125;</span><br><span class="line">                    wrapper.unRead(leftOverInput);</span><br><span class="line">                    // Mark the connection as upgraded</span><br><span class="line">                    wrapper.setUpgraded(true);</span><br><span class="line">                    // Associate with the processor with the connection</span><br><span class="line">                    connections.put(socket, processor);</span><br><span class="line">                    // Initialise the upgrade handler (which may trigger</span><br><span class="line">                    // some IO using the new protocol which is why the lines</span><br><span class="line">                    // above are necessary)</span><br><span class="line">                    // This cast should be safe. If it fails the error</span><br><span class="line">                    // handling for the surrounding try/catch will deal with</span><br><span class="line">                    // it.</span><br><span class="line">                    if (upgradeToken.getInstanceManager() == null) &#123;</span><br><span class="line">                        httpUpgradeHandler.init((WebConnection) processor);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            httpUpgradeHandler.init((WebConnection) processor);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            upgradeToken.getContextBind().unbind(false, oldCL);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while ( state == SocketState.UPGRADING);</span><br><span class="line"></span><br><span class="line">        //该请求为异步任务</span><br><span class="line">        if (state == SocketState.LONG) &#123;</span><br><span class="line">            // In the middle of processing a request/response. Keep the</span><br><span class="line">            // socket associated with the processor. Exact requirements</span><br><span class="line">            // depend on type of long poll</span><br><span class="line">            longPoll(wrapper, processor);</span><br><span class="line">            if (processor.isAsync()) &#123;</span><br><span class="line">                //异步任务把processor添加到等待队列中继续处理读写，异步任务即使用业务线程池处理任务，</span><br><span class="line">                //这样不会占用Executor线程数，可以增加系统的吞吐量</span><br><span class="line">                getProtocol().addWaitingProcessor(processor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (state == SocketState.OPEN) &#123;</span><br><span class="line">            // In keep-alive but between requests. OK to recycle</span><br><span class="line">            // processor. Continue to poll for the next request.</span><br><span class="line">            //请求已处理完且为http长连接，回收processor对象，然后再将channel注册到poller上面去继续等待，  </span><br><span class="line">            //一个http连接可以发送多次请求</span><br><span class="line">            connections.remove(socket);</span><br><span class="line">            release(processor);</span><br><span class="line">            wrapper.registerReadInterest();</span><br><span class="line">        &#125; else if (state == SocketState.SENDFILE) &#123;</span><br><span class="line">            // Sendfile in progress. If it fails, the socket will be</span><br><span class="line">            // closed. If it works, the socket either be added to the</span><br><span class="line">            // poller (or equivalent) to await more data or processed</span><br><span class="line">            // if there are any pipe-lined requests remaining.</span><br><span class="line">        &#125; else if (state == SocketState.UPGRADED) &#123;</span><br><span class="line">            // Don&apos;t add sockets back to the poller if this was a</span><br><span class="line">            // non-blocking write otherwise the poller may trigger</span><br><span class="line">            // multiple read events which may lead to thread starvation</span><br><span class="line">            // in the connector. The write() method will add this socket</span><br><span class="line">            // to the poller if necessary.</span><br><span class="line">            if (status != SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                longPoll(wrapper, processor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (state == SocketState.SUSPENDED) &#123;</span><br><span class="line">            // Don&apos;t add sockets back to the poller.</span><br><span class="line">            // The resumeProcessing() method will add this socket</span><br><span class="line">            // to the poller.</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Connection closed. OK to recycle the processor. Upgrade</span><br><span class="line">            // processors are not recycled.</span><br><span class="line">            // 重置处理器，并关闭连接</span><br><span class="line">            connections.remove(socket);</span><br><span class="line">            if (processor.isUpgrade()) &#123;</span><br><span class="line">                UpgradeToken upgradeToken = processor.getUpgradeToken();</span><br><span class="line">                HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();</span><br><span class="line">                InstanceManager instanceManager = upgradeToken.getInstanceManager();</span><br><span class="line">                if (instanceManager == null) &#123;</span><br><span class="line">                    httpUpgradeHandler.destroy();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        httpUpgradeHandler.destroy();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            instanceManager.destroyInstance(httpUpgradeHandler);</span><br><span class="line">                        &#125; catch (Throwable e) &#123;</span><br><span class="line">                            ExceptionUtils.handleThrowable(e);</span><br><span class="line">                            getLog().error(sm.getString(&quot;abstractConnectionHandler.error&quot;), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        upgradeToken.getContextBind().unbind(false, oldCL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                release(processor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return state;</span><br><span class="line">    &#125; catch(java.net.SocketException e) &#123;</span><br><span class="line">        // SocketExceptions are normal</span><br><span class="line">        getLog().debug(sm.getString(</span><br><span class="line">                &quot;abstractConnectionHandler.socketexception.debug&quot;), e);</span><br><span class="line">    &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">        // IOExceptions are normal</span><br><span class="line">        getLog().debug(sm.getString(</span><br><span class="line">                &quot;abstractConnectionHandler.ioexception.debug&quot;), e);</span><br><span class="line">    &#125; catch (ProtocolException e) &#123;</span><br><span class="line">        // Protocol exceptions normally mean the client sent invalid or</span><br><span class="line">        // incomplete data.</span><br><span class="line">        getLog().debug(sm.getString(</span><br><span class="line">                &quot;abstractConnectionHandler.protocolexception.debug&quot;), e);</span><br><span class="line">    &#125;</span><br><span class="line">    // Future developers: if you discover any other</span><br><span class="line">    // rare-but-nonfatal exceptions, catch them here, and log as</span><br><span class="line">    // above.</span><br><span class="line">    catch (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        // any other exception or error is odd. Here we log it</span><br><span class="line">        // with &quot;ERROR&quot; level, so it will show up even on</span><br><span class="line">        // less-than-verbose logs.</span><br><span class="line">        getLog().error(sm.getString(&quot;abstractConnectionHandler.error&quot;), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ContainerThreadMarker.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make sure socket/processor is removed from the list of current</span><br><span class="line">    // connections</span><br><span class="line">    // 重置处理器，并关闭连接</span><br><span class="line">    connections.remove(socket);</span><br><span class="line">    release(processor);</span><br><span class="line">    return SocketState.CLOSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、AbstractProcessorLight的process方法"><a href="#10、AbstractProcessorLight的process方法" class="headerlink" title="10、AbstractProcessorLight的process方法"></a>10、AbstractProcessorLight的process方法</h4><p>Http11Processor的父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SocketState process(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    SocketState state = SocketState.CLOSED;</span><br><span class="line">    Iterator&lt;DispatchType&gt; dispatches = null;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (dispatches != null) &#123;</span><br><span class="line">            DispatchType nextDispatch = dispatches.next();</span><br><span class="line">            // 异步任务的后续处理,处理read或者write</span><br><span class="line">            state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">        &#125; else if (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">            // Do nothing here, just wait for it to get recycled</span><br><span class="line">        &#125; else if (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;</span><br><span class="line">            //异步任务的后续处理，直接返回给客户端结果或转发请求给其他的servlet。</span><br><span class="line">            state = dispatch(status);</span><br><span class="line">            if (state == SocketState.OPEN) &#123;</span><br><span class="line">                // There may be pipe-lined data to read. If the data isn&apos;t</span><br><span class="line">                // processed now, execution will exit this loop and call</span><br><span class="line">                // release() which will recycle the processor (and input</span><br><span class="line">                // buffer) deleting any pipe-lined data. To avoid this,</span><br><span class="line">                // process it now.</span><br><span class="line">                // 异步任务处理完成，处理新请求</span><br><span class="line">                state = service(socketWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">            // Extra write event likely after async, ignore</span><br><span class="line">            state = SocketState.LONG;</span><br><span class="line">        &#125; else if (status == SocketEvent.OPEN_READ)&#123;</span><br><span class="line">            //读取socket的数据封装成request和response对象，然后把这个两个对象交给容器</span><br><span class="line">            state = service(socketWrapper);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Default to closing the socket if the SocketEvent passed in</span><br><span class="line">            // is not consistent with the current state of the Processor</span><br><span class="line">            state = SocketState.CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">        //异步任务，如果已处理完毕，则返回ASYNC_END，</span><br><span class="line">        //如果未处理完毕，释放当前占用的容器线程池，等待异步servlet通知容器线程池重新处理servlet</span><br><span class="line">        if (state != SocketState.CLOSED &amp;&amp; isAsync()) &#123;</span><br><span class="line">            state = asyncPostProcess();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (getLog().isDebugEnabled()) &#123;</span><br><span class="line">            getLog().debug(&quot;Socket: [&quot; + socketWrapper +</span><br><span class="line">                    &quot;], Status in: [&quot; + status +</span><br><span class="line">                    &quot;], State out: [&quot; + state + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (dispatches == null || !dispatches.hasNext()) &#123;</span><br><span class="line">            // Only returns non-null iterator if there are</span><br><span class="line">            // dispatches to process.</span><br><span class="line">            // 获取待后续处理的异步任务</span><br><span class="line">            dispatches = getIteratorAndClearDispatches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (state == SocketState.ASYNC_END ||</span><br><span class="line">            dispatches != null &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="11、Http11Processor的service方法"><a href="#11、Http11Processor的service方法" class="headerlink" title="11、Http11Processor的service方法"></a>11、Http11Processor的service方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SocketState service(SocketWrapperBase&lt;?&gt; socketWrapper)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    RequestInfo rp = request.getRequestProcessor();</span><br><span class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);</span><br><span class="line"></span><br><span class="line">    // Setting up the I/O</span><br><span class="line">    setSocketWrapper(socketWrapper);</span><br><span class="line">    //初始化读缓冲区</span><br><span class="line">    inputBuffer.init(socketWrapper);</span><br><span class="line">    //初始化写缓冲区</span><br><span class="line">    outputBuffer.init(socketWrapper);</span><br><span class="line"></span><br><span class="line">    // Flags</span><br><span class="line">    // 是否为http长连接</span><br><span class="line">    keepAlive = true;</span><br><span class="line">    openSocket = false;</span><br><span class="line">    //读是否完成</span><br><span class="line">    readComplete = true;</span><br><span class="line">    boolean keptAlive = false;</span><br><span class="line">    SendfileState sendfileState = SendfileState.DONE;</span><br><span class="line"></span><br><span class="line">    while (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !isAsync() &amp;&amp; upgradeToken == null &amp;&amp;</span><br><span class="line">            sendfileState == SendfileState.DONE &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">        // Parsing the request header</span><br><span class="line">        try &#123;</span><br><span class="line">            //读取请求行</span><br><span class="line">            if (!inputBuffer.parseRequestLine(keptAlive)) &#123;</span><br><span class="line">                if (inputBuffer.getParsingRequestLinePhase() == -1) &#123;</span><br><span class="line">                    // 使用http2.0</span><br><span class="line">                    return SocketState.UPGRADING;</span><br><span class="line">                &#125; else if (handleIncompleteRequestLineRead()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //已挂起</span><br><span class="line">            if (endpoint.isPaused()) &#123;</span><br><span class="line">                // 503 - Service unavailable</span><br><span class="line">                // 503 网站不可用</span><br><span class="line">                response.setStatus(503);</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 默认http长连接</span><br><span class="line">                keptAlive = true;</span><br><span class="line">                // Set this every time in case limit has been changed via JMX</span><br><span class="line">                //设置header个数的限制</span><br><span class="line">                request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</span><br><span class="line">                // 循环解析所有的header name和value对，并添加到MimeHeaders的headers数组中</span><br><span class="line">                if (!inputBuffer.parseHeaders()) &#123;</span><br><span class="line">                    // We&apos;ve read part of the request, don&apos;t recycle it</span><br><span class="line">                    // instead associate it with the socket</span><br><span class="line">                    openSocket = true;</span><br><span class="line">                    readComplete = false;</span><br><span class="line">                    //读取失败</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!disableUploadTimeout) &#123;</span><br><span class="line">                    //设置upload超时时间</span><br><span class="line">                    socketWrapper.setReadTimeout(connectionUploadTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(&quot;http11processor.header.parse&quot;), e);</span><br><span class="line">            &#125;</span><br><span class="line">            setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">            break;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            UserDataHelper.Mode logMode = userDataHelper.getNextMode();</span><br><span class="line">            if (logMode != null) &#123;</span><br><span class="line">                String message = sm.getString(&quot;http11processor.header.parse&quot;);</span><br><span class="line">                switch (logMode) &#123;</span><br><span class="line">                    case INFO_THEN_DEBUG:</span><br><span class="line">                        message += sm.getString(&quot;http11processor.fallToDebug&quot;);</span><br><span class="line">                        //$FALL-THROUGH$</span><br><span class="line">                    case INFO:</span><br><span class="line">                        log.info(message, t);</span><br><span class="line">                        break;</span><br><span class="line">                    case DEBUG:</span><br><span class="line">                        log.debug(message, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 400 - Bad Request</span><br><span class="line">            response.setStatus(400);</span><br><span class="line">            setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">            getAdapter().log(request, response, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Has an upgrade been requested?</span><br><span class="line">        // 获取header中的Connection，若存在Connection的值为upgrade，则认为http2.0</span><br><span class="line">        Enumeration&lt;String&gt; connectionValues = request.getMimeHeaders().values(&quot;Connection&quot;);</span><br><span class="line">        boolean foundUpgrade = false;</span><br><span class="line">        while (connectionValues.hasMoreElements() &amp;&amp; !foundUpgrade) &#123;</span><br><span class="line">            foundUpgrade = connectionValues.nextElement().toLowerCase(</span><br><span class="line">                    Locale.ENGLISH).contains(&quot;upgrade&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (foundUpgrade) &#123;</span><br><span class="line">            // Check the protocol</span><br><span class="line">            String requestedProtocol = request.getHeader(&quot;Upgrade&quot;);</span><br><span class="line"></span><br><span class="line">            UpgradeProtocol upgradeProtocol = httpUpgradeProtocols.get(requestedProtocol);</span><br><span class="line">            if (upgradeProtocol != null) &#123;</span><br><span class="line">                if (upgradeProtocol.accept(request)) &#123;</span><br><span class="line">                    // TODO Figure out how to handle request bodies at this</span><br><span class="line">                    // point.</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_SWITCHING_PROTOCOLS);</span><br><span class="line">                    response.setHeader(&quot;Connection&quot;, &quot;Upgrade&quot;);</span><br><span class="line">                    response.setHeader(&quot;Upgrade&quot;, requestedProtocol);</span><br><span class="line">                    action(ActionCode.CLOSE,  null);</span><br><span class="line">                    getAdapter().log(request, response, 0);</span><br><span class="line"></span><br><span class="line">                    InternalHttpUpgradeHandler upgradeHandler =</span><br><span class="line">                            upgradeProtocol.getInternalUpgradeHandler(</span><br><span class="line">                                    getAdapter(), cloneRequest(request));</span><br><span class="line">                    UpgradeToken upgradeToken = new UpgradeToken(upgradeHandler, null, null);</span><br><span class="line">                    action(ActionCode.UPGRADE, upgradeToken);</span><br><span class="line">                    return SocketState.UPGRADING;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!getErrorState().isError()) &#123;</span><br><span class="line">            // Setting up filters, and parse some request headers</span><br><span class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</span><br><span class="line">            try &#123;</span><br><span class="line">                //预处理请求</span><br><span class="line">                prepareRequest();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(&quot;http11processor.request.prepare&quot;), t);</span><br><span class="line">                &#125;</span><br><span class="line">                // 500 - Internal Server Error</span><br><span class="line">                response.setStatus(500);</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                getAdapter().log(request, response, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //长连接数量限制</span><br><span class="line">        if (maxKeepAliveRequests == 1) &#123;</span><br><span class="line">            keepAlive = false;</span><br><span class="line">        &#125; else if (maxKeepAliveRequests &gt; 0 &amp;&amp;</span><br><span class="line">                socketWrapper.decrementKeepAlive() &lt;= 0) &#123;</span><br><span class="line">            keepAlive = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Process the request in the adapter</span><br><span class="line">        if (!getErrorState().isError()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                //获取CoyoteAdapter处理请求</span><br><span class="line">                getAdapter().service(request, response);</span><br><span class="line">                // Handle when the response was committed before a serious</span><br><span class="line">                // error occurred.  Throwing a ServletException should both</span><br><span class="line">                // set the status to 500 and set the errorException.</span><br><span class="line">                // If we fail here, then the response is likely already</span><br><span class="line">                // committed, so we can&apos;t try and set headers.</span><br><span class="line">                if(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">                        statusDropsConnection(response.getStatus())) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedIOException e) &#123;</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">            &#125; catch (HeadersTooLargeException e) &#123;</span><br><span class="line">                log.error(sm.getString(&quot;http11processor.request.process&quot;), e);</span><br><span class="line">                // The response should not have been committed but check it</span><br><span class="line">                // anyway to be safe</span><br><span class="line">                if (response.isCommitted()) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    response.reset();</span><br><span class="line">                    response.setStatus(500);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, e);</span><br><span class="line">                    response.setHeader(&quot;Connection&quot;, &quot;close&quot;); // TODO: Remove</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                log.error(sm.getString(&quot;http11processor.request.process&quot;), t);</span><br><span class="line">                // 500 - Internal Server Error</span><br><span class="line">                response.setStatus(500);</span><br><span class="line">                setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                getAdapter().log(request, response, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finish the handling of the request</span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);</span><br><span class="line">        //不是异步任务，请求处理结束</span><br><span class="line">        if (!isAsync()) &#123;</span><br><span class="line">            // If this is an async request then the request ends when it has</span><br><span class="line">            // been completed. The AsyncContext is responsible for calling</span><br><span class="line">            // endRequest() in that case.</span><br><span class="line">            endRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);</span><br><span class="line"></span><br><span class="line">        // If there was an error, make sure the request is counted as</span><br><span class="line">        // and error, and update the statistics counter</span><br><span class="line">        if (getErrorState().isError()) &#123;</span><br><span class="line">            response.setStatus(500);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 重置，处理下一个请求</span><br><span class="line">        if (!isAsync() || getErrorState().isError()) &#123;</span><br><span class="line">            request.updateCounters();</span><br><span class="line">            if (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">                inputBuffer.nextRequest();</span><br><span class="line">                outputBuffer.nextRequest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //设置Upload超时时间</span><br><span class="line">        if (!disableUploadTimeout) &#123;</span><br><span class="line">            int soTimeout = endpoint.getConnectionTimeout();</span><br><span class="line">            if(soTimeout &gt; 0) &#123;</span><br><span class="line">                socketWrapper.setReadTimeout(soTimeout);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                socketWrapper.setReadTimeout(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);</span><br><span class="line">        //tomcat默认设置是当数据大小达到48kb时，将启用文件传输</span><br><span class="line">        sendfileState = processSendfile(socketWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);</span><br><span class="line"></span><br><span class="line">    if (getErrorState().isError() || endpoint.isPaused()) &#123;</span><br><span class="line">        return SocketState.CLOSED;</span><br><span class="line">    &#125; else if (isAsync()) &#123;</span><br><span class="line">        return SocketState.LONG;</span><br><span class="line">    &#125; else if (isUpgrade()) &#123;</span><br><span class="line">        return SocketState.UPGRADING;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (sendfileState == SendfileState.PENDING) &#123;</span><br><span class="line">            return SocketState.SENDFILE;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (openSocket) &#123;</span><br><span class="line">                if (readComplete) &#123;</span><br><span class="line">                    return SocketState.OPEN;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return SocketState.LONG;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return SocketState.CLOSED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、CoyoteAdapter的service方法"><a href="#12、CoyoteAdapter的service方法" class="headerlink" title="12、CoyoteAdapter的service方法"></a>12、CoyoteAdapter的service方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">    // 创建request及response</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        // Create objects</span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        // Link objects</span><br><span class="line">        request.setResponse(response);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        // Set as notes</span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        // Set query string encoding</span><br><span class="line">        req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (connector.getXpoweredBy()) &#123;</span><br><span class="line">        response.addHeader(&quot;X-Powered-By&quot;, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean async = false;</span><br><span class="line">    boolean postParseSuccess = false;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // Parse and set Catalina and configuration specific</span><br><span class="line">        // request parameters</span><br><span class="line">        // 处理请求，解析请求url中的参数，由Mapper中查找请求对应的host、context、wrapper</span><br><span class="line">        // 获取Path或Cookies中的sessionID存入request中</span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        if (postParseSuccess) &#123;</span><br><span class="line">            //check valves if we support async</span><br><span class="line">            //设置是否支持异步任务</span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                    connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            // Calling the container</span><br><span class="line">            //获取Engine的管道的value链，默认只有StandardEngineValve，执行invoke方法</span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                    request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        if (request.isAsync()) &#123;</span><br><span class="line">            async = true;</span><br><span class="line">            ReadListener readListener = req.getReadListener();</span><br><span class="line">            if (readListener != null &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                // Possible the all data may have been read during service()</span><br><span class="line">                // method so this needs to be checked here</span><br><span class="line">                ClassLoader oldCL = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    oldCL = request.getContext().bind(false, null);</span><br><span class="line">                    if (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                        req.getReadListener().onAllDataRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    request.getContext().unbind(false, oldCL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Throwable throwable =</span><br><span class="line">                    (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">            // If an async request was started, is not going to end once</span><br><span class="line">            // this container thread finishes and an error occurred, trigger</span><br><span class="line">            // the async error process</span><br><span class="line">            if (!request.isAsyncCompleting() &amp;&amp; throwable != null) &#123;</span><br><span class="line">                request.getAsyncContextInternal().setErrorState(throwable, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //请求处理结束，发送返回</span><br><span class="line">            request.finishRequest();</span><br><span class="line">            response.finishResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // Ignore</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        AtomicBoolean error = new AtomicBoolean(false);</span><br><span class="line">        res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">        if (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">            // Connection will be forcibly closed which will prevent</span><br><span class="line">            // completion happening at the usual point. Need to trigger</span><br><span class="line">            // call to onComplete() here.</span><br><span class="line">            res.action(ActionCode.ASYNC_POST_PROCESS,  null);</span><br><span class="line">            async = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Access log</span><br><span class="line">        if (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">            // Log only if processing was invoked.</span><br><span class="line">            // If postParseRequest() failed, it has already logged it.</span><br><span class="line">            Context context = request.getContext();</span><br><span class="line">            // If the context is null, it is likely that the endpoint was</span><br><span class="line">            // shutdown, this connection closed and the request recycled in</span><br><span class="line">            // a different thread. That thread will have updated the access</span><br><span class="line">            // log so it is OK not to update the access log here in that</span><br><span class="line">            // case.</span><br><span class="line">            if (context != null) &#123;</span><br><span class="line">                context.logAccess(request, response,</span><br><span class="line">                        System.currentTimeMillis() - req.getStartTime(), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(null);</span><br><span class="line"></span><br><span class="line">        // Recycle the wrapper request and response</span><br><span class="line">        if (!async) &#123;</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、StandardEngineValve的invoke方法"><a href="#13、StandardEngineValve的invoke方法" class="headerlink" title="13、StandardEngineValve的invoke方法"></a>13、StandardEngineValve的invoke方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    // Select the Host to be used for this Request</span><br><span class="line">    Host host = request.getHost();</span><br><span class="line">    if (host == null) &#123;</span><br><span class="line">        response.sendError</span><br><span class="line">            (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">             sm.getString(&quot;standardEngine.noHost&quot;,</span><br><span class="line">                          request.getServerName()));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ask this Host to process this request</span><br><span class="line">    //获取Host的管道的value链，默认只有StandardHostValve，执行invoke方法 </span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、StandardHostValve的invoke方法"><a href="#14、StandardHostValve的invoke方法" class="headerlink" title="14、StandardHostValve的invoke方法"></a>14、StandardHostValve的invoke方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    // Select the Context to be used for this Request</span><br><span class="line">    Context context = request.getContext();</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,</span><br><span class="line">             sm.getString(&quot;standardHost.noContext&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(context.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean asyncAtStart = request.isAsync();</span><br><span class="line">    boolean asyncDispatching = request.isAsyncDispatching();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);</span><br><span class="line"></span><br><span class="line">        if (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) &#123;</span><br><span class="line">            // Don&apos;t fire listeners during async processing (the listener</span><br><span class="line">            // fired for the request that called startAsync()).</span><br><span class="line">            // If a request init listener throws an exception, the request</span><br><span class="line">            // is aborted.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Ask this Context to process this request. Requests that are in</span><br><span class="line">        // async mode and are not being dispatched to this resource must be</span><br><span class="line">        // in error and have been routed here to check for application</span><br><span class="line">        // defined error pages.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!asyncAtStart || asyncDispatching) &#123;</span><br><span class="line">                //获取Context的管道的value链，默认只有StandardContextValve，执行invoke方法 </span><br><span class="line">                context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Make sure this request/response is here because an error</span><br><span class="line">                // report is required.</span><br><span class="line">                if (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                    throw new IllegalStateException(sm.getString(&quot;standardHost.asyncStateError&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            container.getLogger().error(&quot;Exception Processing &quot; + request.getRequestURI(), t);</span><br><span class="line">            // If a new error occurred while trying to report a previous</span><br><span class="line">            // error allow the original error to be reported.</span><br><span class="line">            if (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">                throwable(request, response, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Now that the request/response pair is back under container</span><br><span class="line">        // control lift the suspension so that the error handling can</span><br><span class="line">        // complete and/or the container can flush any remaining data</span><br><span class="line">        response.setSuspended(false);</span><br><span class="line"></span><br><span class="line">        Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">        // Protect against NPEs if the context was destroyed during a</span><br><span class="line">        // long running request.</span><br><span class="line">        if (!context.getState().isAvailable()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Look for (and render if found) an application level error page</span><br><span class="line">        // 发送错误信息</span><br><span class="line">        if (response.isErrorReportRequired()) &#123;</span><br><span class="line">            if (t != null) &#123;</span><br><span class="line">                throwable(request, response, t);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                status(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 广播request销毁事件</span><br><span class="line">        if (!request.isAsync() &amp;&amp; !asyncAtStart) &#123;</span><br><span class="line">            context.fireRequestDestroyEvent(request.getRequest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // Access a session (if present) to update last accessed time, based</span><br><span class="line">        // on a strict interpretation of the specification</span><br><span class="line">        // 更新session的时间</span><br><span class="line">        if (ACCESS_SESSION) &#123;</span><br><span class="line">            request.getSession(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、StandardContextValve的invoke方法"><a href="#15、StandardContextValve的invoke方法" class="headerlink" title="15、StandardContextValve的invoke方法"></a>15、StandardContextValve的invoke方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void invoke(Request request, Response response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    // Disallow any direct access to resources under WEB-INF or META-INF</span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    // 不允许直接访问该目录的资源</span><br><span class="line">    if ((requestPathMB.startsWithIgnoreCase(&quot;/META-INF/&quot;, 0))</span><br><span class="line">            || (requestPathMB.equalsIgnoreCase(&quot;/META-INF&quot;))</span><br><span class="line">            || (requestPathMB.startsWithIgnoreCase(&quot;/WEB-INF/&quot;, 0))</span><br><span class="line">            || (requestPathMB.equalsIgnoreCase(&quot;/WEB-INF&quot;))) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Select the Wrapper to be used for this Request</span><br><span class="line">    // 检查是否找到wrapper</span><br><span class="line">    Wrapper wrapper = request.getWrapper();</span><br><span class="line">    if (wrapper == null || wrapper.isUnavailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Acknowledge the request</span><br><span class="line">    try &#123;</span><br><span class="line">        //确认已收到该请求</span><br><span class="line">        response.sendAcknowledgement();</span><br><span class="line">    &#125; catch (IOException ioe) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                &quot;standardContextValve.acknowledgeException&quot;), ioe);</span><br><span class="line">        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置是否支持异步任务</span><br><span class="line">    if (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line">    //获取Wrapper的管道的value链，默认只有StandardWrapperValve，执行invoke方法 </span><br><span class="line">    wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、StandardWrapperValve的invoke方法"><a href="#16、StandardWrapperValve的invoke方法" class="headerlink" title="16、StandardWrapperValve的invoke方法"></a>16、StandardWrapperValve的invoke方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final void invoke(Request request, Response response)</span><br><span class="line">     throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">     // Initialize local variables we may need</span><br><span class="line">     boolean unavailable = false;</span><br><span class="line">     Throwable throwable = null;</span><br><span class="line">     // This should be a Request attribute...</span><br><span class="line">     long t1=System.currentTimeMillis();</span><br><span class="line">     requestCount.incrementAndGet();</span><br><span class="line">     StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">     Servlet servlet = null;</span><br><span class="line">     Context context = (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">     // Check for the application being marked unavailable</span><br><span class="line">     if (!context.getState().isAvailable()) &#123;</span><br><span class="line">         response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(&quot;standardContext.isUnavailable&quot;));</span><br><span class="line">         unavailable = true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Check for the servlet being marked unavailable</span><br><span class="line">     if (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">         container.getLogger().info(sm.getString(&quot;standardWrapper.isUnavailable&quot;,</span><br><span class="line">                 wrapper.getName()));</span><br><span class="line">         long available = wrapper.getAvailable();</span><br><span class="line">         if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">             response.setDateHeader(&quot;Retry-After&quot;, available);</span><br><span class="line">             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                     sm.getString(&quot;standardWrapper.isUnavailable&quot;,</span><br><span class="line">                             wrapper.getName()));</span><br><span class="line">         &#125; else if (available == Long.MAX_VALUE) &#123;</span><br><span class="line">             response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                     sm.getString(&quot;standardWrapper.notFound&quot;,</span><br><span class="line">                             wrapper.getName()));</span><br><span class="line">         &#125;</span><br><span class="line">         unavailable = true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Allocate a servlet instance to process this request</span><br><span class="line">     try &#123;</span><br><span class="line">         if (!unavailable) &#123;</span><br><span class="line">             // 获取wrapper中的servlet</span><br><span class="line">             servlet = wrapper.allocate();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (UnavailableException e) &#123;</span><br><span class="line">         container.getLogger().error(</span><br><span class="line">                 sm.getString(&quot;standardWrapper.allocateException&quot;,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">         long available = wrapper.getAvailable();</span><br><span class="line">         if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">             response.setDateHeader(&quot;Retry-After&quot;, available);</span><br><span class="line">             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(&quot;standardWrapper.isUnavailable&quot;,</span><br><span class="line">                                     wrapper.getName()));</span><br><span class="line">         &#125; else if (available == Long.MAX_VALUE) &#123;</span><br><span class="line">             response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(&quot;standardWrapper.notFound&quot;,</span><br><span class="line">                                     wrapper.getName()));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (ServletException e) &#123;</span><br><span class="line">         container.getLogger().error(sm.getString(&quot;standardWrapper.allocateException&quot;,</span><br><span class="line">                          wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         ExceptionUtils.handleThrowable(e);</span><br><span class="line">         container.getLogger().error(sm.getString(&quot;standardWrapper.allocateException&quot;,</span><br><span class="line">                          wrapper.getName()), e);</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">         servlet = null;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">     DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">     if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">     //request对象设置请求类型和请求路径属性</span><br><span class="line">     request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">     request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);</span><br><span class="line"></span><br><span class="line">     // Create the filter chain for this request</span><br><span class="line">     // 创建过滤器链，添加匹配的过滤器、servlet</span><br><span class="line">     ApplicationFilterChain filterChain =</span><br><span class="line">             ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">     // Call the filter chain for this request</span><br><span class="line">     // NOTE: This also calls the servlet&apos;s service() method</span><br><span class="line">     try &#123;</span><br><span class="line">         if ((servlet != null) &amp;&amp; (filterChain != null)) &#123;</span><br><span class="line">             // Swallow output if needed</span><br><span class="line">             if (context.getSwallowOutput()) &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     SystemLogHandler.startCapture();</span><br><span class="line">                     //处理异步任务请求转发</span><br><span class="line">                     if (request.isAsyncDispatching()) &#123;</span><br><span class="line">                         request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         //执行过滤器及servlet的service方法</span><br><span class="line">                         filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                 response.getResponse());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; finally &#123;</span><br><span class="line">                     String log = SystemLogHandler.stopCapture();</span><br><span class="line">                     if (log != null &amp;&amp; log.length() &gt; 0) &#123;</span><br><span class="line">                         context.getLogger().info(log);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 if (request.isAsyncDispatching()) &#123;</span><br><span class="line">                     request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     filterChain.doFilter</span><br><span class="line">                         (request.getRequest(), response.getResponse());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (ClientAbortException e) &#123;</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         container.getLogger().error(sm.getString(</span><br><span class="line">                 &quot;standardWrapper.serviceException&quot;, wrapper.getName(),</span><br><span class="line">                 context.getName()), e);</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">     &#125; catch (UnavailableException e) &#123;</span><br><span class="line">         container.getLogger().error(sm.getString(</span><br><span class="line">                 &quot;standardWrapper.serviceException&quot;, wrapper.getName(),</span><br><span class="line">                 context.getName()), e);</span><br><span class="line">         //            throwable = e;</span><br><span class="line">         //            exception(request, response, e);</span><br><span class="line">         wrapper.unavailable(e);</span><br><span class="line">         long available = wrapper.getAvailable();</span><br><span class="line">         if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">             response.setDateHeader(&quot;Retry-After&quot;, available);</span><br><span class="line">             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(&quot;standardWrapper.isUnavailable&quot;,</span><br><span class="line">                                     wrapper.getName()));</span><br><span class="line">         &#125; else if (available == Long.MAX_VALUE) &#123;</span><br><span class="line">             response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                         sm.getString(&quot;standardWrapper.notFound&quot;,</span><br><span class="line">                                     wrapper.getName()));</span><br><span class="line">         &#125;</span><br><span class="line">         // Do not save exception in &apos;throwable&apos;, because we</span><br><span class="line">         // do not want to do exception(request, response, e) processing</span><br><span class="line">     &#125; catch (ServletException e) &#123;</span><br><span class="line">         Throwable rootCause = StandardWrapper.getRootCause(e);</span><br><span class="line">         if (!(rootCause instanceof ClientAbortException)) &#123;</span><br><span class="line">             container.getLogger().error(sm.getString(</span><br><span class="line">                     &quot;standardWrapper.serviceExceptionRoot&quot;,</span><br><span class="line">                     wrapper.getName(), context.getName(), e.getMessage()),</span><br><span class="line">                     rootCause);</span><br><span class="line">         &#125;</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         ExceptionUtils.handleThrowable(e);</span><br><span class="line">         container.getLogger().error(sm.getString(</span><br><span class="line">                 &quot;standardWrapper.serviceException&quot;, wrapper.getName(),</span><br><span class="line">                 context.getName()), e);</span><br><span class="line">         throwable = e;</span><br><span class="line">         exception(request, response, e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Release the filter chain (if any) for this request</span><br><span class="line">     // 清空对Servlet、Filter的引用</span><br><span class="line">     if (filterChain != null) &#123;</span><br><span class="line">         filterChain.release();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Deallocate the allocated servlet instance</span><br><span class="line">     try &#123;</span><br><span class="line">         // servlet加入instancePool</span><br><span class="line">         if (servlet != null) &#123;</span><br><span class="line">             wrapper.deallocate(servlet);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         ExceptionUtils.handleThrowable(e);</span><br><span class="line">         container.getLogger().error(sm.getString(&quot;standardWrapper.deallocateException&quot;,</span><br><span class="line">                          wrapper.getName()), e);</span><br><span class="line">         if (throwable == null) &#123;</span><br><span class="line">             throwable = e;</span><br><span class="line">             exception(request, response, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // If this servlet has been marked permanently unavailable,</span><br><span class="line">     // unload it and release this instance</span><br><span class="line">     try &#123;</span><br><span class="line">         if ((servlet != null) &amp;&amp;</span><br><span class="line">             (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">             wrapper.unload();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         ExceptionUtils.handleThrowable(e);</span><br><span class="line">         container.getLogger().error(sm.getString(&quot;standardWrapper.unloadException&quot;,</span><br><span class="line">                          wrapper.getName()), e);</span><br><span class="line">         if (throwable == null) &#123;</span><br><span class="line">             throwable = e;</span><br><span class="line">             exception(request, response, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     long t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">     long time=t2-t1;</span><br><span class="line">     processingTime += time;</span><br><span class="line">     if( time &gt; maxTime) maxTime=time;</span><br><span class="line">     if( time &lt; minTime) minTime=time;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、ApplicationFilterChain的internalDoFilter方法"><a href="#17、ApplicationFilterChain的internalDoFilter方法" class="headerlink" title="17、ApplicationFilterChain的internalDoFilter方法"></a>17、ApplicationFilterChain的internalDoFilter方法</h4><p>ApplicationFilterChain的doFilter方法，实际调用了internalDoFilter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private void internalDoFilter(ServletRequest request,</span><br><span class="line">                              ServletResponse response)</span><br><span class="line">    throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    // Call the next filter if there is one</span><br><span class="line">    // 依次执行filter的doFilter方法</span><br><span class="line">    if (pos &lt; n) &#123;</span><br><span class="line">        ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">        try &#123;</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">            if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase(</span><br><span class="line">                    filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">            if( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                final ServletRequest req = request;</span><br><span class="line">                final ServletResponse res = response;</span><br><span class="line">                Principal principal =</span><br><span class="line">                    ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">                Object[] args = new Object[]&#123;req, res, this&#125;;</span><br><span class="line">                SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                filter.doFilter(request, response, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We fell off the end of the chain -- call the servlet instance</span><br><span class="line">    try &#123;</span><br><span class="line">        //设置最近处理请求</span><br><span class="line">        if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest.set(request);</span><br><span class="line">            lastServicedResponse.set(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                    Boolean.FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        // Use potentially wrapped request from this point</span><br><span class="line">        if ((request instanceof HttpServletRequest) &amp;&amp;</span><br><span class="line">                (response instanceof HttpServletResponse) &amp;&amp;</span><br><span class="line">                Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            final ServletRequest req = request;</span><br><span class="line">            final ServletResponse res = response;</span><br><span class="line">            Principal principal =</span><br><span class="line">                ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">            Object[] args = new Object[]&#123;req, res&#125;;</span><br><span class="line">            //执行servlet的service方法</span><br><span class="line">            SecurityUtil.doAsPrivilege(&quot;service&quot;,</span><br><span class="line">                                       servlet,</span><br><span class="line">                                       classTypeUsedInService,</span><br><span class="line">                                       args,</span><br><span class="line">                                       principal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //执行servlet的service方法</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        throw new ServletException(sm.getString(&quot;filterChain.servlet&quot;), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //清空最近处理请求</span><br><span class="line">        if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest.set(null);</span><br><span class="line">            lastServicedResponse.set(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、session创建"><a href="#二、session创建" class="headerlink" title="二、session创建"></a>二、session创建</h3><h4 id="1、Request的getSession方法"><a href="#1、Request的getSession方法" class="headerlink" title="1、Request的getSession方法"></a>1、Request的getSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public HttpSession getSession(boolean create) &#123;</span><br><span class="line">    //获取session，参数为不存在时是否创建</span><br><span class="line">    Session session = doGetSession(create);</span><br><span class="line">    if (session == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return session.getSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、Request的doGetSession方法"><a href="#2、Request的doGetSession方法" class="headerlink" title="2、Request的doGetSession方法"></a>2、Request的doGetSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">protected Session doGetSession(boolean create) &#123;</span><br><span class="line"></span><br><span class="line">    // There cannot be a session if no context has been assigned yet</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">        return (null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return the current session if it exists and is valid</span><br><span class="line">    //判断当前Request对象是否已经存在有效的Session，如果存在则返回此Session</span><br><span class="line">    if ((session != null) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">        session = null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (session != null) &#123;</span><br><span class="line">        return (session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return the requested session if it exists and is valid</span><br><span class="line">    // 获取Session管理器，默认StandardManager</span><br><span class="line">    Manager manager = context.getManager();</span><br><span class="line">    if (manager == null) &#123;</span><br><span class="line">        return (null);      // Sessions are not supported</span><br><span class="line">    &#125;</span><br><span class="line">    // 从StandardManager的Session缓存中获取Session，如果有则返回此Session</span><br><span class="line">    if (requestedSessionId != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            session = manager.findSession(requestedSessionId);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            session = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((session != null) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">            session = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (session != null) &#123;</span><br><span class="line">            // 更新Session的访问时间以及访问次数</span><br><span class="line">            session.access();</span><br><span class="line">            return (session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create a new session if requested and the response is not committed</span><br><span class="line">    // 是否创建session</span><br><span class="line">    if (!create) &#123;</span><br><span class="line">        return (null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请求处理结束，输出流已关闭</span><br><span class="line">    if (response != null</span><br><span class="line">            &amp;&amp; context.getServletContext()</span><br><span class="line">                    .getEffectiveSessionTrackingModes()</span><br><span class="line">                    .contains(SessionTrackingMode.COOKIE)</span><br><span class="line">            &amp;&amp; response.getResponse().isCommitted()) &#123;</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;coyoteRequest.sessionCreateCommitted&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Re-use session IDs provided by the client in very limited</span><br><span class="line">    // circumstances.</span><br><span class="line">    // 获取sessionid</span><br><span class="line">    String sessionId = getRequestedSessionId();</span><br><span class="line">    if (requestedSessionSSL) &#123;</span><br><span class="line">        // If the session ID has been obtained from the SSL handshake then</span><br><span class="line">        // use it.</span><br><span class="line">    &#125; else if ((&quot;/&quot;.equals(context.getSessionCookiePath())</span><br><span class="line">            &amp;&amp; isRequestedSessionIdFromCookie())) &#123;</span><br><span class="line">        /* This is the common(ish) use case: using the same session ID with</span><br><span class="line">         * multiple web applications on the same host. Typically this is</span><br><span class="line">         * used by Portlet implementations. It only works if sessions are</span><br><span class="line">         * tracked via cookies. The cookie must have a path of &quot;/&quot; else it</span><br><span class="line">         * won&apos;t be provided for requests to all web applications.</span><br><span class="line">         *</span><br><span class="line">         * Any session ID provided by the client should be for a session</span><br><span class="line">         * that already exists somewhere on the host. Check if the context</span><br><span class="line">         * is configured for this to be confirmed.</span><br><span class="line">         */</span><br><span class="line">        if (context.getValidateClientProvidedNewSessionId()) &#123;</span><br><span class="line">            boolean found = false;</span><br><span class="line">            for (Container container : getHost().findChildren()) &#123;</span><br><span class="line">                Manager m = ((Context) container).getManager();</span><br><span class="line">                if (m != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (m.findSession(sessionId) != null) &#123;</span><br><span class="line">                            found = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        // Ignore. Problems with this manager will be</span><br><span class="line">                        // handled elsewhere.</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!found) &#123;</span><br><span class="line">                sessionId = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sessionId = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建Session</span><br><span class="line">    session = manager.createSession(sessionId);</span><br><span class="line"></span><br><span class="line">    // Creating a new session cookie based on that session</span><br><span class="line">    // 创建保存Session ID的Cookie</span><br><span class="line">    if (session != null</span><br><span class="line">            &amp;&amp; context.getServletContext()</span><br><span class="line">                    .getEffectiveSessionTrackingModes()</span><br><span class="line">                    .contains(SessionTrackingMode.COOKIE)) &#123;</span><br><span class="line">        Cookie cookie =</span><br><span class="line">            ApplicationSessionCookieConfig.createSessionCookie(</span><br><span class="line">                    context, session.getIdInternal(), isSecure());</span><br><span class="line">        response.addSessionCookieInternal(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (session == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //更新Session的访问时间以及访问次数</span><br><span class="line">    session.access();</span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ManagerBase的createSession方法"><a href="#3、ManagerBase的createSession方法" class="headerlink" title="3、ManagerBase的createSession方法"></a>3、ManagerBase的createSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Session createSession(String sessionId) &#123;</span><br><span class="line"></span><br><span class="line">    if ((maxActiveSessions &gt;= 0) &amp;&amp;</span><br><span class="line">            (getActiveSessions() &gt;= maxActiveSessions)) &#123;</span><br><span class="line">        rejectedSessions++;</span><br><span class="line">        throw new TooManyActiveSessionsException(</span><br><span class="line">                sm.getString(&quot;managerBase.createSession.ise&quot;),</span><br><span class="line">                maxActiveSessions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Recycle or create a Session instance</span><br><span class="line">    //创建session，默认StandardSession</span><br><span class="line">    Session session = createEmptySession();</span><br><span class="line"></span><br><span class="line">    // Initialize the properties of the new session and return it</span><br><span class="line">    // 新session</span><br><span class="line">    session.setNew(true);</span><br><span class="line">    // 有效</span><br><span class="line">    session.setValid(true);</span><br><span class="line">    // 创建时间</span><br><span class="line">    session.setCreationTime(System.currentTimeMillis());</span><br><span class="line">    // 超时时间</span><br><span class="line">    session.setMaxInactiveInterval(getContext().getSessionTimeout() * 60);</span><br><span class="line">    // 创建sessionId</span><br><span class="line">    String id = sessionId;</span><br><span class="line">    if (id == null) &#123;</span><br><span class="line">        id = generateSessionId();</span><br><span class="line">    &#125;</span><br><span class="line">    session.setId(id);</span><br><span class="line">    //创建session个数</span><br><span class="line">    sessionCounter++;</span><br><span class="line"></span><br><span class="line">    SessionTiming timing = new SessionTiming(session.getCreationTime(), 0);</span><br><span class="line">    synchronized (sessionCreationTiming) &#123;</span><br><span class="line">        sessionCreationTiming.add(timing);</span><br><span class="line">        sessionCreationTiming.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    return (session);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、异步任务"><a href="#三、异步任务" class="headerlink" title="三、异步任务"></a>三、异步任务</h3><h4 id="1、AsyncContextImpl的complete方法"><a href="#1、AsyncContextImpl的complete方法" class="headerlink" title="1、AsyncContextImpl的complete方法"></a>1、AsyncContextImpl的complete方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void complete() &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        logDebug(&quot;complete   &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    check();</span><br><span class="line">    //更改任务状态</span><br><span class="line">    request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCHED：普通servlet结束的状态</span><br><span class="line">STARTING：servlet开始异步时的状态</span><br><span class="line">STARTED：当前servlet已经开始异步，释放容器线程之前异步servlet并未结束的状态</span><br><span class="line">MUST_COMPLETE：释放容器线程之前，异步servlet已经结束的状态（complete函数）</span><br><span class="line">COMPLETING：异步servlet并未dispatch到其他servlet上，然后异步结束的状态</span><br><span class="line">TIMING_OUT：当前异步servlet已经超时的状态</span><br><span class="line">MUST_DISPATCH：释放容器线程之前，异步servlet dispatch到其他servlet上的状态</span><br><span class="line">DISPATCHING：异步servlet结束，dispatch到其他servlet上的状态</span><br><span class="line">ERROR：异步servlet异常的状态</span><br></pre></td></tr></table></figure></p>
<h4 id="2、Request的action方法"><a href="#2、Request的action方法" class="headerlink" title="2、Request的action方法"></a>2、Request的action方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void action(ActionCode actionCode, Object param) &#123;</span><br><span class="line">    if (hook != null) &#123;</span><br><span class="line">        if (param == null) &#123;</span><br><span class="line">            hook.action(actionCode, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hook.action(actionCode, param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、AbstractProcessor的action方法"><a href="#3、AbstractProcessor的action方法" class="headerlink" title="3、AbstractProcessor的action方法"></a>3、AbstractProcessor的action方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void action(ActionCode actionCode, Object param) &#123;</span><br><span class="line">    switch (actionCode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    case ASYNC_COMPLETE: &#123;</span><br><span class="line">        //清空dispatches</span><br><span class="line">        clearDispatches();</span><br><span class="line">        //更改请求状态</span><br><span class="line">        if (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">            //再次调用processSocket</span><br><span class="line">            processSocketEvent(SocketEvent.OPEN_READ, true);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case ASYNC_DISPATCH: &#123;</span><br><span class="line">        //更改请求状态</span><br><span class="line">        if (asyncStateMachine.asyncDispatch()) &#123;</span><br><span class="line">            //再次调用processSocket</span><br><span class="line">            processSocketEvent(SocketEvent.OPEN_READ, true);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case ASYNC_DISPATCHED: &#123;</span><br><span class="line">        //更改请求状态</span><br><span class="line">        asyncStateMachine.asyncDispatched();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2019 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>