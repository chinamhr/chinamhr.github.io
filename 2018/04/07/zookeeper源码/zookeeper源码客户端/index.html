<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>zookeeper源码客户端 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="zookeeper源码客户端客户端Demo1234567891011121314151617181920ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &amp;#123;           @Override           public void process(WatchedEvent even">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper源码客户端">
<meta property="og:url" content="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码客户端/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="zookeeper源码客户端客户端Demo1234567891011121314151617181920ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &amp;#123;           @Override           public void process(WatchedEvent even">
<meta property="og:updated_time" content="2018-04-06T17:27:17.360Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zookeeper源码客户端">
<meta name="twitter:description" content="zookeeper源码客户端客户端Demo1234567891011121314151617181920ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &amp;#123;           @Override           public void process(WatchedEvent even">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-zookeeper源码/zookeeper源码客户端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/zookeeper源码/zookeeper源码客户端/" class="article-date">
  <time datetime="2018-04-07T04:44:43.474Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/zookeeper/">zookeeper</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      zookeeper源码客户端
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper源码客户端"><a href="#zookeeper源码客户端" class="headerlink" title="zookeeper源码客户端"></a>zookeeper源码客户端</h2><h3 id="客户端Demo"><a href="#客户端Demo" class="headerlink" title="客户端Demo"></a>客户端Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">//参数1 路径，参数2 内容，参数3 权限，参数4 类型</span><br><span class="line">String znodePath = zk.create(&quot;/demo&quot;, &quot;hello zookeeper&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">   	CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">//判断/java节点是否存在，并且给它注册一个监听器，这个监听器只能监听一次，监听到一次事件后就会失效  </span><br><span class="line">   zk.exists(&quot;/demo&quot;, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="一、建立连接过程"><a href="#一、建立连接过程" class="headerlink" title="一、建立连接过程"></a>一、建立连接过程</h3><h4 id="1、实例化ZooKeeper"><a href="#1、实例化ZooKeeper" class="headerlink" title="1、实例化ZooKeeper"></a>1、实例化ZooKeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   // connectString 连接字符串 如&quot;192.168.12.1:2181,192.168.12.2:2181,192.168.12.3:2181/root&quot;  </span><br><span class="line">   // sessionTimeout 客户端提议的session有效时间</span><br><span class="line">public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,</span><br><span class="line">           boolean canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">           ZKClientConfig clientConfig) throws IOException &#123;</span><br><span class="line">       LOG.info(&quot;Initiating client connection, connectString=&quot; + connectString</span><br><span class="line">               + &quot; sessionTimeout=&quot; + sessionTimeout + &quot; watcher=&quot; + watcher);</span><br><span class="line"></span><br><span class="line">       if (clientConfig == null) &#123;</span><br><span class="line">           clientConfig = new ZKClientConfig();</span><br><span class="line">       &#125;</span><br><span class="line">       this.clientConfig = clientConfig;</span><br><span class="line"></span><br><span class="line">       //创建Watcher监听器的管理器</span><br><span class="line">       watchManager = defaultWatchManager();</span><br><span class="line"></span><br><span class="line">       //设置默认的Watcher监听器</span><br><span class="line">       watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">       ConnectStringParser connectStringParser = new ConnectStringParser(</span><br><span class="line">               connectString);</span><br><span class="line"></span><br><span class="line">       hostProvider = aHostProvider;</span><br><span class="line"></span><br><span class="line">       //客户端负责与服务端通信的对象</span><br><span class="line">       cnxn = new ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">               hostProvider, sessionTimeout, this, watchManager,</span><br><span class="line">               getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">       cnxn.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、实例化ClientCnxn"><a href="#2、实例化ClientCnxn" class="headerlink" title="2、实例化ClientCnxn"></a>2、实例化ClientCnxn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">       this.zooKeeper = zooKeeper;</span><br><span class="line">       this.watcher = watcher;</span><br><span class="line">       this.sessionId = sessionId; //初始值为0</span><br><span class="line">       this.sessionPasswd = sessionPasswd; //初始值为 new byte[16]</span><br><span class="line">       this.sessionTimeout = sessionTimeout;</span><br><span class="line">       this.hostProvider = hostProvider;</span><br><span class="line">       this.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.size();//hostProvider.size() 服务端地址个数</span><br><span class="line">       readTimeout = sessionTimeout * 2 / 3;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">	//发送和接收socket数据的线程</span><br><span class="line">       sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line"></span><br><span class="line">       //事件线程</span><br><span class="line">       eventThread = new EventThread();</span><br><span class="line"></span><br><span class="line">       this.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、SendThread的run方法"><a href="#3、SendThread的run方法" class="headerlink" title="3、SendThread的run方法"></a>3、SendThread的run方法</h4><p>ClientCnxn 的start方法 会分别启动SendThread、EventThread、SendThread的run方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    //更新最近接受和发送时间</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    int to;</span><br><span class="line">    long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">    InetSocketAddress serverAddress = null;</span><br><span class="line">    while (state.isAlive()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//判断是否完成连接</span><br><span class="line">            if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                判断是否关闭</span><br><span class="line">                if (closing) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //若之前连接过只读服务器，直接用上次查找出的读写服务器地址连接</span><br><span class="line">                if (rwServerAddress != null) &#123;</span><br><span class="line">                    serverAddress = rwServerAddress;</span><br><span class="line">                    rwServerAddress = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//获取下一个服务端地址 延迟1s返回</span><br><span class="line">                    serverAddress = hostProvider.next(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                //连接服务端</span><br><span class="line">                startConnect(serverAddress);</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            判断是否已连接</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                // determine whether we need to send an AuthFailed event.</span><br><span class="line">                if (zooKeeperSaslClient != null) &#123;</span><br><span class="line">                	...</span><br><span class="line">                    //进行sasl权限验证</span><br><span class="line">                &#125;</span><br><span class="line">                //超时剩余时间</span><br><span class="line">                to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	//超时剩余时间</span><br><span class="line">                to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //to &lt;= 0 则说明连接超时</span><br><span class="line">            if (to &lt;= 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //打印日志抛出异常</span><br><span class="line">                throw new SessionTimeoutException(warnInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果已连接  定时发送心跳检测</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - </span><br><span class="line">                		((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);</span><br><span class="line">                if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                    //发送ping数据</span><br><span class="line">                    sendPing();</span><br><span class="line">                    clientCnxnSocket.updateLastSend();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (timeToNextPing &lt; to) &#123;</span><br><span class="line">                        to = timeToNextPing;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果连接的是只读服务器</span><br><span class="line">            if (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                long now = Time.currentElapsedTime();</span><br><span class="line">                int idlePingRwServer = (int) (now - lastPingRwServer);</span><br><span class="line">                if (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                    lastPingRwServer = now;</span><br><span class="line">                    idlePingRwServer = 0;</span><br><span class="line">                    pingRwTimeout =</span><br><span class="line">                        Math.min(2*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                    //寻找读写服务器，抛出异常，重新连接</span><br><span class="line">                    pingRwServer();</span><br><span class="line">                &#125;</span><br><span class="line">                to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理与客户端的通信</span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (closing) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //跳出主循环，结束线程</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (state) &#123;</span><br><span class="line">        断开连接，处理队列中的数据包</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    关闭socket</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    if (state.isAlive()) &#123;</span><br><span class="line">    	//添加断开连接事件</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(Event.EventType.None,</span><br><span class="line">                Event.KeeperState.Disconnected, null));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4、startConnect方法连接服务端"><a href="#4、startConnect方法连接服务端" class="headerlink" title="4、startConnect方法连接服务端"></a>4、startConnect方法连接服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    private void startConnect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        客户端状态更新为正在连接</span><br><span class="line">        state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">        //连接服务端</span><br><span class="line">        clientCnxnSocket.connect(addr);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">#### 5、ClientCnxnSocketNIO中的connect方法</span><br></pre></td></tr></table></figure>
<pre><code>@Override
void connect(InetSocketAddress addr) throws IOException {
    SocketChannel sock = createSock();
    try {
       registerAndConnect(sock, addr);
  } catch (IOException e) {
        sock.close();
        throw e;
    }
    //未初始化
    initialized = false;
    //清空缓存区
    lenBuffer.clear();
    incomingBuffer = lenBuffer;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 6、调用了registerAndConnect方法</span><br></pre></td></tr></table></figure>
<pre><code>void registerAndConnect(SocketChannel sock, InetSocketAddress addr) 
throws IOException {
    //向selector注册SocketChannel指定OP_CONNECT事件
    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);
    //连接服务器
    boolean immediateConnect = sock.connect(addr);
    if (immediateConnect) {
        sendThread.primeConnection();
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 7、SendThread的primeConnection方法</span><br></pre></td></tr></table></figure>
<pre><code>void primeConnection() throws IOException {
    isFirstConnect = false;
    若之前连接过只读服务器，则使用之前的sessionId
    long sessId = (seenRwServerBefore) ? sessionId : 0;
    创建连接请求对象
    ConnectRequest conReq = new ConnectRequest(0, lastZxid,
            sessionTimeout, sessId, sessionPasswd);

    //重新连接将已有的监听器注册到服务器
    if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {
        //类是否存在监听器
        List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();
        //数据变化监听器
        List&lt;String&gt; existWatches = zooKeeper.getExistWatches();
        //子节点变化监听器
        List&lt;String&gt; childWatches = zooKeeper.getChildWatches();
        if (!dataWatches.isEmpty()
                || !existWatches.isEmpty() || !childWatches.isEmpty()) {
            Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();
            Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();
            Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();
            long setWatchesLastZxid = lastZxid;

            while (dataWatchesIter.hasNext()
                   || existWatchesIter.hasNext() || childWatchesIter.hasNext()) {
                List&lt;String&gt; dataWatchesBatch = new ArrayList&lt;String&gt;();
                List&lt;String&gt; existWatchesBatch = new ArrayList&lt;String&gt;();
                List&lt;String&gt; childWatchesBatch = new ArrayList&lt;String&gt;();
                int batchLength = 0;

                while (batchLength &lt; SET_WATCHES_MAX_LENGTH) {
                    final String watch;
                    if (dataWatchesIter.hasNext()) {
                        watch = dataWatchesIter.next();
                        dataWatchesBatch.add(watch);
                    } else if (existWatchesIter.hasNext()) {
                        watch = existWatchesIter.next();
                        existWatchesBatch.add(watch);
                    } else if (childWatchesIter.hasNext()) {
                        watch = childWatchesIter.next();
                        childWatchesBatch.add(watch);
                    } else {
                        break;
                    }
                    batchLength += watch.length();
                }

                SetWatches sw = new SetWatches(setWatchesLastZxid,
                                               dataWatchesBatch,
                                               existWatchesBatch,
                                               childWatchesBatch);
                RequestHeader header = new RequestHeader(-8, OpCode.setWatches);
                Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);
                outgoingQueue.addFirst(packet);
            }
        }
    }

    ...

    //新建一个数据包，加入发送队列
    outgoingQueue.addFirst(new Packet(null, null, conReq,
            null, null, readOnly));
    //该方法修改SocketChannel指定事件为读和写
    clientCnxnSocket.connectionPrimed();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 8、ClientCnxnSocketNIO的doTransport方法</span><br><span class="line">读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中</span><br></pre></td></tr></table></figure>
<pre><code>@Override
void doTransport(int waitTimeOut, List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)
        throws IOException, InterruptedException {
    selector.select(waitTimeOut);
    Set&lt;SelectionKey&gt; selected;
    synchronized (this) {
        selected = selector.selectedKeys();
    }
    updateNow();
    for (SelectionKey k : selected) {
        SocketChannel sc = ((SocketChannel) k.channel());
        //连接事件未就绪
        if ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != 0) {
            if (sc.finishConnect()) {
                updateLastSendAndHeard();
                更新服务端地址
                updateSocketAddresses();
                连接服务端
                sendThread.primeConnection();
            }
         //读写事件就绪
        } else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {
            处理通信数据
            doIO(pendingQueue, cnxn);
        }
    }
    if (sendThread.getZkState().isConnected()) {
        //找出可以在sasl认证之前可以预先发送的请求
        if (findSendablePacket(outgoingQueue,
                sendThread.tunnelAuthInProgress()) != null) {
            enableWrite();
        }
    }
    selected.clear();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 9、ClientCnxnSocketNIO的doIO方法</span><br></pre></td></tr></table></figure>
<pre><code>void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)
  throws InterruptedException, IOException {
    SocketChannel sock = (SocketChannel) sockKey.channel();
    if (sock == null) {
        throw new IOException(&quot;Socket is null!&quot;);
    }
    //就绪事件为读事件
    if (sockKey.isReadable()) {
        int rc = sock.read(incomingBuffer);
        if (rc &lt; 0) {
            throw new EndOfStreamException(
                    &quot;Unable to read additional data from server sessionid 0x&quot;
                            + Long.toHexString(sessionId)
                            + &quot;, likely server has closed socket&quot;);
        }
        //incomingBuffer是否还有空间
        if (!incomingBuffer.hasRemaining()) {
            incomingBuffer.flip();
            //如果incomingBuffer和lenBuffer指向同一个byteBuffer，说明是新请求的第一次读 
            if (incomingBuffer == lenBuffer) {
                请求次数增加
                recvCount++;
                //incomingBuffer缓存区初始化
                readLength();
            } else if (!initialized) {
                //读取服务端的连接请求返回
                readConnectResult();
                enableRead();
                if (findSendablePacket(outgoingQueue,
                        sendThread.tunnelAuthInProgress()) != null) {
                    enableWrite();
                }
                lenBuffer.clear();
                incomingBuffer = lenBuffer;
                updateLastHeard();
                initialized = true;
            } else {
                //读取服务端的其他请求返回
                sendThread.readResponse(incomingBuffer);
                lenBuffer.clear();
                incomingBuffer = lenBuffer;
                updateLastHeard();
            }
        }
    }
    if (sockKey.isWritable()) {
        //查找可发送的数据包
        Packet p = findSendablePacket(outgoingQueue,
                sendThread.tunnelAuthInProgress());

        if (p != null) {
            updateLastSend();
            // If we already started writing p, p.bb will already exist
            if (p.bb == null) {
                if ((p.requestHeader != null) &amp;&amp;
                        (p.requestHeader.getType() != OpCode.ping) &amp;&amp;
                        (p.requestHeader.getType() != OpCode.auth)) {
                    p.requestHeader.setXid(cnxn.getXid());
                }
                p.createBB();
            }
            //发送数据
            sock.write(p.bb);
            if (!p.bb.hasRemaining()) {
                sentCount++;
                outgoingQueue.removeFirstOccurrence(p);
                if (p.requestHeader != null
                        &amp;&amp; p.requestHeader.getType() != OpCode.ping
                        &amp;&amp; p.requestHeader.getType() != OpCode.auth) {
                    synchronized (pendingQueue) {
                        //把包裹加入到等待服务端返回队列
                        pendingQueue.add(p);
                    }
                }
            }
        }
        if (outgoingQueue.isEmpty()) {
            发送队列为空，取消对OP_WRITE事件的指定
            disableWrite();
        } else if (!initialized &amp;&amp; p != null &amp;&amp; !p.bb.hasRemaining()) {
            连接请求发送完成，取消对OP_WRITE事件的指定
            disableWrite();
        } else {
            // Just in case
            enableWrite();
        }
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 10、ClientCnxnSocketNIO的readConnectResult方法</span><br></pre></td></tr></table></figure>
<pre><code>void readConnectResult() throws IOException {
    if (LOG.isTraceEnabled()) {
        StringBuilder buf = new StringBuilder(&quot;0x[&quot;);
        for (byte b : incomingBuffer.array()) {
            buf.append(Integer.toHexString(b) + &quot;,&quot;);
        }
        buf.append(&quot;]&quot;);
        LOG.trace(&quot;readConnectResult &quot; + incomingBuffer.remaining() + &quot; &quot;
                + buf.toString());
    }
    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);
    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
    ConnectResponse conRsp = new ConnectResponse();
    反序列化连接请求返回
    conRsp.deserialize(bbia, &quot;connect&quot;);

    // read &quot;is read-only&quot; flag
    boolean isRO = false;
    try {
        isRO = bbia.readBool(&quot;readOnly&quot;);
    } catch (IOException e) {
        // this is ok -- just a packet from an old server which
        // doesn&apos;t contain readOnly field
        LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);
    }
    //获取服务端返回的sessionId
    this.sessionId = conRsp.getSessionId();
    //最终处理连接返回数据
    sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,
            conRsp.getPasswd(), isRO);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 11、sendThread的onConnected方法</span><br></pre></td></tr></table></figure>
<pre><code>void onConnected(int _negotiatedSessionTimeout, long _sessionId,
                byte[] _sessionPasswd, boolean isRO) throws IOException {
    negotiatedSessionTimeout = _negotiatedSessionTimeout;
    //session是否过期
    if (negotiatedSessionTimeout &lt;= 0) {
        state = States.CLOSED;
        //session过期 关闭客户端
        eventThread.queueEvent(new WatchedEvent(
                Watcher.Event.EventType.None,
                Watcher.Event.KeeperState.Expired, null));
        eventThread.queueEventOfDeath();
        ...
        throw new SessionExpiredException(warnInfo);
    }
    //读写客户端连接上只读服务器，则打印错误日志
    if (!readOnly &amp;&amp; isRO) {
        LOG.error(&quot;Read/write client got connected to read-only server&quot;);
    }
    readTimeout = negotiatedSessionTimeout * 2 / 3;
    connectTimeout = negotiatedSessionTimeout / hostProvider.size();
    hostProvider.onConnected();
    sessionId = _sessionId;
    sessionPasswd = _sessionPasswd;
    //连接成功修改连接状态
    state = (isRO) ?
            States.CONNECTEDREADONLY : States.CONNECTED;
    //是否连接上读写服务器
    seenRwServerBefore |= !isRO;
    KeeperState eventState = (isRO) ?
            KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;
    事件队列添加一个None类型的事件
    eventThread.queueEvent(new WatchedEvent(
            Watcher.Event.EventType.None,
            eventState, null));
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 12、EventThread的queueEvent方法</span><br></pre></td></tr></table></figure>
<pre><code>private void queueEvent(WatchedEvent event,
        Set&lt;Watcher&gt; materializedWatchers) {
    if (event.getType() == EventType.None
            &amp;&amp; sessionState == event.getState()) {
        return;
    }
    sessionState = event.getState();
    final Set&lt;Watcher&gt; watchers;
    if (materializedWatchers == null) {
        // 获取与该事件相关的所有监听器
        watchers = watcher.materialize(event.getState(),
                event.getType(), event.getPath());
    } else {
        watchers = new HashSet&lt;Watcher&gt;();
        watchers.addAll(materializedWatchers);
    }
    WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);
    //往队列添加监听器和事件对
    waitingEvents.add(pair);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 13、ZKWatchManager的materialize方法</span><br></pre></td></tr></table></figure>
<pre><code>@Override
public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,
                                    Watcher.Event.EventType type,
                                    String clientPath)
{
    Set&lt;Watcher&gt; result = new HashSet&lt;Watcher&gt;();

    switch (type) {
    //None类型的事件通知所有监听器
    case None:
        result.add(defaultWatcher);
        boolean clear = disableAutoWatchReset &amp;&amp; state != Watcher.Event.KeeperState.SyncConnected;
        synchronized(dataWatches) {
            for(Set&lt;Watcher&gt; ws: dataWatches.values()) {
                result.addAll(ws);
            }
            if (clear) {
                dataWatches.clear();
            }
        }

        synchronized(existWatches) {
            for(Set&lt;Watcher&gt; ws: existWatches.values()) {
                result.addAll(ws);
            }
            if (clear) {
                existWatches.clear();
            }
        }

        synchronized(childWatches) {
            for(Set&lt;Watcher&gt; ws: childWatches.values()) {
                result.addAll(ws);
            }
            if (clear) {
                childWatches.clear();
            }
        }

        return result;
    case NodeDataChanged:
    case NodeCreated:
        synchronized (dataWatches) {
            addTo(dataWatches.remove(clientPath), result);
        }
        synchronized (existWatches) {
            addTo(existWatches.remove(clientPath), result);
        }
        break;
    case NodeChildrenChanged:
        synchronized (childWatches) {
            addTo(childWatches.remove(clientPath), result);
        }
        break;
    case NodeDeleted:
        synchronized (dataWatches) {
            addTo(dataWatches.remove(clientPath), result);
        }
        // XXX This shouldn&apos;t be needed, but just in case
        synchronized (existWatches) {
            Set&lt;Watcher&gt; list = existWatches.remove(clientPath);
            if (list != null) {
                addTo(existWatches.remove(clientPath), result);
                LOG.warn(&quot;We are triggering an exists watch for delete! Shouldn&apos;t happen!&quot;);
            }
        }
        synchronized (childWatches) {
            addTo(childWatches.remove(clientPath), result);
        }
        break;
    default:
        String msg = &quot;Unhandled watch event type &quot; + type
            + &quot; with state &quot; + state + &quot; on path &quot; + clientPath;
        LOG.error(msg);
        throw new RuntimeException(msg);
    }

    return result;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 14、EventThread的processEvent方法</span><br><span class="line">EventThread的run方法中的processEvent方法处理事件</span><br></pre></td></tr></table></figure>
<pre><code>private void processEvent(Object event) {
    try {
        if (event instanceof WatcherSetEventPair) {
            //是监听器事件则调用所有监听器
            WatcherSetEventPair pair = (WatcherSetEventPair) event;
            for (Watcher watcher : pair.watchers) {
                try {
                      watcher.process(pair.event);
                catch (Throwable t) {
                      LOG.error(&quot;Error while calling watcher &quot;, t);
                }
            }
            //调用回调函数
        } else if (event instanceof LocalCallback) {
            LocalCallback lcb = (LocalCallback) event;
            if (lcb.cb instanceof StatCallback) {
                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path,
                        lcb.ctx, null);
                }
                ...
        } else {
            //是数据包则调用其中的回调函数
            Packet p = (Packet) event;
            int rc = 0;
            String clientPath = p.clientPath;
            if (p.replyHeader.getErr() != 0) {
                rc = p.replyHeader.getErr();
            }
            if (p.cb == null) {
                LOG.warn(&quot;Somehow a null cb got to EventThread!&quot;);
            } else if (p.response instanceof ExistsResponse
                      || p.response instanceof SetDataResponse
                      || p.response instanceof SetACLResponse) {
                StatCallback cb = (StatCallback) p.cb;
                if (rc == 0) {
                    if (p.response instanceof ExistsResponse) {
                        cb.processResult(rc, clientPath, p.ctx,
                                  ((ExistsResponse) p.response)
                                          .getStat());
                    } else if (p.response instanceof SetDataResponse) {
                        cb.processResult(rc, clientPath, p.ctx,
                                  ((SetDataResponse) p.response)
                                          .getStat());
                    } else if (p.response instanceof SetACLResponse) {
                          cb.processResult(rc, clientPath, p.ctx,
                                  ((SetACLResponse) p.response)
                                          .getStat());
                    }
                } else {
                      cb.processResult(rc, clientPath, p.ctx, null);
                }
            }
            ... 
           }
    } catch (Throwable t) {
        LOG.error(&quot;Caught unexpected throwable&quot;, t);
    }
}  
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">至此客户端连接成功</span><br><span class="line">### 二、添加节点过程</span><br><span class="line">#### 1、ZooKeeper类中的create方法</span><br></pre></td></tr></table></figure>
<pre><code>//path           节点的位置
//data[]         节点的数据
//acl             OPEN_ACL_UNSAFE：完全开放
//                CREATOR_ALL_ACL：创建该znode的连接拥有所有权限
//                READ_ACL_UNSAFE：所有的客户端都可读
//createMode     PERSISTENT：持久化节点
//                PERSISTENT_SEQUENTIAL：持久化有序节点
//                EPHEMERAL：临时节点（连接断开自动删除）
//                EPHEMERAL_SEQUENTIAL：临时有序节点（连接断开自动删除）
public String create(final String path, byte data[], List&lt;ACL&gt; acl,
        CreateMode createMode)
    throws KeeperException, InterruptedException
{
    final String clientPath = path;
    PathUtils.validatePath(clientPath, createMode.isSequential());
    EphemeralType.validateTTL(createMode, -1);
    validateACL(acl);

    final String serverPath = prependChroot(clientPath);

    RequestHeader h = new RequestHeader();
    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);
    CreateRequest request = new CreateRequest();
    CreateResponse response = new CreateResponse();
    request.setData(data);
    request.setFlags(createMode.toFlag());
    request.setPath(serverPath);
    request.setAcl(acl);
    //发送请求
    ReplyHeader r = cnxn.submitRequest(h, request, response, null);
    if (r.getErr() != 0) {
        throw KeeperException.create(KeeperException.Code.get(r.getErr()),
                clientPath);
    }
    if (cnxn.chrootPath == null) {
        return response.getPath();
    } else {
        return response.getPath().substring(cnxn.chrootPath.length());
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 2、ClientCnxn的submitRequest方法</span><br></pre></td></tr></table></figure>
<pre><code>public ReplyHeader submitRequest(RequestHeader h, Record request,
        Record response, WatchRegistration watchRegistration,
        WatchDeregistration watchDeregistration)
        throws InterruptedException {
    ReplyHeader r = new ReplyHeader();
    //将请求打包并加入发送队列
    Packet packet = queuePacket(h, r, request, response, null, null, null,
            null, watchRegistration, watchDeregistration);
    synchronized (packet) {
        //等待直到数据包处理
        while (!packet.finished) {
            packet.wait();
        }
    }
    return r;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 3、ClientCnxn的queuePacket方法</span><br></pre></td></tr></table></figure>
<pre><code>public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,
        Record response, AsyncCallback cb, String clientPath,
        String serverPath, Object ctx, WatchRegistration watchRegistration,
        WatchDeregistration watchDeregistration) {
    Packet packet = null;

    //创建待发送的数据包裹
    packet = new Packet(h, r, request, response, watchRegistration);
    packet.cb = cb;
    packet.ctx = ctx;
    packet.clientPath = clientPath;
    packet.serverPath = serverPath;
    packet.watchDeregistration = watchDeregistration;

    synchronized (state) {
        if (!state.isAlive() || closing) {
            //客户端已关闭或正在关闭，关闭包裹
            conLossPacket(packet);
        } else {
            //如果发送的是关闭请求,更改正关闭状态为true
            if (h.getType() == OpCode.closeSession) {
                closing = true;
            }
            将数据包裹加入待发送队列
            outgoingQueue.add(packet);
        }
    }
    //唤醒selector
    sendThread.getClientCnxnSocket().packetAdded();
    return packet;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 4、SendThread类的readResponse方法</span><br><span class="line">发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据</span><br></pre></td></tr></table></figure>
<pre><code>void readResponse(ByteBuffer incomingBuffer) throws IOException {
    ByteBufferInputStream bbis = new ByteBufferInputStream(
            incomingBuffer);
    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);
    ReplyHeader replyHdr = new ReplyHeader();

    replyHdr.deserialize(bbia, &quot;header&quot;);
    //ping请求返回
    if (replyHdr.getXid() == -2) {
        return;
    }
    //权限认证请求返回
    if (replyHdr.getXid() == -4) {
        if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {
            state = States.AUTH_FAILED;                    
            eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, 
                    Watcher.Event.KeeperState.AuthFailed, null) );                                        
        }
        return;
    }
    //客户端返回通知
    if (replyHdr.getXid() == -1) {
        WatcherEvent event = new WatcherEvent();
        event.deserialize(bbia, &quot;response&quot;);

        //把event中的path转换为客户端path
        if (chrootPath != null) {
            String serverPath = event.getPath();
            if(serverPath.compareTo(chrootPath)==0)
                event.setPath(&quot;/&quot;);
            else if (serverPath.length() &gt; chrootPath.length())
                event.setPath(serverPath.substring(chrootPath.length()));
            else {
                LOG.warn(&quot;Got server path &quot; + event.getPath()
                        + &quot; which is too short for chroot path &quot;
                        + chrootPath);
            }
        }

        WatchedEvent we = new WatchedEvent(event);
        //添加事件，逻辑在（一、12）中
        eventThread.queueEvent( we );
        return;
    }

    ...

    Packet packet;
    synchronized (pendingQueue) {
        if (pendingQueue.size() == 0) {
            throw new IOException(&quot;Nothing in the queue, but got &quot;
                    + replyHdr.getXid());
        }
        //服务端已返回，从队列中删除该数据包
        packet = pendingQueue.remove();
    }
    //数据包裹按顺序处理，返回不一致则抛出异常
    try {
        if (packet.requestHeader.getXid() != replyHdr.getXid()) {
            packet.replyHeader.setErr(
                    KeeperException.Code.CONNECTIONLOSS.intValue());
            throw new IOException(&quot;Xid out of order. Got Xid &quot;
                    + replyHdr.getXid() + &quot; with err &quot; +
                    + replyHdr.getErr() +
                    &quot; expected Xid &quot;
                    + packet.requestHeader.getXid()
                    + &quot; for a packet with details: &quot;
                    + packet );
        }

        packet.replyHeader.setXid(replyHdr.getXid());
        packet.replyHeader.setErr(replyHdr.getErr());
        packet.replyHeader.setZxid(replyHdr.getZxid());
        if (replyHdr.getZxid() &gt; 0) {
            //更新最新处理事物id
            lastZxid = replyHdr.getZxid();
        }
        if (packet.response != null &amp;&amp; replyHdr.getErr() == 0) {
            //序列化返回数据
            packet.response.deserialize(bbia, &quot;response&quot;);
        }
    } finally {
        //最终完成数据包处理
        finishPacket(packet);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 5、SendThread的finishPacket方法</span><br></pre></td></tr></table></figure>
<pre><code>private void finishPacket(Packet p) {
    int err = p.replyHeader.getErr();
    if (p.watchRegistration != null) {
        //注册监听器到watchManager中
        p.watchRegistration.register(err);
    }
    ...
    数据包裹处理完成
    if (p.cb == null) {
        synchronized (p) {
            p.finished = true;
            p.notifyAll();
        }
    } else {
        p.finished = true;
        eventThread.queuePacket(p);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">到此create处理完成</span><br><span class="line">### 三、添加监听器过程</span><br><span class="line">#### 1、以ZooKeepe类中的exists方法为例</span><br></pre></td></tr></table></figure>
<pre><code>public Stat exists(final String path, Watcher watcher)
    throws KeeperException, InterruptedException
{
    final String clientPath = path;
    PathUtils.validatePath(clientPath);
    WatchRegistration wcb = null;
    if (watcher != null) {
        //新建Exist监听器注册器
        wcb = new ExistsWatchRegistration(watcher, clientPath);
    }

    final String serverPath = prependChroot(clientPath);

    RequestHeader h = new RequestHeader();
    h.setType(ZooDefs.OpCode.exists);
    //实例化Exists请求
    ExistsRequest request = new ExistsRequest();
    request.setPath(serverPath);
    request.setWatch(watcher != null);
    SetDataResponse response = new SetDataResponse();
    //发送请求，见（二、2）
    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);
    if (r.getErr() != 0) {
        if (r.getErr() == KeeperException.Code.NONODE.intValue()) {
            return null;
        }
        throw KeeperException.create(KeeperException.Code.get(r.getErr()),
                clientPath);
    }

    return response.getStat().getCzxid() == -1 ? null : response.getStat();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 2、ExistsWatchRegistration的register方法</span><br><span class="line">发送和接受请求与二中相同</span><br></pre></td></tr></table></figure>
<pre><code>public void register(int rc) {
    if (shouldAddWatch(rc)) {
        Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);
        synchronized(watches) {
            Set&lt;Watcher&gt; watchers = watches.get(clientPath);
            if (watchers == null) {
                watchers = new HashSet&lt;Watcher&gt;();
                watches.put(clientPath, watchers);
            }
            watchers.add(watcher);
        }
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 3、ExistsWatchRegistration的getWatches方法</span><br></pre></td></tr></table></figure>
<pre><code>@Override
protected Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(int rc) {
    //返回成功则注册到dataWatches，不存在则注册到existWatches中
    return rc == 0 ?  watchManager.dataWatches : watchManager.existWatches;
}
</code></pre><p><code>`</code><br>到此zookeeper客户端源码就介绍完了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/07/zookeeper源码/zookeeper源码客户端/" data-id="cjfowx40k000678ue7z4uinv6" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/04/07/zookeeper源码/zookeeper源码单机版服务端/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">zookeeper源码客户端</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/07/zookeeper源码/zookeeper源码客户端/">zookeeper源码客户端</a>
          </li>
        
          <li>
            <a href="/2018/04/07/zookeeper源码/zookeeper源码单机版服务端/">zookeeper源码客户端</a>
          </li>
        
          <li>
            <a href="/2018/04/07/zookeeper源码/zookeeper源码分布服务端（2）/">zookeeper源码分布服务端（2）</a>
          </li>
        
          <li>
            <a href="/2018/04/07/zookeeper源码/zookeeper源码分布服务端（1）/">zookeeper源码分布服务端（1）</a>
          </li>
        
          <li>
            <a href="/2018/02/21/helloworld/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>