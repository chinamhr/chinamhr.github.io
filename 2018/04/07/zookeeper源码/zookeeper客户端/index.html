<!DOCTYPE html>
<html lang="default">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="客户端Demo1234567891011121314151617181920ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &amp;#123;           @Override           p"/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="zookeeper客户端"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="客户端Demo1234567891011121314151617181920ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &amp;#123;           @Override           p"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.comhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.comhttp://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>zookeeper客户端 - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>zookeeper客户端</h1>
                    
                    <h2 class="post-subheading">
                        建立连接、create及exists处理的过程
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-04-07
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/zookeeper/">zookeeper</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h4 id="客户端Demo"><a href="#客户端Demo" class="headerlink" title="客户端Demo"></a>客户端Demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">//参数1 路径，参数2 内容，参数3 权限，参数4 类型</span><br><span class="line">String znodePath = zk.create(&quot;/demo&quot;, &quot;hello zookeeper&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">   	CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">//判断/java节点是否存在，并且给它注册一个监听器，这个监听器只能监听一次，监听到一次事件后就会失效  </span><br><span class="line">   zk.exists(&quot;/demo&quot;, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="一、建立连接过程"><a href="#一、建立连接过程" class="headerlink" title="一、建立连接过程"></a>一、建立连接过程</h3><h4 id="1、实例化ZooKeeper"><a href="#1、实例化ZooKeeper" class="headerlink" title="1、实例化ZooKeeper"></a>1、实例化ZooKeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   // connectString 连接字符串 如&quot;192.168.12.1:2181,192.168.12.2:2181,192.168.12.3:2181/root&quot;  </span><br><span class="line">   // sessionTimeout 客户端提议的session有效时间</span><br><span class="line">public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,</span><br><span class="line">           boolean canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">           ZKClientConfig clientConfig) throws IOException &#123;</span><br><span class="line">       LOG.info(&quot;Initiating client connection, connectString=&quot; + connectString</span><br><span class="line">               + &quot; sessionTimeout=&quot; + sessionTimeout + &quot; watcher=&quot; + watcher);</span><br><span class="line"></span><br><span class="line">       if (clientConfig == null) &#123;</span><br><span class="line">           clientConfig = new ZKClientConfig();</span><br><span class="line">       &#125;</span><br><span class="line">       this.clientConfig = clientConfig;</span><br><span class="line"></span><br><span class="line">       //创建Watcher监听器的管理器</span><br><span class="line">       watchManager = defaultWatchManager();</span><br><span class="line"></span><br><span class="line">       //设置默认的Watcher监听器</span><br><span class="line">       watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">       ConnectStringParser connectStringParser = new ConnectStringParser(</span><br><span class="line">               connectString);</span><br><span class="line"></span><br><span class="line">       hostProvider = aHostProvider;</span><br><span class="line"></span><br><span class="line">       //客户端负责与服务端通信的对象</span><br><span class="line">       cnxn = new ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">               hostProvider, sessionTimeout, this, watchManager,</span><br><span class="line">               getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">       cnxn.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、实例化ClientCnxn"><a href="#2、实例化ClientCnxn" class="headerlink" title="2、实例化ClientCnxn"></a>2、实例化ClientCnxn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">       this.zooKeeper = zooKeeper;</span><br><span class="line">       this.watcher = watcher;</span><br><span class="line">       this.sessionId = sessionId; //初始值为0</span><br><span class="line">       this.sessionPasswd = sessionPasswd; //初始值为 new byte[16]</span><br><span class="line">       this.sessionTimeout = sessionTimeout;</span><br><span class="line">       this.hostProvider = hostProvider;</span><br><span class="line">       this.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.size();//hostProvider.size() 服务端地址个数</span><br><span class="line">       readTimeout = sessionTimeout * 2 / 3;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">	//发送和接收socket数据的线程</span><br><span class="line">       sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line"></span><br><span class="line">       //事件线程</span><br><span class="line">       eventThread = new EventThread();</span><br><span class="line"></span><br><span class="line">       this.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、SendThread的run方法"><a href="#3、SendThread的run方法" class="headerlink" title="3、SendThread的run方法"></a>3、SendThread的run方法</h4><h5 id="ClientCnxn-的start方法-会分别启动SendThread、EventThread、SendThread的run方法"><a href="#ClientCnxn-的start方法-会分别启动SendThread、EventThread、SendThread的run方法" class="headerlink" title="ClientCnxn 的start方法 会分别启动SendThread、EventThread、SendThread的run方法"></a>ClientCnxn 的start方法 会分别启动SendThread、EventThread、SendThread的run方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    //更新最近接受和发送时间</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    int to;</span><br><span class="line">    long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">    InetSocketAddress serverAddress = null;</span><br><span class="line">    while (state.isAlive()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//判断是否完成连接</span><br><span class="line">            if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                判断是否关闭</span><br><span class="line">                if (closing) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //若之前连接过只读服务器，直接用上次查找出的读写服务器地址连接</span><br><span class="line">                if (rwServerAddress != null) &#123;</span><br><span class="line">                    serverAddress = rwServerAddress;</span><br><span class="line">                    rwServerAddress = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//获取下一个服务端地址 延迟1s返回</span><br><span class="line">                    serverAddress = hostProvider.next(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                //连接服务端</span><br><span class="line">                startConnect(serverAddress);</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            判断是否已连接</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                // determine whether we need to send an AuthFailed event.</span><br><span class="line">                if (zooKeeperSaslClient != null) &#123;</span><br><span class="line">                	...</span><br><span class="line">                    //进行sasl权限验证</span><br><span class="line">                &#125;</span><br><span class="line">                //超时剩余时间</span><br><span class="line">                to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	//超时剩余时间</span><br><span class="line">                to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //to &lt;= 0 则说明连接超时</span><br><span class="line">            if (to &lt;= 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //打印日志抛出异常</span><br><span class="line">                throw new SessionTimeoutException(warnInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果已连接  定时发送心跳检测</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - </span><br><span class="line">                		((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);</span><br><span class="line">                if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                    //发送ping数据</span><br><span class="line">                    sendPing();</span><br><span class="line">                    clientCnxnSocket.updateLastSend();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (timeToNextPing &lt; to) &#123;</span><br><span class="line">                        to = timeToNextPing;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果连接的是只读服务器</span><br><span class="line">            if (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                long now = Time.currentElapsedTime();</span><br><span class="line">                int idlePingRwServer = (int) (now - lastPingRwServer);</span><br><span class="line">                if (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                    lastPingRwServer = now;</span><br><span class="line">                    idlePingRwServer = 0;</span><br><span class="line">                    pingRwTimeout =</span><br><span class="line">                        Math.min(2*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                    //寻找读写服务器，抛出异常，重新连接</span><br><span class="line">                    pingRwServer();</span><br><span class="line">                &#125;</span><br><span class="line">                to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理与客户端的通信</span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (closing) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //跳出主循环，结束线程</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (state) &#123;</span><br><span class="line">        断开连接，处理队列中的数据包</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    关闭socket</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    if (state.isAlive()) &#123;</span><br><span class="line">    	//添加断开连接事件</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(Event.EventType.None,</span><br><span class="line">                Event.KeeperState.Disconnected, null));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、startConnect方法连接服务端"><a href="#4、startConnect方法连接服务端" class="headerlink" title="4、startConnect方法连接服务端"></a>4、startConnect方法连接服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startConnect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    客户端状态更新为正在连接</span><br><span class="line">    state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">    //连接服务端</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、ClientCnxnSocketNIO中的connect方法"><a href="#5、ClientCnxnSocketNIO中的connect方法" class="headerlink" title="5、ClientCnxnSocketNIO中的connect方法"></a>5、ClientCnxnSocketNIO中的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void connect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line">       SocketChannel sock = createSock();</span><br><span class="line">       try &#123;</span><br><span class="line">          registerAndConnect(sock, addr);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">           sock.close();</span><br><span class="line">           throw e;</span><br><span class="line">       &#125;</span><br><span class="line">       //未初始化</span><br><span class="line">       initialized = false;</span><br><span class="line">       //清空缓存区</span><br><span class="line">       lenBuffer.clear();</span><br><span class="line">       incomingBuffer = lenBuffer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、调用了registerAndConnect方法"><a href="#6、调用了registerAndConnect方法" class="headerlink" title="6、调用了registerAndConnect方法"></a>6、调用了registerAndConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void registerAndConnect(SocketChannel sock, InetSocketAddress addr) </span><br><span class="line">   throws IOException &#123;</span><br><span class="line">   	//向selector注册SocketChannel指定OP_CONNECT事件</span><br><span class="line">       sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">       //连接服务器</span><br><span class="line">       boolean immediateConnect = sock.connect(addr);</span><br><span class="line">       if (immediateConnect) &#123;</span><br><span class="line">           sendThread.primeConnection();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、SendThread的primeConnection方法"><a href="#7、SendThread的primeConnection方法" class="headerlink" title="7、SendThread的primeConnection方法"></a>7、SendThread的primeConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void primeConnection() throws IOException &#123;</span><br><span class="line">       isFirstConnect = false;</span><br><span class="line">       若之前连接过只读服务器，则使用之前的sessionId</span><br><span class="line">       long sessId = (seenRwServerBefore) ? sessionId : 0;</span><br><span class="line">       创建连接请求对象</span><br><span class="line">       ConnectRequest conReq = new ConnectRequest(0, lastZxid,</span><br><span class="line">               sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">      </span><br><span class="line">       //重新连接将已有的监听器注册到服务器</span><br><span class="line">       if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) &#123;</span><br><span class="line">       	//类是否存在监听器</span><br><span class="line">           List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();</span><br><span class="line">           //数据变化监听器</span><br><span class="line">           List&lt;String&gt; existWatches = zooKeeper.getExistWatches();</span><br><span class="line">           //子节点变化监听器</span><br><span class="line">           List&lt;String&gt; childWatches = zooKeeper.getChildWatches();</span><br><span class="line">           if (!dataWatches.isEmpty()</span><br><span class="line">                   || !existWatches.isEmpty() || !childWatches.isEmpty()) &#123;</span><br><span class="line">               Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();</span><br><span class="line">               long setWatchesLastZxid = lastZxid;</span><br><span class="line"></span><br><span class="line">               while (dataWatchesIter.hasNext()</span><br><span class="line">                      || existWatchesIter.hasNext() || childWatchesIter.hasNext()) &#123;</span><br><span class="line">                   List&lt;String&gt; dataWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; existWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; childWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   int batchLength = 0;</span><br><span class="line"></span><br><span class="line">                   while (batchLength &lt; SET_WATCHES_MAX_LENGTH) &#123;</span><br><span class="line">                       final String watch;</span><br><span class="line">                       if (dataWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = dataWatchesIter.next();</span><br><span class="line">                           dataWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (existWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = existWatchesIter.next();</span><br><span class="line">                           existWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (childWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = childWatchesIter.next();</span><br><span class="line">                           childWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                       batchLength += watch.length();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   SetWatches sw = new SetWatches(setWatchesLastZxid,</span><br><span class="line">                                                  dataWatchesBatch,</span><br><span class="line">                                                  existWatchesBatch,</span><br><span class="line">                                                  childWatchesBatch);</span><br><span class="line">                   RequestHeader header = new RequestHeader(-8, OpCode.setWatches);</span><br><span class="line">                   Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);</span><br><span class="line">                   outgoingQueue.addFirst(packet);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       //新建一个数据包，加入发送队列</span><br><span class="line">       outgoingQueue.addFirst(new Packet(null, null, conReq,</span><br><span class="line">               null, null, readOnly));</span><br><span class="line">       //该方法修改SocketChannel指定事件为读和写</span><br><span class="line">       clientCnxnSocket.connectionPrimed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、ClientCnxnSocketNIO的doTransport方法"><a href="#8、ClientCnxnSocketNIO的doTransport方法" class="headerlink" title="8、ClientCnxnSocketNIO的doTransport方法"></a>8、ClientCnxnSocketNIO的doTransport方法</h4><h5 id="读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中"><a href="#读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中" class="headerlink" title="读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中"></a>读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void doTransport(int waitTimeOut, List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">           throws IOException, InterruptedException &#123;</span><br><span class="line">       selector.select(waitTimeOut);</span><br><span class="line">       Set&lt;SelectionKey&gt; selected;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           selected = selector.selectedKeys();</span><br><span class="line">       &#125;</span><br><span class="line">       updateNow();</span><br><span class="line">       for (SelectionKey k : selected) &#123;</span><br><span class="line">           SocketChannel sc = ((SocketChannel) k.channel());</span><br><span class="line">           //连接事件未就绪</span><br><span class="line">           if ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">               if (sc.finishConnect()) &#123;</span><br><span class="line">                   updateLastSendAndHeard();</span><br><span class="line">                   更新服务端地址</span><br><span class="line">                   updateSocketAddresses();</span><br><span class="line">                   连接服务端</span><br><span class="line">                   sendThread.primeConnection();</span><br><span class="line">               &#125;</span><br><span class="line">            //读写事件就绪</span><br><span class="line">           &#125; else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) &#123;</span><br><span class="line">               处理通信数据</span><br><span class="line">               doIO(pendingQueue, cnxn);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sendThread.getZkState().isConnected()) &#123;</span><br><span class="line">       	//找出可以在sasl认证之前可以预先发送的请求</span><br><span class="line">           if (findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       selected.clear();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ClientCnxnSocketNIO的doIO方法"><a href="#9、ClientCnxnSocketNIO的doIO方法" class="headerlink" title="9、ClientCnxnSocketNIO的doIO方法"></a>9、ClientCnxnSocketNIO的doIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">     throws InterruptedException, IOException &#123;</span><br><span class="line">       SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">       if (sock == null) &#123;</span><br><span class="line">           throw new IOException(&quot;Socket is null!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //就绪事件为读事件</span><br><span class="line">       if (sockKey.isReadable()) &#123;</span><br><span class="line">           int rc = sock.read(incomingBuffer);</span><br><span class="line">           if (rc &lt; 0) &#123;</span><br><span class="line">               throw new EndOfStreamException(</span><br><span class="line">                       &quot;Unable to read additional data from server sessionid 0x&quot;</span><br><span class="line">                               + Long.toHexString(sessionId)</span><br><span class="line">                               + &quot;, likely server has closed socket&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           //incomingBuffer是否还有空间</span><br><span class="line">           if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">               incomingBuffer.flip();</span><br><span class="line">               //如果incomingBuffer和lenBuffer指向同一个byteBuffer，说明是新请求的第一次读 </span><br><span class="line">               if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">               	请求次数增加</span><br><span class="line">                   recvCount++;</span><br><span class="line">                   //incomingBuffer缓存区初始化</span><br><span class="line">                   readLength();</span><br><span class="line">               &#125; else if (!initialized) &#123;</span><br><span class="line">               	//读取服务端的连接请求返回</span><br><span class="line">                   readConnectResult();</span><br><span class="line">                   enableRead();</span><br><span class="line">                   if (findSendablePacket(outgoingQueue,</span><br><span class="line">                           sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">                       enableWrite();</span><br><span class="line">                   &#125;</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">                   initialized = true;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               	//读取服务端的其他请求返回</span><br><span class="line">                   sendThread.readResponse(incomingBuffer);</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sockKey.isWritable()) &#123;</span><br><span class="line">       	//查找可发送的数据包</span><br><span class="line">           Packet p = findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress());</span><br><span class="line"></span><br><span class="line">           if (p != null) &#123;</span><br><span class="line">               updateLastSend();</span><br><span class="line">               // If we already started writing p, p.bb will already exist</span><br><span class="line">               if (p.bb == null) &#123;</span><br><span class="line">                   if ((p.requestHeader != null) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.auth)) &#123;</span><br><span class="line">                       p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                   &#125;</span><br><span class="line">                   p.createBB();</span><br><span class="line">               &#125;</span><br><span class="line">               //发送数据</span><br><span class="line">               sock.write(p.bb);</span><br><span class="line">               if (!p.bb.hasRemaining()) &#123;</span><br><span class="line">                   sentCount++;</span><br><span class="line">                   outgoingQueue.removeFirstOccurrence(p);</span><br><span class="line">                   if (p.requestHeader != null</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.ping</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</span><br><span class="line">                       synchronized (pendingQueue) &#123;</span><br><span class="line">                       	//把包裹加入到等待服务端返回队列</span><br><span class="line">                           pendingQueue.add(p);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">               发送队列为空，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else if (!initialized &amp;&amp; p != null &amp;&amp; !p.bb.hasRemaining()) &#123;</span><br><span class="line">               连接请求发送完成，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Just in case</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ClientCnxnSocketNIO的readConnectResult方法"><a href="#10、ClientCnxnSocketNIO的readConnectResult方法" class="headerlink" title="10、ClientCnxnSocketNIO的readConnectResult方法"></a>10、ClientCnxnSocketNIO的readConnectResult方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void readConnectResult() throws IOException &#123;</span><br><span class="line">       if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">           StringBuilder buf = new StringBuilder(&quot;0x[&quot;);</span><br><span class="line">           for (byte b : incomingBuffer.array()) &#123;</span><br><span class="line">               buf.append(Integer.toHexString(b) + &quot;,&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           buf.append(&quot;]&quot;);</span><br><span class="line">           LOG.trace(&quot;readConnectResult &quot; + incomingBuffer.remaining() + &quot; &quot;</span><br><span class="line">                   + buf.toString());</span><br><span class="line">       &#125;</span><br><span class="line">       ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">       BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">       ConnectResponse conRsp = new ConnectResponse();</span><br><span class="line">       反序列化连接请求返回</span><br><span class="line">       conRsp.deserialize(bbia, &quot;connect&quot;);</span><br><span class="line"></span><br><span class="line">       // read &quot;is read-only&quot; flag</span><br><span class="line">       boolean isRO = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           isRO = bbia.readBool(&quot;readOnly&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           // this is ok -- just a packet from an old server which</span><br><span class="line">           // doesn&apos;t contain readOnly field</span><br><span class="line">           LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //获取服务端返回的sessionId</span><br><span class="line">       this.sessionId = conRsp.getSessionId();</span><br><span class="line">       //最终处理连接返回数据</span><br><span class="line">       sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,</span><br><span class="line">               conRsp.getPasswd(), isRO);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、sendThread的onConnected方法"><a href="#11、sendThread的onConnected方法" class="headerlink" title="11、sendThread的onConnected方法"></a>11、sendThread的onConnected方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void onConnected(int _negotiatedSessionTimeout, long _sessionId,</span><br><span class="line">                byte[] _sessionPasswd, boolean isRO) throws IOException &#123;</span><br><span class="line">    negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">    //session是否过期</span><br><span class="line">    if (negotiatedSessionTimeout &lt;= 0) &#123;</span><br><span class="line">        state = States.CLOSED;</span><br><span class="line">        //session过期 关闭客户端</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">                Watcher.Event.EventType.None,</span><br><span class="line">                Watcher.Event.KeeperState.Expired, null));</span><br><span class="line">        eventThread.queueEventOfDeath();</span><br><span class="line">        ...</span><br><span class="line">        throw new SessionExpiredException(warnInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    //读写客户端连接上只读服务器，则打印错误日志</span><br><span class="line">    if (!readOnly &amp;&amp; isRO) &#123;</span><br><span class="line">        LOG.error(&quot;Read/write client got connected to read-only server&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    readTimeout = negotiatedSessionTimeout * 2 / 3;</span><br><span class="line">    connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">    hostProvider.onConnected();</span><br><span class="line">    sessionId = _sessionId;</span><br><span class="line">    sessionPasswd = _sessionPasswd;</span><br><span class="line">    //连接成功修改连接状态</span><br><span class="line">    state = (isRO) ?</span><br><span class="line">            States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">    //是否连接上读写服务器</span><br><span class="line">    seenRwServerBefore |= !isRO;</span><br><span class="line">    KeeperState eventState = (isRO) ?</span><br><span class="line">            KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">    事件队列添加一个None类型的事件</span><br><span class="line">    eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">            Watcher.Event.EventType.None,</span><br><span class="line">            eventState, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、EventThread的queueEvent方法"><a href="#12、EventThread的queueEvent方法" class="headerlink" title="12、EventThread的queueEvent方法"></a>12、EventThread的queueEvent方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void queueEvent(WatchedEvent event,</span><br><span class="line">           Set&lt;Watcher&gt; materializedWatchers) &#123;</span><br><span class="line">       if (event.getType() == EventType.None</span><br><span class="line">               &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       sessionState = event.getState();</span><br><span class="line">       final Set&lt;Watcher&gt; watchers;</span><br><span class="line">       if (materializedWatchers == null) &#123;</span><br><span class="line">           // 获取与该事件相关的所有监听器</span><br><span class="line">           watchers = watcher.materialize(event.getState(),</span><br><span class="line">                   event.getType(), event.getPath());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">           watchers.addAll(materializedWatchers);</span><br><span class="line">       &#125;</span><br><span class="line">       WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);</span><br><span class="line">       //往队列添加监听器和事件对</span><br><span class="line">       waitingEvents.add(pair);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、ZKWatchManager的materialize方法"><a href="#13、ZKWatchManager的materialize方法" class="headerlink" title="13、ZKWatchManager的materialize方法"></a>13、ZKWatchManager的materialize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,</span><br><span class="line">                                       Watcher.Event.EventType type,</span><br><span class="line">                                       String clientPath)</span><br><span class="line">   &#123;</span><br><span class="line">       Set&lt;Watcher&gt; result = new HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">       switch (type) &#123;</span><br><span class="line">       //None类型的事件通知所有监听器</span><br><span class="line">       case None:</span><br><span class="line">           result.add(defaultWatcher);</span><br><span class="line">           boolean clear = disableAutoWatchReset &amp;&amp; state != Watcher.Event.KeeperState.SyncConnected;</span><br><span class="line">           synchronized(dataWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: dataWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   dataWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(existWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: existWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   existWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(childWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: childWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   childWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       case NodeDataChanged:</span><br><span class="line">       case NodeCreated:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               addTo(existWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeChildrenChanged:</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeDeleted:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           // XXX This shouldn&apos;t be needed, but just in case</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; list = existWatches.remove(clientPath);</span><br><span class="line">               if (list != null) &#123;</span><br><span class="line">                   addTo(existWatches.remove(clientPath), result);</span><br><span class="line">                   LOG.warn(&quot;We are triggering an exists watch for delete! Shouldn&apos;t happen!&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       default:</span><br><span class="line">           String msg = &quot;Unhandled watch event type &quot; + type</span><br><span class="line">               + &quot; with state &quot; + state + &quot; on path &quot; + clientPath;</span><br><span class="line">           LOG.error(msg);</span><br><span class="line">           throw new RuntimeException(msg);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、EventThread的processEvent方法"><a href="#14、EventThread的processEvent方法" class="headerlink" title="14、EventThread的processEvent方法"></a>14、EventThread的processEvent方法</h4><h5 id="EventThread的run方法中的processEvent方法处理事件"><a href="#EventThread的run方法中的processEvent方法处理事件" class="headerlink" title="EventThread的run方法中的processEvent方法处理事件"></a>EventThread的run方法中的processEvent方法处理事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private void processEvent(Object event) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (event instanceof WatcherSetEventPair) &#123;</span><br><span class="line">            //是监听器事件则调用所有监听器</span><br><span class="line">            WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">            for (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                      watcher.process(pair.event);</span><br><span class="line">                catch (Throwable t) &#123;</span><br><span class="line">                      LOG.error(&quot;Error while calling watcher &quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用回调函数</span><br><span class="line">        &#125; else if (event instanceof LocalCallback) &#123;</span><br><span class="line">            LocalCallback lcb = (LocalCallback) event;</span><br><span class="line">            if (lcb.cb instanceof StatCallback) &#123;</span><br><span class="line">                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path,</span><br><span class="line">                        lcb.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	//是数据包则调用其中的回调函数</span><br><span class="line">            Packet p = (Packet) event;</span><br><span class="line">            int rc = 0;</span><br><span class="line">            String clientPath = p.clientPath;</span><br><span class="line">            if (p.replyHeader.getErr() != 0) &#123;</span><br><span class="line">                rc = p.replyHeader.getErr();</span><br><span class="line">            &#125;</span><br><span class="line">            if (p.cb == null) &#123;</span><br><span class="line">                LOG.warn(&quot;Somehow a null cb got to EventThread!&quot;);</span><br><span class="line">            &#125; else if (p.response instanceof ExistsResponse</span><br><span class="line">                      || p.response instanceof SetDataResponse</span><br><span class="line">                      || p.response instanceof SetACLResponse) &#123;</span><br><span class="line">            	StatCallback cb = (StatCallback) p.cb;</span><br><span class="line">                if (rc == 0) &#123;</span><br><span class="line">                    if (p.response instanceof ExistsResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((ExistsResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetDataResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetDataResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetACLResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetACLResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	... </span><br><span class="line">       	&#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        LOG.error(&quot;Caught unexpected throwable&quot;, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="至此客户端连接成功"><a href="#至此客户端连接成功" class="headerlink" title="至此客户端连接成功"></a>至此客户端连接成功</h5><h3 id="二、添加节点过程"><a href="#二、添加节点过程" class="headerlink" title="二、添加节点过程"></a>二、添加节点过程</h3><h4 id="1、ZooKeeper类中的create方法"><a href="#1、ZooKeeper类中的create方法" class="headerlink" title="1、ZooKeeper类中的create方法"></a>1、ZooKeeper类中的create方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   //path   		节点的位置</span><br><span class="line">   //data[] 		节点的数据</span><br><span class="line">   //acl 			OPEN_ACL_UNSAFE：完全开放</span><br><span class="line">//				CREATOR_ALL_ACL：创建该znode的连接拥有所有权限</span><br><span class="line">//				READ_ACL_UNSAFE：所有的客户端都可读</span><br><span class="line">   //createMode 	PERSISTENT：持久化节点</span><br><span class="line">//				PERSISTENT_SEQUENTIAL：持久化有序节点</span><br><span class="line">//				EPHEMERAL：临时节点（连接断开自动删除）</span><br><span class="line">//				EPHEMERAL_SEQUENTIAL：临时有序节点（连接断开自动删除）</span><br><span class="line">public String create(final String path, byte data[], List&lt;ACL&gt; acl,</span><br><span class="line">           CreateMode createMode)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">       EphemeralType.validateTTL(createMode, -1);</span><br><span class="line">       validateACL(acl);</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">       CreateRequest request = new CreateRequest();</span><br><span class="line">       CreateResponse response = new CreateResponse();</span><br><span class="line">       request.setData(data);</span><br><span class="line">       request.setFlags(createMode.toFlag());</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setAcl(acl);</span><br><span class="line">       //发送请求</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, null);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line">       if (cnxn.chrootPath == null) &#123;</span><br><span class="line">           return response.getPath();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return response.getPath().substring(cnxn.chrootPath.length());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ClientCnxn的submitRequest方法"><a href="#2、ClientCnxn的submitRequest方法" class="headerlink" title="2、ClientCnxn的submitRequest方法"></a>2、ClientCnxn的submitRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ReplyHeader submitRequest(RequestHeader h, Record request,</span><br><span class="line">           Record response, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       ReplyHeader r = new ReplyHeader();</span><br><span class="line">       //将请求打包并加入发送队列</span><br><span class="line">       Packet packet = queuePacket(h, r, request, response, null, null, null,</span><br><span class="line">               null, watchRegistration, watchDeregistration);</span><br><span class="line">       synchronized (packet) &#123;</span><br><span class="line">       	//等待直到数据包处理</span><br><span class="line">           while (!packet.finished) &#123;</span><br><span class="line">               packet.wait();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ClientCnxn的queuePacket方法"><a href="#3、ClientCnxn的queuePacket方法" class="headerlink" title="3、ClientCnxn的queuePacket方法"></a>3、ClientCnxn的queuePacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,</span><br><span class="line">           Record response, AsyncCallback cb, String clientPath,</span><br><span class="line">           String serverPath, Object ctx, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration) &#123;</span><br><span class="line">       Packet packet = null;</span><br><span class="line"></span><br><span class="line">       //创建待发送的数据包裹</span><br><span class="line">       packet = new Packet(h, r, request, response, watchRegistration);</span><br><span class="line">       packet.cb = cb;</span><br><span class="line">       packet.ctx = ctx;</span><br><span class="line">       packet.clientPath = clientPath;</span><br><span class="line">       packet.serverPath = serverPath;</span><br><span class="line">       packet.watchDeregistration = watchDeregistration;</span><br><span class="line">       </span><br><span class="line">       synchronized (state) &#123;</span><br><span class="line">           if (!state.isAlive() || closing) &#123;</span><br><span class="line">           	//客户端已关闭或正在关闭，关闭包裹</span><br><span class="line">               conLossPacket(packet);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果发送的是关闭请求,更改正关闭状态为true</span><br><span class="line">               if (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                   closing = true;</span><br><span class="line">               &#125;</span><br><span class="line">               将数据包裹加入待发送队列</span><br><span class="line">               outgoingQueue.add(packet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //唤醒selector</span><br><span class="line">       sendThread.getClientCnxnSocket().packetAdded();</span><br><span class="line">       return packet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、SendThread类的readResponse方法"><a href="#4、SendThread类的readResponse方法" class="headerlink" title="4、SendThread类的readResponse方法"></a>4、SendThread类的readResponse方法</h4><h5 id="发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据"><a href="#发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据" class="headerlink" title="发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据"></a>发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">void readResponse(ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    ByteBufferInputStream bbis = new ByteBufferInputStream(</span><br><span class="line">            incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ReplyHeader replyHdr = new ReplyHeader();</span><br><span class="line"></span><br><span class="line">    replyHdr.deserialize(bbia, &quot;header&quot;);</span><br><span class="line">    //ping请求返回</span><br><span class="line">    if (replyHdr.getXid() == -2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //权限认证请求返回</span><br><span class="line">    if (replyHdr.getXid() == -4) &#123;</span><br><span class="line">        if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">            state = States.AUTH_FAILED;                    </span><br><span class="line">            eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, </span><br><span class="line">                    Watcher.Event.KeeperState.AuthFailed, null) );            		            		</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //客户端返回通知</span><br><span class="line">    if (replyHdr.getXid() == -1) &#123;</span><br><span class="line">        WatcherEvent event = new WatcherEvent();</span><br><span class="line">        event.deserialize(bbia, &quot;response&quot;);</span><br><span class="line"></span><br><span class="line">        //把event中的path转换为客户端path</span><br><span class="line">        if (chrootPath != null) &#123;</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            if(serverPath.compareTo(chrootPath)==0)</span><br><span class="line">                event.setPath(&quot;/&quot;);</span><br><span class="line">            else if (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            else &#123;</span><br><span class="line">            	LOG.warn(&quot;Got server path &quot; + event.getPath()</span><br><span class="line">            			+ &quot; which is too short for chroot path &quot;</span><br><span class="line">            			+ chrootPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WatchedEvent we = new WatchedEvent(event);</span><br><span class="line">        //添加事件，逻辑在（一、12）中</span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Packet packet;</span><br><span class="line">    synchronized (pendingQueue) &#123;</span><br><span class="line">        if (pendingQueue.size() == 0) &#123;</span><br><span class="line">            throw new IOException(&quot;Nothing in the queue, but got &quot;</span><br><span class="line">                    + replyHdr.getXid());</span><br><span class="line">        &#125;</span><br><span class="line">        //服务端已返回，从队列中删除该数据包</span><br><span class="line">        packet = pendingQueue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    //数据包裹按顺序处理，返回不一致则抛出异常</span><br><span class="line">    try &#123;</span><br><span class="line">        if (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">            packet.replyHeader.setErr(</span><br><span class="line">                    KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">            throw new IOException(&quot;Xid out of order. Got Xid &quot;</span><br><span class="line">                    + replyHdr.getXid() + &quot; with err &quot; +</span><br><span class="line">                    + replyHdr.getErr() +</span><br><span class="line">                    &quot; expected Xid &quot;</span><br><span class="line">                    + packet.requestHeader.getXid()</span><br><span class="line">                    + &quot; for a packet with details: &quot;</span><br><span class="line">                    + packet );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">        packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">        if (replyHdr.getZxid() &gt; 0) &#123;</span><br><span class="line">        	//更新最新处理事物id</span><br><span class="line">            lastZxid = replyHdr.getZxid();</span><br><span class="line">        &#125;</span><br><span class="line">        if (packet.response != null &amp;&amp; replyHdr.getErr() == 0) &#123;</span><br><span class="line">        	//序列化返回数据</span><br><span class="line">            packet.response.deserialize(bbia, &quot;response&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	//最终完成数据包处理</span><br><span class="line">        finishPacket(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、SendThread的finishPacket方法"><a href="#5、SendThread的finishPacket方法" class="headerlink" title="5、SendThread的finishPacket方法"></a>5、SendThread的finishPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void finishPacket(Packet p) &#123;</span><br><span class="line">       int err = p.replyHeader.getErr();</span><br><span class="line">       if (p.watchRegistration != null) &#123;</span><br><span class="line">       	//注册监听器到watchManager中</span><br><span class="line">           p.watchRegistration.register(err);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       数据包裹处理完成</span><br><span class="line">       if (p.cb == null) &#123;</span><br><span class="line">           synchronized (p) &#123;</span><br><span class="line">               p.finished = true;</span><br><span class="line">               p.notifyAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           p.finished = true;</span><br><span class="line">           eventThread.queuePacket(p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="到此create处理完成"><a href="#到此create处理完成" class="headerlink" title="到此create处理完成"></a>到此create处理完成</h5><h3 id="三、添加监听器过程"><a href="#三、添加监听器过程" class="headerlink" title="三、添加监听器过程"></a>三、添加监听器过程</h3><h4 id="1、以ZooKeepe类中的exists方法为例"><a href="#1、以ZooKeepe类中的exists方法为例" class="headerlink" title="1、以ZooKeepe类中的exists方法为例"></a>1、以ZooKeepe类中的exists方法为例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Stat exists(final String path, Watcher watcher)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath);</span><br><span class="line">       WatchRegistration wcb = null;</span><br><span class="line">       if (watcher != null) &#123;</span><br><span class="line">       	//新建Exist监听器注册器</span><br><span class="line">           wcb = new ExistsWatchRegistration(watcher, clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">       //实例化Exists请求</span><br><span class="line">       ExistsRequest request = new ExistsRequest();</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setWatch(watcher != null);</span><br><span class="line">       SetDataResponse response = new SetDataResponse();</span><br><span class="line">       //发送请求，见（二、2）</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           if (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return response.getStat().getCzxid() == -1 ? null : response.getStat();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ExistsWatchRegistration的register方法"><a href="#2、ExistsWatchRegistration的register方法" class="headerlink" title="2、ExistsWatchRegistration的register方法"></a>2、ExistsWatchRegistration的register方法</h4><h5 id="发送和接受请求与二中相同"><a href="#发送和接受请求与二中相同" class="headerlink" title="发送和接受请求与二中相同"></a>发送和接受请求与二中相同</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void register(int rc) &#123;</span><br><span class="line">       if (shouldAddWatch(rc)) &#123;</span><br><span class="line">           Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">           synchronized(watches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">               if (watchers == null) &#123;</span><br><span class="line">                   watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">                   watches.put(clientPath, watchers);</span><br><span class="line">               &#125;</span><br><span class="line">               watchers.add(watcher);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ExistsWatchRegistration的getWatches方法"><a href="#3、ExistsWatchRegistration的getWatches方法" class="headerlink" title="3、ExistsWatchRegistration的getWatches方法"></a>3、ExistsWatchRegistration的getWatches方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(int rc) &#123;</span><br><span class="line">   	//返回成功则注册到dataWatches，不存在则注册到existWatches中</span><br><span class="line">       return rc == 0 ?  watchManager.dataWatches : watchManager.existWatches;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="到此zookeeper客户端源码就介绍完了"><a href="#到此zookeeper客户端源码就介绍完了" class="headerlink" title="到此zookeeper客户端源码就介绍完了"></a>到此zookeeper客户端源码就介绍完了</h5>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>