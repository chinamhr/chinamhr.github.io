<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="一、ConcurrentHashMap1、实例化ConcurrentHashMapJDK1.8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树12345678910111213141516171819202122232425"/>
    

    <!--Author-->
    
        <meta name="author" content="小远"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="JUC集合(1)ConcurrentHashMap"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="一、ConcurrentHashMap1、实例化ConcurrentHashMapJDK1.8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树12345678910111213141516171819202122232425"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>JUC集合(1)ConcurrentHashMap - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Hexo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>JUC集合(1)ConcurrentHashMap</h1>
                    
                    <h2 class="post-subheading">
                        ConcurrentHashMap集合元素增删查及红黑树平衡的过程
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-05-06
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        

<a href="/categories/java-util-concurrent/">java.util.concurrent</a>

                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="一、ConcurrentHashMap"><a href="#一、ConcurrentHashMap" class="headerlink" title="一、ConcurrentHashMap"></a>一、ConcurrentHashMap</h3><h4 id="1、实例化ConcurrentHashMap"><a href="#1、实例化ConcurrentHashMap" class="headerlink" title="1、实例化ConcurrentHashMap"></a>1、实例化ConcurrentHashMap</h4><h5 id="JDK1-8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树"><a href="#JDK1-8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树" class="headerlink" title="JDK1.8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树"></a>JDK1.8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        //数组扩容的锁，在对象中的位置偏移</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">        //transferIndex扩容时处理到的数组下标值，在对象中的位置偏移。扩容时线程获取处理链表的锁</span><br><span class="line">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">        //元素的数量，在对象中的位置偏移</span><br><span class="line">        BASECOUNT = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">        //存放元素数量数组扩容锁，在对象中的位置偏移</span><br><span class="line">        CELLSBUSY = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">        Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        //存放的是部分元素的数量</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">            (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        //数组第一个元素相对于数组起始位置的偏移</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        //数组元素的大小</span><br><span class="line">        int scale = U.arrayIndexScale(ak);</span><br><span class="line">        if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">            throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">        ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ConcurrentHashMap的put方法"><a href="#2、ConcurrentHashMap的put方法" class="headerlink" title="2、ConcurrentHashMap的put方法"></a>2、ConcurrentHashMap的put方法</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ConcurrentHashMap的putVal方法"><a href="#3、ConcurrentHashMap的putVal方法" class="headerlink" title="3、ConcurrentHashMap的putVal方法"></a>3、ConcurrentHashMap的putVal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //获取key的hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            //节点数组不存在</span><br><span class="line">            //初始化节点数组</span><br><span class="line">            tab = initTable();</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //节点数组长度与key的hash值取模作为key在节点数组中的下标</span><br><span class="line">            //若数组该下标节点不存在，则用当前的key、value新建一个节点，添加进数组</span><br><span class="line">            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            //数组正在扩容</span><br><span class="line">            //参与到扩容中去</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            //数组该下标节点已存在，且有效</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //获取该节点的对象锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //数组该下标节点任然等于f，说明未被其他线程更改</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        //该节点hash值大于零，表示该节点仍为普通节点</span><br><span class="line">                        //该链表节点数</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //该节点key与添加的key相等</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                //是否允许覆盖</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                //将当前key、value新建节点，加入链表最后</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        //f节点为红黑树</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //往红黑树中添加该key、value</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                //链表元素超过8个</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    //重新设置数组长度或者将链表转换为红黑树</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //增加元素数量</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、ConcurrentHashMap的initTable方法"><a href="#4、ConcurrentHashMap的initTable方法" class="headerlink" title="4、ConcurrentHashMap的initTable方法"></a>4、ConcurrentHashMap的initTable方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    //table不存在</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            //其他线程已经在初始化，本线程进入待执行状态</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            //将sizeCtl改为-1，获取数组扩容锁</span><br><span class="line">            try &#123;</span><br><span class="line">                //table不存在，须初始化</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    //sc大于零说明实例化的时候给了数组的容量</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    //创建一个空数组，赋值给table</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（一、3）ConcurrentHashMap的helpTransfer方法"><a href="#5、接（一、3）ConcurrentHashMap的helpTransfer方法" class="headerlink" title="5、接（一、3）ConcurrentHashMap的helpTransfer方法"></a>5、接（一、3）ConcurrentHashMap的helpTransfer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    //正在扩容</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        //获取锁标志</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 表示数组初始化状态</span><br><span class="line">            //sc == rs + 1 表示数组扩容已完成</span><br><span class="line">            //sc == rs + MAX_RESIZERS 表示获取锁的线程已达到上限</span><br><span class="line">            //剩余条件均表示扩容已完成</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            //获取锁</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                //参与扩容</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（一、3）ConcurrentHashMap的treeifyBin方法"><a href="#6、接（一、3）ConcurrentHashMap的treeifyBin方法" class="headerlink" title="6、接（一、3）ConcurrentHashMap的treeifyBin方法"></a>6、接（一、3）ConcurrentHashMap的treeifyBin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            //数组长度未达到，最小转换红黑数的长度</span><br><span class="line">            //扩大数组容量</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            //b.hash大于等于零,b是普通节点</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line">                //节点b未发生改变</span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    //将b及之后的元素，加入一个TreeNode队列</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        //创建双向队列</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //把TreeNode队列加入TreeBin，并转换为红黑树，然后加入数组</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、ConcurrentHashMap的tryPresize方法"><a href="#7、ConcurrentHashMap的tryPresize方法" class="headerlink" title="7、ConcurrentHashMap的tryPresize方法"></a>7、ConcurrentHashMap的tryPresize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    //获取新数组的容量</span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    //锁未被获取</span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123;</span><br><span class="line">        //数组不存在</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            //获取锁</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //数组未改变，初始化数组</span><br><span class="line">                    if (table == tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        //无需扩容</span><br><span class="line">            break;</span><br><span class="line">        else if (tab == table) &#123;</span><br><span class="line">            //由数组长度，获取锁标志</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">            //锁已被获取</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 表示数组初始化状态</span><br><span class="line">                //sc == rs + 1 表示数组扩容已完成</span><br><span class="line">                //sc == rs + MAX_RESIZERS 表示获取锁的线程已达到上限</span><br><span class="line">                //剩余条件均表示扩容已完成</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                //获取锁，并参与到扩容中去</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">            //锁未被其他线程获取，并且本线程已获取到锁</span><br><span class="line">                //扩容数组</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、ConcurrentHashMap的transfer方法"><a href="#8、ConcurrentHashMap的transfer方法" class="headerlink" title="8、ConcurrentHashMap的transfer方法"></a>8、ConcurrentHashMap的transfer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    //stride线程一批处理数组中链表的个数</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    //扩容后的数组尚不存在，初始化</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    //扩容后数组的长度</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    //扩容数组时，替代老数组中的处理完的链表</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    //本批次是否处理完成</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    //数组扩容完成</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">            //本批次尚未处理完成，或已经全部处理完成</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">            //已没有可以处理的批次</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                //transferIndex当前处理到的数组下标</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">        //已处理完</span><br><span class="line">            int sc;</span><br><span class="line">            //全部处理完成</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                //更新table</span><br><span class="line">                table = nextTab;</span><br><span class="line">                //释放锁</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">            //释放一层锁</span><br><span class="line">                //表明尚有其他线程正在处理</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                //已全部处理完成</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">        //数组该位置未有元素</span><br><span class="line">            //设置老数组该位置元素为fwd</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">        //已处理</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //数组该位置未改变</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                    //f为普通节点</span><br><span class="line">                        //hash值&amp;n表示扩容后取模的值，是否增加n</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                //链表最后的元素</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //将原链表元素，重新分为两个链表</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //更新新数组元素</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //更新老数组元素</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                    //f为红黑树</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        //根据扩容后的数组长度与hash值取模的值，创建两个TreeNode队列</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //根据节点数量，判断构造红黑树，或者构造链表</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ConcurrentHashMap的untreeify方法"><a href="#9、ConcurrentHashMap的untreeify方法" class="headerlink" title="9、ConcurrentHashMap的untreeify方法"></a>9、ConcurrentHashMap的untreeify方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; Node&lt;K,V&gt; untreeify(Node&lt;K,V&gt; b) &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">    //创建链表</span><br><span class="line">    for (Node&lt;K,V&gt; q = b; q != null; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = new Node&lt;K,V&gt;(q.hash, q.key, q.val, null);</span><br><span class="line">        if (tl == null)</span><br><span class="line">            hd = p;</span><br><span class="line">        else</span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    return hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、接（一、3）ConcurrentHashMap的addCount方法"><a href="#10、接（一、3）ConcurrentHashMap的addCount方法" class="headerlink" title="10、接（一、3）ConcurrentHashMap的addCount方法"></a>10、接（一、3）ConcurrentHashMap的addCount方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    //默认用baseCount计数，如果并发争用失败，创建counterCells数组用于计数</span><br><span class="line">    if ((as = counterCells) != null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            //元素数量增加x</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">        //元素个数大于sizeCtl扩容数组</span><br><span class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、ConcurrentHashMap的fullAddCount方法"><a href="#11、ConcurrentHashMap的fullAddCount方法" class="headerlink" title="11、ConcurrentHashMap的fullAddCount方法"></a>11、ConcurrentHashMap的fullAddCount方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">private final void fullAddCount(long x, boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //获取一个随机数</span><br><span class="line">    if ((h = ThreadLocalRandom.getProbe()) == 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      // force initialization</span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide = false;                // True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; int n; long v;</span><br><span class="line">        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;</span><br><span class="line">        //counterCells数组存在</span><br><span class="line">            if ((a = as[(n - 1) &amp; h]) == null) &#123;</span><br><span class="line">            //该位置没有元素</span><br><span class="line">                if (cellsBusy == 0) &#123;            // Try to attach new Cell</span><br><span class="line">                //cellsBusy锁空闲</span><br><span class="line">                    //创建一个计数器</span><br><span class="line">                    CounterCell r = new CounterCell(x); // Optimistic create</span><br><span class="line">                    //获取锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                        boolean created = false;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            CounterCell[] rs; int m, j;</span><br><span class="line">                            if ((rs = counterCells) != null &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                                //添加进数组</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            //释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">            //增加元素数量，成功则跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            else if (cellsBusy == 0 &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">            //获取锁,counterCells数组扩容</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (counterCells == as) &#123;// Expand table unless stale</span><br><span class="line">                        CounterCell[] rs = new CounterCell[n &lt;&lt; 1];</span><br><span class="line">                        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            //获取下一个随机数</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">        //counterCells数组不存在，获取锁，初始化counterCells数组</span><br><span class="line">            boolean init = false;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                if (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = new CounterCell[2];</span><br><span class="line">                    //添加计数</span><br><span class="line">                    rs[h &amp; 1] = new CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">        //任然用baseCount计数</span><br><span class="line">            break;                          // Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、ConcurrentHashMap的get方法"><a href="#12、ConcurrentHashMap的get方法" class="headerlink" title="12、ConcurrentHashMap的get方法"></a>12、ConcurrentHashMap的get方法</h4><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    //获取hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //获取hash值对应的数组中的链表</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">            //正好在表头</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            //从ForwardingNode或红黑树中获取</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        //从链表中逐一查找</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、ForwardingNode的find方法"><a href="#13、ForwardingNode的find方法" class="headerlink" title="13、ForwardingNode的find方法"></a>13、ForwardingNode的find方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">    //从新数组里获取链表</span><br><span class="line">    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; int n;</span><br><span class="line">        if (k == null || tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">            //数组该索引位置为空</span><br><span class="line">            return null;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int eh; K ek;</span><br><span class="line">            if ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                //从链表中查找到</span><br><span class="line">                return e;</span><br><span class="line">            if (eh &lt; 0) &#123;</span><br><span class="line">                //再次扩容，从下个数组中查找</span><br><span class="line">                if (e instanceof ForwardingNode) &#123;</span><br><span class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                    continue outer;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    //从红黑树中查找</span><br><span class="line">                    return e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line">            if ((e = e.next) == null)</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、ConcurrentHashMap的remove方法"><a href="#14、ConcurrentHashMap的remove方法" class="headerlink" title="14、ConcurrentHashMap的remove方法"></a>14、ConcurrentHashMap的remove方法</h4><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    return replaceNode(key, null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、ConcurrentHashMap的replaceNode方法"><a href="#15、ConcurrentHashMap的replaceNode方法" class="headerlink" title="15、ConcurrentHashMap的replaceNode方法"></a>15、ConcurrentHashMap的replaceNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</span><br><span class="line">            //未找到该元素</span><br><span class="line">            break;</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            //正在扩容数组，帮助扩容</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            boolean validated = false;</span><br><span class="line">            //获取f的对象锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                    //正常节点</span><br><span class="line">                        validated = true;</span><br><span class="line">                        //遍历链表</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                if (cv == null || cv == ev ||</span><br><span class="line">                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    if (value != null)</span><br><span class="line">                                        //替换</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    else if (pred != null)</span><br><span class="line">                                        //删除</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    else</span><br><span class="line">                                        //删除</span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            if ((e = e.next) == null)</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                    //f为红黑树</span><br><span class="line">                        validated = true;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        //从红黑树中查找到该节点</span><br><span class="line">                        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            if (cv == null || cv == pv ||</span><br><span class="line">                                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                if (value != null)</span><br><span class="line">                                    //替换</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                else if (t.removeTreeNode(p))</span><br><span class="line">                                //红黑树删除该节点，并返回是否需要将红黑树转换回链表</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (validated) &#123;</span><br><span class="line">                if (oldVal != null) &#123;</span><br><span class="line">                    if (value == null)</span><br><span class="line">                        //数量减一</span><br><span class="line">                        addCount(-1L, -1);</span><br><span class="line">                    return oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、红黑树TreeBin"><a href="#二、红黑树TreeBin" class="headerlink" title="二、红黑树TreeBin"></a>二、红黑树TreeBin</h3><h4 id="1、实例化TreeBin"><a href="#1、实例化TreeBin" class="headerlink" title="1、实例化TreeBin"></a>1、实例化TreeBin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = TreeBin.class;</span><br><span class="line">        //根节点root锁的位置偏移</span><br><span class="line">        LOCKSTATE = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;lockState&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造红黑树"><a href="#构造红黑树" class="headerlink" title="构造红黑树"></a>构造红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    super(TREEBIN, null, null, null);</span><br><span class="line">    //红黑树中同时维护了一个双向队列</span><br><span class="line">    this.first = b;</span><br><span class="line">    TreeNode&lt;K,V&gt; r = null;</span><br><span class="line">    //逐个处理节点</span><br><span class="line">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = null;</span><br><span class="line">        if (r == null) &#123;</span><br><span class="line">        //尚未有根节点，当前节点设置为根节点</span><br><span class="line">            x.parent = null;</span><br><span class="line">            x.red = false;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            int h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = null;</span><br><span class="line">            //查找新增节点的父节点，并新增</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                int dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                //hash小的在左边，大的在右边</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir = 1;</span><br><span class="line">                else if ((kc == null &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                //先用比较器比较</span><br><span class="line">                    //先用类名比较，不成功则用内存地址比较</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                //找到新增节点应当添加的位置</span><br><span class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    //对象不等但无法区分大小,也存入左子结点</span><br><span class="line">                    if (dir &lt;= 0)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    //新增节点之后，平衡红黑树</span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root = r;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、TreeBin的balanceInsertion方法"><a href="#2、TreeBin的balanceInsertion方法" class="headerlink" title="2、TreeBin的balanceInsertion方法"></a>2、TreeBin的balanceInsertion方法</h4><h5 id="新增节点后，平衡红黑树"><a href="#新增节点后，平衡红黑树" class="headerlink" title="新增节点后，平衡红黑树"></a>新增节点后，平衡红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">    //新增节点默认红色</span><br><span class="line">    x.red = true;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        if ((xp = x.parent) == null) &#123;</span><br><span class="line">        //新增节点为根节点，直接染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">        //父节点为黑色，或者父节点为根节点，无须处理</span><br><span class="line">            return root;</span><br><span class="line">        if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">        //新增节点的父节点为左子结点</span><br><span class="line">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">            //新增节点的父节点的兄弟节点为红色</span><br><span class="line">            //已知父节点为红色，将父节点和叔叔节点同时设置为黑色，</span><br><span class="line">            //把爷爷节点染红，当成新增节点继续处理</span><br><span class="line">                xppr.red = false;</span><br><span class="line">                xp.red = false;</span><br><span class="line">                xpp.red = true;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">            //叔叔节点为黑色</span><br><span class="line">                if (x == xp.right) &#123;</span><br><span class="line">                //新增节点为右子节点</span><br><span class="line">                    //将父节点当成新增节点，并左旋</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    //我觉得x.parent不会出现null？？</span><br><span class="line">                    xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                //父节点和爷爷节点互换颜色</span><br><span class="line">                //右旋爷爷节点</span><br><span class="line">                if (xp != null) &#123;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    if (xpp != null) &#123;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        //新增节点的父节点为右子结点，处理过程与之前对称</span><br><span class="line">            if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = false;</span><br><span class="line">                xp.red = false;</span><br><span class="line">                xpp.red = true;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                if (xp != null) &#123;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    if (xpp != null) &#123;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、TreeBin的putTreeVal方法"><a href="#3、TreeBin的putTreeVal方法" class="headerlink" title="3、TreeBin的putTreeVal方法"></a>3、TreeBin的putTreeVal方法</h4><h5 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">    Class&lt;?&gt; kc = null;</span><br><span class="line">    boolean searched = false;</span><br><span class="line">    //查找新增节点的父节点，并新增</span><br><span class="line">    for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        int dir, ph; K pk;</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            //红黑树尚未有节点，新增节点为第一个节点</span><br><span class="line">            first = root = new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -1;</span><br><span class="line">        else if (ph &lt; h)</span><br><span class="line">            dir = 1;</span><br><span class="line">        else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">            //已存在该节点</span><br><span class="line">            return p;</span><br><span class="line">        else if ((kc == null &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">            //查找红黑树中是否已存在key</span><br><span class="line">            if (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = true;</span><br><span class="line">                if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != null) ||</span><br><span class="line">                    ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != null))</span><br><span class="line">                    return q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        //找到新增节点的父节点</span><br><span class="line">        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            //创建新节点，放在队首</span><br><span class="line">            first = x = new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">            if (f != null)</span><br><span class="line">                f.prev = x;</span><br><span class="line">            if (dir &lt;= 0)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            else</span><br><span class="line">                xp.right = x;</span><br><span class="line">            if (!xp.red)</span><br><span class="line">                //新增节点默认为红色</span><br><span class="line">                x.red = true;</span><br><span class="line">            else &#123;</span><br><span class="line">                //获取根节点锁</span><br><span class="line">                lockRoot();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //新增后，平衡红黑树</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、TreeBin的lockRoot方法"><a href="#4、TreeBin的lockRoot方法" class="headerlink" title="4、TreeBin的lockRoot方法"></a>4、TreeBin的lockRoot方法</h4><h5 id="获取根节点锁"><a href="#获取根节点锁" class="headerlink" title="获取根节点锁"></a>获取根节点锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final void lockRoot() &#123;</span><br><span class="line">    //获取写锁</span><br><span class="line">    if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))</span><br><span class="line">        //获取失败，进入等待</span><br><span class="line">        contendedLock(); // offload to separate method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、TreeBin的contendedLock方法"><a href="#5、TreeBin的contendedLock方法" class="headerlink" title="5、TreeBin的contendedLock方法"></a>5、TreeBin的contendedLock方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final void contendedLock() &#123;</span><br><span class="line">    boolean waiting = false;</span><br><span class="line">    for (int s;;) &#123;</span><br><span class="line">        if (((s = lockState) &amp; ~WAITER) == 0) &#123;</span><br><span class="line">        //锁未被获取，读和写均未被获取</span><br><span class="line">            //获取写锁</span><br><span class="line">            if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line">                if (waiting)</span><br><span class="line">                    waiter = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((s &amp; WAITER) == 0) &#123;</span><br><span class="line">        //没有等待线程</span><br><span class="line">            //获取等待锁</span><br><span class="line">            if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) &#123;</span><br><span class="line">                waiting = true;</span><br><span class="line">                waiter = Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (waiting)</span><br><span class="line">            //阻塞线程</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、TreeBin的unlockRoot方法"><a href="#6、TreeBin的unlockRoot方法" class="headerlink" title="6、TreeBin的unlockRoot方法"></a>6、TreeBin的unlockRoot方法</h4><h5 id="释放根节点锁"><a href="#释放根节点锁" class="headerlink" title="释放根节点锁"></a>释放根节点锁</h5><h5 id="写操作时，会锁整个节点，因此不会存在线程等待些操作，而读操作在这种情况下会直接查找队列，因此不会存在等待线程"><a href="#写操作时，会锁整个节点，因此不会存在线程等待些操作，而读操作在这种情况下会直接查找队列，因此不会存在等待线程" class="headerlink" title="写操作时，会锁整个节点，因此不会存在线程等待些操作，而读操作在这种情况下会直接查找队列，因此不会存在等待线程"></a>写操作时，会锁整个节点，因此不会存在线程等待些操作，而读操作在这种情况下会直接查找队列，因此不会存在等待线程</h5><h5 id="读操作时，可能会存在线程等待写操作"><a href="#读操作时，可能会存在线程等待写操作" class="headerlink" title="读操作时，可能会存在线程等待写操作"></a>读操作时，可能会存在线程等待写操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final void unlockRoot() &#123;</span><br><span class="line">    lockState = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、TreeBin的find方法"><a href="#7、TreeBin的find方法" class="headerlink" title="7、TreeBin的find方法"></a>7、TreeBin的find方法</h4><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        for (Node&lt;K,V&gt; e = first; e != null; ) &#123;</span><br><span class="line">            int s; K ek;</span><br><span class="line">            if (((s = lockState) &amp; (WAITER|WRITER)) != 0) &#123;</span><br><span class="line">            //根节点锁，已被获取，从队列中查找</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">            //获取读锁</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //从红黑树中查找</span><br><span class="line">                    p = ((r = root) == null ? null :</span><br><span class="line">                         r.findTreeNode(h, k, null));</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Thread w;</span><br><span class="line">                    //释放读锁，若完全释放读锁，且存在等待线程，则唤醒等待线程</span><br><span class="line">                    if (U.getAndAddInt(this, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != null)</span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、TreeBin的findTreeNode方法"><a href="#8、TreeBin的findTreeNode方法" class="headerlink" title="8、TreeBin的findTreeNode方法"></a>8、TreeBin的findTreeNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">        do  &#123;</span><br><span class="line">            int ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">            if ((ph = p.hash) &gt; h)</span><br><span class="line">            //往左查找</span><br><span class="line">                p = pl;</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">            //往右查找</span><br><span class="line">                p = pr;</span><br><span class="line">            else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">            //已找到</span><br><span class="line">                return p;</span><br><span class="line">            else if (pl == null)</span><br><span class="line">                p = pr;</span><br><span class="line">            else if (pr == null)</span><br><span class="line">                p = pl;</span><br><span class="line">            else if ((kc != null ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">            //hash值相等，对象不相等，进一步比较</span><br><span class="line">                p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">            else if ((q = pr.findTreeNode(h, k, kc)) != null)</span><br><span class="line">                //对象不等但无法区分大小，向右查找</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; while (p != null);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、TreeBin的removeTreeNode方法"><a href="#9、TreeBin的removeTreeNode方法" class="headerlink" title="9、TreeBin的removeTreeNode方法"></a>9、TreeBin的removeTreeNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">final boolean removeTreeNode(TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; next = (TreeNode&lt;K,V&gt;)p.next;</span><br><span class="line">    TreeNode&lt;K,V&gt; pred = p.prev;  // unlink traversal pointers</span><br><span class="line">    TreeNode&lt;K,V&gt; r, rl;</span><br><span class="line">    if (pred == null)</span><br><span class="line">    //删除的是队首</span><br><span class="line">        first = next;</span><br><span class="line">    else</span><br><span class="line">        pred.next = next;</span><br><span class="line">    if (next != null)</span><br><span class="line">        next.prev = pred;</span><br><span class="line">    //删除了最后一个节点</span><br><span class="line">    if (first == null) &#123;</span><br><span class="line">        root = null;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //节点过少</span><br><span class="line">    if ((r = root) == null || r.right == null || // too small</span><br><span class="line">        (rl = r.left) == null || rl.left == null)</span><br><span class="line">        return true;</span><br><span class="line">    //获取根节点锁</span><br><span class="line">    lockRoot();</span><br><span class="line">    try &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; replacement;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left;</span><br><span class="line">        TreeNode&lt;K,V&gt; pr = p.right;</span><br><span class="line">        if (pl != null &amp;&amp; pr != null) &#123;</span><br><span class="line">        //待删除节点有两个子节点</span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            //找到后继节点</span><br><span class="line">            while ((sl = s.left) != null) // find successor</span><br><span class="line">                s = sl;</span><br><span class="line">            //交换节点颜色</span><br><span class="line">            boolean c = s.red; s.red = p.red; p.red = c; // swap colors</span><br><span class="line">            //交换节点位置</span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            if (s == pr) &#123; // p was s&apos;s direct parent</span><br><span class="line">            //后继节点刚好为删除节点的右子节点</span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                if ((p.parent = sp) != null) &#123;</span><br><span class="line">                    if (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    else</span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((s.right = pr) != null)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left = null;</span><br><span class="line">            if ((p.right = sr) != null)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            if ((s.left = pl) != null)</span><br><span class="line">                pl.parent = s;</span><br><span class="line">            if ((s.parent = pp) == null)</span><br><span class="line">                r = s;</span><br><span class="line">            else if (p == pp.left)</span><br><span class="line">                pp.left = s;</span><br><span class="line">            else</span><br><span class="line">                pp.right = s;</span><br><span class="line">            //删除后的替代节点</span><br><span class="line">            if (sr != null)</span><br><span class="line">                replacement = sr;</span><br><span class="line">            else</span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pl != null)</span><br><span class="line">        //待删除节点只有左子结点</span><br><span class="line">            replacement = pl;</span><br><span class="line">        else if (pr != null)</span><br><span class="line">        //待删除节点只有右子结点</span><br><span class="line">            replacement = pr;</span><br><span class="line">        else</span><br><span class="line">        //待删除节点没有子结点</span><br><span class="line">            replacement = p;</span><br><span class="line">        if (replacement != p) &#123;</span><br><span class="line">        //删除后，替代操作</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            if (pp == null)</span><br><span class="line">                r = replacement;</span><br><span class="line">            else if (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            else</span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除节点为红色则不处理，否则平衡红黑树</span><br><span class="line">        root = (p.red) ? r : balanceDeletion(r, replacement);</span><br><span class="line">        //无替代节点</span><br><span class="line">        if (p == replacement) &#123;  // detach pointers</span><br><span class="line">            TreeNode&lt;K,V&gt; pp;</span><br><span class="line">            if ((pp = p.parent) != null) &#123;</span><br><span class="line">                if (p == pp.left)</span><br><span class="line">                    pp.left = null;</span><br><span class="line">                else if (p == pp.right)</span><br><span class="line">                    pp.right = null;</span><br><span class="line">                p.parent = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        unlockRoot();</span><br><span class="line">    &#125;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、TreeBin的balanceDeletion方法"><a href="#10、TreeBin的balanceDeletion方法" class="headerlink" title="10、TreeBin的balanceDeletion方法"></a>10、TreeBin的balanceDeletion方法</h4><h5 id="删除节点后，平衡红黑树"><a href="#删除节点后，平衡红黑树" class="headerlink" title="删除节点后，平衡红黑树"></a>删除节点后，平衡红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        if (x == null || x == root)</span><br><span class="line">            //x迭代到根节点</span><br><span class="line">            return root;</span><br><span class="line">        else if ((xp = x.parent) == null) &#123;</span><br><span class="line">            //x迭代到根节点，染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x.red) &#123;</span><br><span class="line">            //新x节点为红色，直接染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((xpl = xp.left) == x) &#123;</span><br><span class="line">        //删除节点为左子节点</span><br><span class="line">            //兄弟节点为红色</span><br><span class="line">            //兄弟节点和父节点互换颜色，左旋父节点</span><br><span class="line">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = false;</span><br><span class="line">                xp.red = true;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                //更新兄弟节点</span><br><span class="line">                xpr = (xp = x.parent) == null ? null : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (xpr == null)</span><br><span class="line">            //兄弟节点不可能为null？？？</span><br><span class="line">                x = xp;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                if ((sr == null || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == null || !sl.red)) &#123;</span><br><span class="line">                    //兄弟节点为黑色，兄弟节点的子节点都为黑色</span><br><span class="line">                    //染红兄弟节点，将父节点作为新的x节点,继续迭代</span><br><span class="line">                    xpr.red = true;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //兄弟节点的右子节点为黑色，左子节点为红色</span><br><span class="line">                    //兄弟节点与左子节点互换颜色，右旋兄弟节点</span><br><span class="line">                    if (sr == null || !sr.red) &#123;</span><br><span class="line">                        if (sl != null)</span><br><span class="line">                            sl.red = false;</span><br><span class="line">                        xpr.red = true;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == null ?</span><br><span class="line">                            null : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //兄弟节点的右子节点为红色，左子节点随意</span><br><span class="line">                    //兄弟节点和父节点互换颜色，左旋父节点，染黑兄弟节点的右子节点</span><br><span class="line">                    if (xpr != null) &#123;</span><br><span class="line">                        xpr.red = (xp == null) ? false : xp.red;</span><br><span class="line">                        if ((sr = xpr.right) != null)</span><br><span class="line">                            sr.red = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; </span><br><span class="line">        //删除节点为右子节点，与之前对称</span><br><span class="line">            if (xpl != null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = false;</span><br><span class="line">                xp.red = true;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == null ? null : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (xpl == null)</span><br><span class="line">                x = xp;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                if ((sl == null || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == null || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = true;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (sl == null || !sl.red) &#123;</span><br><span class="line">                        if (sr != null)</span><br><span class="line">                            sr.red = false;</span><br><span class="line">                        xpl.red = true;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == null ?</span><br><span class="line">                            null : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpl != null) &#123;</span><br><span class="line">                        xpl.red = (xp == null) ? false : xp.red;</span><br><span class="line">                        if ((sl = xpl.left) != null)</span><br><span class="line">                            sl.red = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、TreeBin的rotateLeft方法"><a href="#11、TreeBin的rotateLeft方法" class="headerlink" title="11、TreeBin的rotateLeft方法"></a>11、TreeBin的rotateLeft方法</h4><h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                          TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">        if ((rl = p.right = r.left) != null)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        if ((pp = r.parent = p.parent) == null)</span><br><span class="line">            (root = r).red = false;</span><br><span class="line">        else if (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        else</span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、TreeBin的rotateRight方法"><a href="#12、TreeBin的rotateRight方法" class="headerlink" title="12、TreeBin的rotateRight方法"></a>12、TreeBin的rotateRight方法</h4><h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">        if ((lr = p.left = l.right) != null)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        if ((pp = l.parent = p.parent) == null)</span><br><span class="line">            (root = l).red = false;</span><br><span class="line">        else if (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        else</span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/chinamhr/chinamhr.github.io" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 小远<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>