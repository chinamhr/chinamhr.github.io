<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JUC锁 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JUC锁一、独占锁ReentrantLock1、实例化ReentrantLockAbstractQueuedSynchronizer的静态代码块12345678910111213141516171819static &amp;#123;    try &amp;#123;        //锁状态state字段，在AbstractQueuedSynchronizer对象中的地址偏移        stateOff">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC锁">
<meta property="og:url" content="http://yoursite.com/2018/05/06/JUC源码/JUC锁/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC锁一、独占锁ReentrantLock1、实例化ReentrantLockAbstractQueuedSynchronizer的静态代码块12345678910111213141516171819static &amp;#123;    try &amp;#123;        //锁状态state字段，在AbstractQueuedSynchronizer对象中的地址偏移        stateOff">
<meta property="og:updated_time" content="2018-04-25T11:56:02.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JUC锁">
<meta name="twitter:description" content="JUC锁一、独占锁ReentrantLock1、实例化ReentrantLockAbstractQueuedSynchronizer的静态代码块12345678910111213141516171819static &amp;#123;    try &amp;#123;        //锁状态state字段，在AbstractQueuedSynchronizer对象中的地址偏移        stateOff">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JUC源码/JUC锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/JUC源码/JUC锁/" class="article-date">
  <time datetime="2018-05-06T13:48:30.182Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java-util-concurrent/">java.util.concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JUC锁
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JUC锁"><a href="#JUC锁" class="headerlink" title="JUC锁"></a>JUC锁</h2><h3 id="一、独占锁ReentrantLock"><a href="#一、独占锁ReentrantLock" class="headerlink" title="一、独占锁ReentrantLock"></a>一、独占锁ReentrantLock</h3><h4 id="1、实例化ReentrantLock"><a href="#1、实例化ReentrantLock" class="headerlink" title="1、实例化ReentrantLock"></a>1、实例化ReentrantLock</h4><p>AbstractQueuedSynchronizer的静态代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //锁状态state字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        //CLH队首head字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">        //CLH队尾head字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">        //节点状态waitStatus字段,在Node对象中的位置偏移</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">        //后继节点next字段,在Node对象中的位置偏移</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    //默认非公平锁</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ReentrantLock的lock方法"><a href="#2、ReentrantLock的lock方法" class="headerlink" title="2、ReentrantLock的lock方法"></a>2、ReentrantLock的lock方法</h4><p>lock方法获取锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、NonfairSync的lock方法"><a href="#3、NonfairSync的lock方法" class="headerlink" title="3、NonfairSync的lock方法"></a>3、NonfairSync的lock方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    //锁状态state为0则表示锁空闲,state&gt;0则表示锁已被获取</span><br><span class="line">    //将state状态由0改为1</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        //成功则，设置锁的拥有线程为当前线程</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        //不成功，说明锁状态不为0，已被其他线程获取，则继续获取锁</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、AbstractQueuedSynchronizer的acquire方法"><a href="#4、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="4、AbstractQueuedSynchronizer的acquire方法"></a>4、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //尝试获取锁，失败则将线程加入等待队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        //acquireQueued会返回本线程是否中断</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、NonfairSync的tryAcquire方法"><a href="#5、NonfairSync的tryAcquire方法" class="headerlink" title="5、NonfairSync的tryAcquire方法"></a>5、NonfairSync的tryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //尝试获取非公平锁</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、Sync的nonfairTryAcquire方法"><a href="#6、Sync的nonfairTryAcquire方法" class="headerlink" title="6、Sync的nonfairTryAcquire方法"></a>6、Sync的nonfairTryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    //获取state值</span><br><span class="line">    int c = getState();</span><br><span class="line">    //锁状态为0，锁空闲</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //更改锁状态，成功则返回true</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        //锁已被本线程获取</span><br><span class="line">        //本线程再次获取锁</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //更新锁状态</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、接（一、4）Node的addWaiter方法"><a href="#7、接（一、4）Node的addWaiter方法" class="headerlink" title="7、接（一、4）Node的addWaiter方法"></a>7、接（一、4）Node的addWaiter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    //获取队尾节点</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    //tail节点存在，则CLH队列不为空，则将“当前线程”添加到CLH队列末尾</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        //设置本节点的上个节点为队尾节点</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        //将本节点设置为队尾，成功则返回节点，失败则认为队尾已变更，本次操作失败</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、Node的enq方法"><a href="#8、Node的enq方法" class="headerlink" title="8、Node的enq方法"></a>8、Node的enq方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">        //队尾不存在，说明队列尚未建立</span><br><span class="line">            //创建一个空节点作为头节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                //成功则将尾节点也设置为当前节点</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //队列已建立</span><br><span class="line">            //操作与上个方法相同，成功则返回，不成功则重新循环</span><br><span class="line">            //头节点的前一个节点，是尾节点</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法"><a href="#9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法" class="headerlink" title="9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法"></a>9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // interrupted表示在CLH队列的调度中，</span><br><span class="line">        // “当前线程”在休眠时，有没有被中断过。</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取上一个节点。</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //若p为头节点，则尝试获取锁</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //设置当前节点为头节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程应阻塞，则阻塞当前线程</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //取消本节点</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法"><a href="#10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法" class="headerlink" title="10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法"></a>10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    // 前继节点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        //前继节点的后继节点，在前继节点释放或取消时，需要唤醒后继节点</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">         // 如果前继节点是前取消状态，则设置当前节点的前继节点为原前继节点的前继节点。</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果前继节点为0或者共享锁状态，则设置前继节点为SIGNAL状态。</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitStatus的状态如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CANCELLED[1]  -- 当前线程已被取消</span><br><span class="line">SIGNAL[-1]    -- “当前线程的后继线程需要被unpark(唤醒)”。</span><br><span class="line">    一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。</span><br><span class="line">CONDITION[-2] -- 当前线程(处在Condition休眠状态)在等待Condition唤醒</span><br><span class="line">PROPAGATE[-3] -- (共享锁)其它线程获取到“共享锁”</span><br><span class="line">[0]           -- 当前线程不属于上面的任何一种状态。</span><br></pre></td></tr></table></figure></p>
<h4 id="11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法"><a href="#11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法" class="headerlink" title="11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法"></a>11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    // 通过LockSupport的park()阻塞“当前线程”。</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    // 返回线程的中断状态。</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法"><a href="#12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法" class="headerlink" title="12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法"></a>12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    // Ignore if node doesn&apos;t exist</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    //清空node对应的线程</span><br><span class="line">    node.thread = null;</span><br><span class="line">    //获取前继节点</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    // 如果前继节点是前取消状态，则设置当前节点的前继节点为原前继节点的前继节点。</span><br><span class="line">    while (pred.waitStatus &gt; 0)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    //获取前继节点的后继节点</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    //设置当前节点状态为取消</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        //当前节点为队尾，设置队尾为前继节点</span><br><span class="line">        //设置前继节点的后继节点为null</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        //前继节点不为头节点，设置前继节点状态为SIGNAL</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            //后继节点存在且未取消</span><br><span class="line">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                //设置前继节点的后继节点为当前节点的后继节点</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //唤醒后继节点</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; // help GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、AbstractQueuedSynchronizer的unparkSuccessor方法"><a href="#13、AbstractQueuedSynchronizer的unparkSuccessor方法" class="headerlink" title="13、AbstractQueuedSynchronizer的unparkSuccessor方法"></a>13、AbstractQueuedSynchronizer的unparkSuccessor方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    //获取节点状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果状态&lt;0，则设置状态=0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    // 获取当前节点的有效的后继节点，无效的话，则通过for循环进行获取。</span><br><span class="line">    // 这里的有效，是指后继节点对应的线程状态&lt;=0</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        //从队尾往前查找</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒后继节点对应的线程</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、ReentrantLock的unlock方法"><a href="#14、ReentrantLock的unlock方法" class="headerlink" title="14、ReentrantLock的unlock方法"></a>14、ReentrantLock的unlock方法</h4><p>unlock释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15、NonfairSync的release方法"><a href="#15、NonfairSync的release方法" class="headerlink" title="15、NonfairSync的release方法"></a>15、NonfairSync的release方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点存在，且有效</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            //唤醒头节点的后继节点</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、Sync的tryRelease方法"><a href="#16、Sync的tryRelease方法" class="headerlink" title="16、Sync的tryRelease方法"></a>16、Sync的tryRelease方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //释放一层锁</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //c为零表示完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //更新锁状态</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、公平锁"><a href="#二、公平锁" class="headerlink" title="二、公平锁"></a>二、公平锁</h3><h4 id="1、实例化ReentrantLock-1"><a href="#1、实例化ReentrantLock-1" class="headerlink" title="1、实例化ReentrantLock"></a>1、实例化ReentrantLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、FairSync的lock方法"><a href="#2、FairSync的lock方法" class="headerlink" title="2、FairSync的lock方法"></a>2、FairSync的lock方法</h4><p>公平锁   – 公平锁的lock()函数，会直接调用acquire(1)。<br>非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、AbstractQueuedSynchronizer的acquire方法"><a href="#3、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquire方法"></a>3、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //尝试获取锁，失败则将线程加入等待队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        //acquireQueued会返回本线程是否中断</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、FairSync的tryAcquire方法"><a href="#4、FairSync的tryAcquire方法" class="headerlink" title="4、FairSync的tryAcquire方法"></a>4、FairSync的tryAcquire方法</h4><p>公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。<br>非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //锁空闲，首先查看等待队列是否有线程等待，无线程等待或队首节点的后继节点是本线程，</span><br><span class="line">        //再去获取锁，否则获取失败</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、Condition条件"><a href="#三、Condition条件" class="headerlink" title="三、Condition条件"></a>三、Condition条件</h3><h4 id="1、ReentrantLock的newCondition方法"><a href="#1、ReentrantLock的newCondition方法" class="headerlink" title="1、ReentrantLock的newCondition方法"></a>1、ReentrantLock的newCondition方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject newCondition() &#123;</span><br><span class="line">    return new ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ConditionObject的await方法"><a href="#2、ConditionObject的await方法" class="headerlink" title="2、ConditionObject的await方法"></a>2、ConditionObject的await方法</h4><p>线程等待<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //往该条件等待队列队尾，添加一个等待线程节点</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    //完全释放锁</span><br><span class="line">    long savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    //检查该节点是否在CLH队列中，不在则阻塞该线程。条件等待队列和CLH队列是两个不同的队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        //检查线程中断，线程中断时，在条件等待队列中返回（THROW_IE），</span><br><span class="line">        //线程中断时不在条件等待队列中返回REINTERRUPT,线程未中断返回0</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    //node在CLH队列中重新获取锁</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    //该节点的条件等待队列后继节点为空</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        //去除队列里的无效节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        //THROW_IE中断则抛出异常，REINTERRUPT设置本线程中断标记</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、ConditionObject的addConditionWaiter方法"><a href="#3、ConditionObject的addConditionWaiter方法" class="headerlink" title="3、ConditionObject的addConditionWaiter方法"></a>3、ConditionObject的addConditionWaiter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    //队尾节点无效</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        //去除队列里的无效节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        //获取队尾节点</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    //本线程新建节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        //队尾节点不存在，说明队列尚不存在，设置队首为本节点</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        //否则设置队尾节点的后继节点为本节点</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    //设置队尾节点为本节点</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、ConditionObject的unlinkCancelledWaiters方法"><a href="#4、ConditionObject的unlinkCancelledWaiters方法" class="headerlink" title="4、ConditionObject的unlinkCancelledWaiters方法"></a>4、ConditionObject的unlinkCancelledWaiters方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    //当前处理节点</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    //当前处理节点的前一个节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            //t节点无效</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                //当前节点不存在前继节点</span><br><span class="line">                //设置队首为后继节点</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                //设置前继节点的后继节点为next</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                //next不存在设置trail为队尾</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            //当前节点有效，上一个节点设置为当前节点</span><br><span class="line">            trail = t;</span><br><span class="line">        //设置当前节点为当前节点的后一个节点</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法"><a href="#5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法" class="headerlink" title="5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法"></a>5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    //当前处理节点</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    //当前处理节点的前一个节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            //t节点无效</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                //当前节点不存在前继节点</span><br><span class="line">                //设置队首为后继节点</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                //设置前继节点的后继节点为next</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                //next不存在设置trail为队尾</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            //当前节点有效，上一个节点设置为当前节点</span><br><span class="line">            trail = t;</span><br><span class="line">        //设置当前节点为当前节点的后一个节点</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、ConditionObject的signal方法"><a href="#6、ConditionObject的signal方法" class="headerlink" title="6、ConditionObject的signal方法"></a>6、ConditionObject的signal方法</h4><p>按顺序唤醒该条件等待的一个线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //拥有该锁的线程必须是本线程</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        //唤醒队首</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、ConditionObject的doSignal方法"><a href="#7、ConditionObject的doSignal方法" class="headerlink" title="7、ConditionObject的doSignal方法"></a>7、ConditionObject的doSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //firstWaiter的后继节点等于null,设置队首队尾为null</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">        //节点加入CLH队列，失败则处理下一个</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、ConditionObject的transferForSignal方法"><a href="#8、ConditionObject的transferForSignal方法" class="headerlink" title="8、ConditionObject的transferForSignal方法"></a>8、ConditionObject的transferForSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //设置该节点状态为0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line">    //将该节点加入CLH队列，返回原队尾</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //设置该节点前继节点的状态为SIGNAL</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        //设置失败，唤醒该线程</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ConditionObject的signalAll方法"><a href="#9、ConditionObject的signalAll方法" class="headerlink" title="9、ConditionObject的signalAll方法"></a>9、ConditionObject的signalAll方法</h4><p>唤醒该条件等待的所有线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public final void signalAll() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        //唤醒所有等待的线程</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10、ConditionObject的doSignal方法"><a href="#10、ConditionObject的doSignal方法" class="headerlink" title="10、ConditionObject的doSignal方法"></a>10、ConditionObject的doSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doSignalAll(Node first) &#123;</span><br><span class="line">    //清空队列</span><br><span class="line">    lastWaiter = firstWaiter = null;</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">        //依次将节点加入CLH队列</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; while (first != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、读写锁ReentrantReadWriteLock"><a href="#四、读写锁ReentrantReadWriteLock" class="headerlink" title="四、读写锁ReentrantReadWriteLock"></a>四、读写锁ReentrantReadWriteLock</h3><h4 id="1、实例化ReentrantReadWriteLock"><a href="#1、实例化ReentrantReadWriteLock" class="headerlink" title="1、实例化ReentrantReadWriteLock"></a>1、实例化ReentrantReadWriteLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock() &#123;</span><br><span class="line">    this(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">    //默认使用非公平锁</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    //读锁</span><br><span class="line">    readerLock = new ReadLock(this);</span><br><span class="line">    //写锁</span><br><span class="line">    writerLock = new WriteLock(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、ReadLock的lock方法"><a href="#2、ReadLock的lock方法" class="headerlink" title="2、ReadLock的lock方法"></a>2、ReadLock的lock方法</h4><p>获取读锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、AbstractQueuedSynchronizer的acquireShared方法"><a href="#3、AbstractQueuedSynchronizer的acquireShared方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireShared方法"></a>3、AbstractQueuedSynchronizer的acquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //尝试获取共享锁</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //失败则将线程加入等待队列</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、Sync的tryAcquireShared方法"><a href="#4、Sync的tryAcquireShared方法" class="headerlink" title="4、Sync的tryAcquireShared方法"></a>4、Sync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    //获取锁状态,默认左16位为共享锁（读锁）使用，右16位为独占锁（写锁）使用</span><br><span class="line">    int c = getState();</span><br><span class="line">    //独占锁且拥有者不是当前线程，获取失败，返回-1</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line">    //c右移去除独占锁部分</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    //readerShouldBlock 非公平锁(如果队首存在且为独占锁，则返回true)</span><br><span class="line">    //                  公平锁(如果队首存在且不为当前线程，则返回true)</span><br><span class="line">    //MAX_COUNT 共享锁最大共享线程数</span><br><span class="line">    //compareAndSetState 获取锁</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp; </span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">            //第一次获取共享锁</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123;</span><br><span class="line">            //第一个获取共享锁的线程,但不是第一次获取</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // HoldCounter是用来统计该线程获取“读取锁”的次数。</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            //线程获取锁的次数加一</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、Sync的fullTryAcquireShared方法"><a href="#5、Sync的fullTryAcquireShared方法" class="headerlink" title="5、Sync的fullTryAcquireShared方法"></a>5、Sync的fullTryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh = null;</span><br><span class="line">    //不停获取锁，直到成功，或者不能获取</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            //独占锁</span><br><span class="line">            //拥有者不是当前线程，获取失败，返回-1</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            //队首存在且为独占锁，则新线程不可再获取读锁</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //若线程未获取到锁，清除rh</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //新线程不可再获取读锁</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取共享锁线程，超过最大数量限制</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //获取锁，与上个方法相同</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; // cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法"><a href="#6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法" class="headerlink" title="6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法"></a>6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    //创建共享锁节点，并添加到队列中去</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取前继节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //说明本节点为队首</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //再次获取共享锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //获取共享锁成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    //头节点标记为当前节点，清空当前节点，</span><br><span class="line">                    //后继节点为共享锁，则唤醒后继节点,</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        //中断本线程</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程应阻塞，则阻塞当前线程，与（一、9）相同</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //取消本节点，与（一、12）相同</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、WriteLock的lock方法"><a href="#7、WriteLock的lock方法" class="headerlink" title="7、WriteLock的lock方法"></a>7、WriteLock的lock方法</h4><p>获取写锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="8、AbstractQueuedSynchronizer的acquire方法"><a href="#8、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="8、AbstractQueuedSynchronizer的acquire方法"></a>8、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //tryAcquire尝试获取独占锁，其余方法与之前相同。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、Sync的tryAcquire方法"><a href="#9、Sync的tryAcquire方法" class="headerlink" title="9、Sync的tryAcquire方法"></a>9、Sync的tryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        //获取独占锁状态</span><br><span class="line">        int w = exclusiveCount(c);</span><br><span class="line">        //锁已被获取</span><br><span class="line">        if (c != 0) &#123;</span><br><span class="line">            //共享锁或者获取独占锁的不是本线程，返回失败</span><br><span class="line">            if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                return false;</span><br><span class="line">            //独占锁获取次数大于最大次数</span><br><span class="line">            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            //更新锁状态</span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //writerShouldBlock永远返回false</span><br><span class="line">        //尝试获取独占锁</span><br><span class="line">        if (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            return false;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、ReadLock的unlock方法"><a href="#10、ReadLock的unlock方法" class="headerlink" title="10、ReadLock的unlock方法"></a>10、ReadLock的unlock方法</h4><p>释放共享锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="11、AbstractQueuedSynchronizer的releaseShared方法"><a href="#11、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="11、AbstractQueuedSynchronizer的releaseShared方法"></a>11、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //释放共享锁</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、Sync的tryReleaseShared方法"><a href="#12、Sync的tryReleaseShared方法" class="headerlink" title="12、Sync的tryReleaseShared方法"></a>12、Sync的tryReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123;</span><br><span class="line">        //本线程为获取共享锁的第一个线程</span><br><span class="line">        if (firstReaderHoldCount == 1)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //线程获取锁次数减1，若线程已完全释放锁，清除rh</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        //释放一层锁</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            //共享锁是否完全释放</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、接（四、11）Sync的doReleaseShared方法"><a href="#13、接（四、11）Sync的doReleaseShared方法" class="headerlink" title="13、接（四、11）Sync的doReleaseShared方法"></a>13、接（四、11）Sync的doReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                //SIGNAL说明下个节点需要唤醒</span><br><span class="line">                //设置该节点状态为0，不成功继续循环，</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;    </span><br><span class="line">                //唤醒下个节点的线程</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                //设置该节点状态为共享锁</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        //头结点发生变化，退出循环</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、WriteLock的unlock方法"><a href="#14、WriteLock的unlock方法" class="headerlink" title="14、WriteLock的unlock方法"></a>14、WriteLock的unlock方法</h4><p>写锁释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15、AbstractQueuedSynchronizer的release方法"><a href="#15、AbstractQueuedSynchronizer的release方法" class="headerlink" title="15、AbstractQueuedSynchronizer的release方法"></a>15、AbstractQueuedSynchronizer的release方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //释放锁，返回是否完全释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            //唤醒后继节点线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、AbstractQueuedSynchronizer的tryRelease方法"><a href="#16、AbstractQueuedSynchronizer的tryRelease方法" class="headerlink" title="16、AbstractQueuedSynchronizer的tryRelease方法"></a>16、AbstractQueuedSynchronizer的tryRelease方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //拥有锁的是否是当前线程</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //释放一层锁</span><br><span class="line">    int nextc = getState() - releases;</span><br><span class="line">    //是否完全释放</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">    if (free)</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、CountDownLatch"><a href="#五、CountDownLatch" class="headerlink" title="五、CountDownLatch"></a>五、CountDownLatch</h3><h4 id="1、实例化CountDownLatch"><a href="#1、实例化CountDownLatch" class="headerlink" title="1、实例化CountDownLatch"></a>1、实例化CountDownLatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(int count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueuedSynchronizer的setState方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CountDownLatch重写了tryAcquireShared、tryReleaseShared方法，其余与共享锁相同</p>
<h4 id="2、CountDownLatch的await方法"><a href="#2、CountDownLatch的await方法" class="headerlink" title="2、CountDownLatch的await方法"></a>2、CountDownLatch的await方法</h4><p>线程加入等待队列，等待CountDownLatch释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"><a href="#3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //查看CountDownLatch是否完全释放，没有则线程加入等待队列</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //线程加入等待队列，与共享锁相同</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、Sync的tryAcquireShared方法-1"><a href="#4、Sync的tryAcquireShared方法-1" class="headerlink" title="4、Sync的tryAcquireShared方法"></a>4、Sync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"><a href="#5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法" class="headerlink" title="5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //判断CountDownLatch是否完全释放</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //CountDownLatch完全释放，唤醒等待队列中的所有线程</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、CountDownLatch的countDown方法"><a href="#6、CountDownLatch的countDown方法" class="headerlink" title="6、CountDownLatch的countDown方法"></a>6、CountDownLatch的countDown方法</h4><p>CountDownLatch释放一层锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、AbstractQueuedSynchronizer的releaseShared方法"><a href="#7、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="7、AbstractQueuedSynchronizer的releaseShared方法"></a>7、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    //释放一层锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //释放共享锁，唤醒等待线程，与共享锁相同</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、Sync的tryReleaseShared方法"><a href="#8、Sync的tryReleaseShared方法" class="headerlink" title="8、Sync的tryReleaseShared方法"></a>8、Sync的tryReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        //释放一层锁</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            //返回CountDownLatch是否完全释放</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、CyclicBarrier"><a href="#六、CyclicBarrier" class="headerlink" title="六、CyclicBarrier"></a>六、CyclicBarrier</h3><h4 id="1、实例化CyclicBarrier"><a href="#1、实例化CyclicBarrier" class="headerlink" title="1、实例化CyclicBarrier"></a>1、实例化CyclicBarrier</h4><p>等待parties个线程到达，才会释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    //回调线程</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、CyclicBarrier的await方法"><a href="#2、CyclicBarrier的await方法" class="headerlink" title="2、CyclicBarrier的await方法"></a>2、CyclicBarrier的await方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); // cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、CyclicBarrier的dowait方法"><a href="#3、CyclicBarrier的dowait方法" class="headerlink" title="3、CyclicBarrier的dowait方法"></a>3、CyclicBarrier的dowait方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    //独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //当前的generation</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        //是否已损坏</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        //当前线程已被中断</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            //破坏锁，释放等待线程</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        //count 减一</span><br><span class="line">        int index = --count;</span><br><span class="line">        //到达CyclicBarrier的线程数已达到parties个</span><br><span class="line">        if (index == 0) &#123;  // tripped</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                if (command != null)</span><br><span class="line">                    //执行回调线程</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                //释放等待线程，重置锁</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    //lock锁的条件等待</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、CyclicBarrier的breakBarrier方法"><a href="#4、CyclicBarrier的breakBarrier方法" class="headerlink" title="4、CyclicBarrier的breakBarrier方法"></a>4、CyclicBarrier的breakBarrier方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    //锁被破坏</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    //重置count</span><br><span class="line">    count = parties;</span><br><span class="line">    //释放在等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、接（六、3）CyclicBarrier的nextGeneration方法"><a href="#5、接（六、3）CyclicBarrier的nextGeneration方法" class="headerlink" title="5、接（六、3）CyclicBarrier的nextGeneration方法"></a>5、接（六、3）CyclicBarrier的nextGeneration方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    //释放等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    //重置count</span><br><span class="line">    count = parties;</span><br><span class="line">    //重置Generation</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、Semaphore"><a href="#七、Semaphore" class="headerlink" title="七、Semaphore"></a>七、Semaphore</h3><h4 id="1、实例化Semaphore"><a href="#1、实例化Semaphore" class="headerlink" title="1、实例化Semaphore"></a>1、实例化Semaphore</h4><p>最大信号量permits<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、Semaphore的acquire方法"><a href="#2、Semaphore的acquire方法" class="headerlink" title="2、Semaphore的acquire方法"></a>2、Semaphore的acquire方法</h4><p>获取permits的信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法-1"><a href="#3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法-1" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //剩余信号量小于零，则线程加入等待队列</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //加入等待队列,与共享锁相同  </span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、NonfairSync的tryAcquireShared方法"><a href="#4、NonfairSync的tryAcquireShared方法" class="headerlink" title="4、NonfairSync的tryAcquireShared方法"></a>4、NonfairSync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、Semaphore的nonfairTryAcquireShared方法"><a href="#5、Semaphore的nonfairTryAcquireShared方法" class="headerlink" title="5、Semaphore的nonfairTryAcquireShared方法"></a>5、Semaphore的nonfairTryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //剩余的信号量</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        //剩余信号量大于零，则尝试获取。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            //剩余信号量小于零，或者获取成功，返回剩余信号量</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、Semaphore的release方法"><a href="#6、Semaphore的release方法" class="headerlink" title="6、Semaphore的release方法"></a>6、Semaphore的release方法</h4><p>释放信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void release(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、AbstractQueuedSynchronizer的releaseShared方法-1"><a href="#7、AbstractQueuedSynchronizer的releaseShared方法-1" class="headerlink" title="7、AbstractQueuedSynchronizer的releaseShared方法"></a>7、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //唤醒等待队列，与共享锁相同</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、AbstractQueuedSynchronizer的releaseShared方法"><a href="#8、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="8、AbstractQueuedSynchronizer的releaseShared方法"></a>8、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        //释放信号量</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、接（七、3）FairSync的tryAcquireShared方法"><a href="#9、接（七、3）FairSync的tryAcquireShared方法" class="headerlink" title="9、接（七、3）FairSync的tryAcquireShared方法"></a>9、接（七、3）FairSync的tryAcquireShared方法</h4><p>公平锁的信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //等待队列中，由线程直接返回-1，其余与非公平锁相同</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/JUC源码/JUC锁/" data-id="cjix6fz5w00018ouez5ztl62u" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/06/JUC源码/JUC集合(1)ConcurrentHashMap/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          JUC集合(1)ConcurrentHashMap
        
      </div>
    </a>
  
  
    <a href="/2018/05/06/JUC源码/JUC线程池(2)ForkJoinPool/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">JUC线程池(2)ForkJoinPool</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java-util-concurrent/">java.util.concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis3/">mybatis3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码整合MyBatis/">spring源码整合MyBatis</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(2) /">spring源码XmlBeanFactory(2)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(1)/">spring源码XmlBeanFactory(1)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码Transaction/">spring源码Transaction</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码SpringMVC/">spring源码SpringMVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>