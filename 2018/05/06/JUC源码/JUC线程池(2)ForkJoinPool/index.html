<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JUC线程池(2)ForkJoinPool | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JUC线程池(2)ForkJoinPool###demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &amp;#123;      public static void main(String[] args">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC线程池(2)ForkJoinPool">
<meta property="og:url" content="http://yoursite.com/2018/05/06/JUC源码/JUC线程池(2)ForkJoinPool/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JUC线程池(2)ForkJoinPool###demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &amp;#123;      public static void main(String[] args">
<meta property="og:updated_time" content="2018-05-06T13:47:22.088Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JUC线程池(2)ForkJoinPool">
<meta name="twitter:description" content="JUC线程池(2)ForkJoinPool###demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &amp;#123;      public static void main(String[] args">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JUC源码/JUC线程池(2)ForkJoinPool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/JUC源码/JUC线程池(2)ForkJoinPool/" class="article-date">
  <time datetime="2018-05-06T13:48:30.181Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java-util-concurrent/">java.util.concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JUC线程池(2)ForkJoinPool
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JUC线程池-2-ForkJoinPool"><a href="#JUC线程池-2-ForkJoinPool" class="headerlink" title="JUC线程池(2)ForkJoinPool"></a>JUC线程池(2)ForkJoinPool</h2><p>###demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();  </span><br><span class="line">              </span><br><span class="line">        /** </span><br><span class="line">         * get()和join()有两个主要的区别： </span><br><span class="line">         * join()方法同步返回,不能被中断。如果你中断调用join()方法的线程，这个方法将抛出InterruptedException异常。 </span><br><span class="line">         * 如果任务抛出任何未受检异常，get()方法异步返回将返回一个ExecutionException异常，而join()方法将返回一个RuntimeException异常。 </span><br><span class="line">         */  </span><br><span class="line">        //同步返回结果  </span><br><span class="line">        //Future&lt;Integer&gt; result = pool.submit(new CountTask(0, 2000));  </span><br><span class="line">        //System.out.println(result.get());  </span><br><span class="line">        //异步返回结果  </span><br><span class="line">        CountTask task = new CountTask(0, 2000);  </span><br><span class="line">        pool.execute(task);  </span><br><span class="line">        pool.shutdown();  </span><br><span class="line">        Integer count = task.join();  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 计算1..n相加总和的简单demo </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">class CountTask extends RecursiveTask&lt;Integer&gt;&#123;  </span><br><span class="line">        </span><br><span class="line">    private static final long serialVersionUID = 1L;  </span><br><span class="line">    //边界值  </span><br><span class="line">    private static final int THRESHOLD = 50;  </span><br><span class="line">    private int start;  </span><br><span class="line">    private int end;  </span><br><span class="line">       </span><br><span class="line">    public CountTask(int start, int end) &#123;  </span><br><span class="line">        this.start = start;  </span><br><span class="line">        this.end = end;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    protected Integer compute() &#123;  </span><br><span class="line">        int sum = 0;  </span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;  </span><br><span class="line">        if (canCompute) &#123;  </span><br><span class="line">            for (int i = start; i &lt;= end; i++)  </span><br><span class="line">                sum += i;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            int mid = (start + end) / 2;  </span><br><span class="line">            CountTask t1 = new CountTask(start, mid);  </span><br><span class="line">            CountTask t2 = new CountTask(mid+1, end);  </span><br><span class="line">            t1.fork();  </span><br><span class="line">            t2.fork();  </span><br><span class="line">            sum = t1.join() + t2.join();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return sum;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一、ForkJoinPool"><a href="#一、ForkJoinPool" class="headerlink" title="一、ForkJoinPool"></a>一、ForkJoinPool</h3><h4 id="1、实例化ForkJoinPool"><a href="#1、实例化ForkJoinPool" class="headerlink" title="1、实例化ForkJoinPool"></a>1、实例化ForkJoinPool</h4><p>创建ForkJoinPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool() &#123;</span><br><span class="line">    this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">         defaultForkJoinWorkerThreadFactory, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool(int parallelism,</span><br><span class="line">                    ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                    UncaughtExceptionHandler handler,</span><br><span class="line">                    boolean asyncMode) &#123;</span><br><span class="line">    this(checkParallelism(parallelism),</span><br><span class="line">         checkFactory(factory),</span><br><span class="line">         handler,</span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">         &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinPool(int parallelism,</span><br><span class="line">                     ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                     UncaughtExceptionHandler handler,</span><br><span class="line">                     int mode,</span><br><span class="line">                     String workerNamePrefix) &#123;</span><br><span class="line">    //线程名前缀</span><br><span class="line">    this.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    //线程工厂，默认DefaultForkJoinWorkerThreadFactory</span><br><span class="line">    this.factory = factory;</span><br><span class="line">    //</span><br><span class="line">    this.ueh = handler;</span><br><span class="line">    //前16位保存队列模式，后16位保存最大线程数量</span><br><span class="line">    this.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    //</span><br><span class="line">    long np = (long)(-parallelism); // offset ctl counts</span><br><span class="line">    //线程锁，前16位保存活跃的工作线程数量，第二个16位保存总线程数量,最后32位保存等待线程在数组中的位置</span><br><span class="line">    this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池运行状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final int  RSLOCK     = 1;</span><br><span class="line">private static final int  RSIGNAL    = 1 &lt;&lt; 1;</span><br><span class="line">private static final int  STARTED    = 1 &lt;&lt; 2;</span><br><span class="line">private static final int  STOP       = 1 &lt;&lt; 29;</span><br><span class="line">private static final int  TERMINATED = 1 &lt;&lt; 30;</span><br><span class="line">private static final int  SHUTDOWN   = 1 &lt;&lt; 31;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、ForkJoinPool的execute"><a href="#2、ForkJoinPool的execute" class="headerlink" title="2、ForkJoinPool的execute"></a>2、ForkJoinPool的execute</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、ForkJoinPool的externalPush"><a href="#3、ForkJoinPool的externalPush" class="headerlink" title="3、ForkJoinPool的externalPush"></a>3、ForkJoinPool的externalPush</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final void externalPush(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; int m;</span><br><span class="line">    //随机数</span><br><span class="line">    int r = ThreadLocalRandom.getProbe();</span><br><span class="line">    int rs = runState;</span><br><span class="line">    //如果数组存在，获取数组中的workQueue队列，将任务加入队列</span><br><span class="line">    if ((ws = workQueues) != null &amp;&amp; (m = (ws.length - 1)) &gt;= 0 &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp; r != 0 &amp;&amp; rs &gt; 0 &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; int am, n, s;</span><br><span class="line">        if ((a = q.array) != null &amp;&amp;</span><br><span class="line">            (am = a.length - 1) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            int j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            U.putOrderedInt(q, QTOP, s + 1);</span><br><span class="line">            U.putIntVolatile(q, QLOCK, 0);</span><br><span class="line">            //尝试创建一个活跃的工作线程</span><br><span class="line">            if (n &lt;= 1)</span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, 1, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //任务加入线程池</span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、ForkJoinPool的externalSubmit"><a href="#4、ForkJoinPool的externalSubmit" class="headerlink" title="4、ForkJoinPool的externalSubmit"></a>4、ForkJoinPool的externalSubmit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private void externalSubmit(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    int r;                                    // initialize caller&apos;s probe</span><br><span class="line">    //获取随机数</span><br><span class="line">    if ((r = ThreadLocalRandom.getProbe()) == 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; int rs, m, k;</span><br><span class="line">        boolean move = false;</span><br><span class="line">        //线程池已关闭，抛出异常</span><br><span class="line">        if ((rs = runState) &lt; 0) &#123;</span><br><span class="line">            tryTerminate(false, false);     // help terminate</span><br><span class="line">            throw new RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化数组workQueues</span><br><span class="line">        else if ((rs &amp; STARTED) == 0 ||     // initialize</span><br><span class="line">                 ((ws = workQueues) == null || (m = ws.length - 1) &lt; 0)) &#123;</span><br><span class="line">            int ns = 0;</span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((rs &amp; STARTED) == 0) &#123;</span><br><span class="line">                    U.compareAndSwapObject(this, STEALCOUNTER, null,</span><br><span class="line">                                           new AtomicLong());</span><br><span class="line">                    // create workQueues array with size a power of two</span><br><span class="line">                    int p = config &amp; SMASK; // ensure at least 2 slots</span><br><span class="line">                    int n = (p &gt; 1) ? p - 1 : 1;</span><br><span class="line">                    n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2;  n |= n &gt;&gt;&gt; 4;</span><br><span class="line">                    n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n = (n + 1) &lt;&lt; 1;</span><br><span class="line">                    workQueues = new WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //任务加入队列</span><br><span class="line">        else if ((q = ws[k = r &amp; m &amp; SQMASK]) != null) &#123;</span><br><span class="line">            if (q.qlock == 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                int s = q.top;</span><br><span class="line">                boolean submitted = false; // initial submission or resizing</span><br><span class="line">                try &#123;                      // locked version of push</span><br><span class="line">                    if ((a != null &amp;&amp; a.length &gt; s + 1 - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != null) &#123;</span><br><span class="line">                        int j = (((a.length - 1) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + 1);</span><br><span class="line">                        submitted = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, 1, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                if (submitted) &#123;</span><br><span class="line">                    //创建工作线程</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = true;                   // move on failure</span><br><span class="line">        &#125;</span><br><span class="line">        //队列不存在，创建队列</span><br><span class="line">        else if (((rs = runState) &amp; RSLOCK) == 0) &#123; // create new queue</span><br><span class="line">            q = new WorkQueue(this, null);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            //队列中不存在工作线程</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           // publish index</span><br><span class="line">            if (rs &gt; 0 &amp;&amp;  (ws = workQueues) != null &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == null)</span><br><span class="line">                ws[k] = q;                 // else terminated</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            move = true;                   // move if busy</span><br><span class="line">        //添加失败,换个数组下标</span><br><span class="line">        if (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、ForkJoinPool的signalWork"><a href="#5、ForkJoinPool的signalWork" class="headerlink" title="5、ForkJoinPool的signalWork"></a>5、ForkJoinPool的signalWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final void signalWork(WorkQueue[] ws, WorkQueue q) &#123;</span><br><span class="line">    long c; int sp, i; WorkQueue v; Thread p;</span><br><span class="line">    //ctl小于零，说明活跃工作线程数量未达到上限</span><br><span class="line">    while ((c = ctl) &lt; 0L) &#123;                       // too few active</span><br><span class="line">        //没有等待线程</span><br><span class="line">        if ((sp = (int)c) == 0) &#123;                  // no idle workers</span><br><span class="line">            //总线程数未达到上限</span><br><span class="line">            if ((c &amp; ADD_WORKER) != 0L)            // too few workers</span><br><span class="line">                //创建新工作线程</span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ws == null)                            // unstarted/terminated</span><br><span class="line">            break;</span><br><span class="line">        if (ws.length &lt;= (i = sp &amp; SMASK))         // terminated</span><br><span class="line">            break;</span><br><span class="line">        if ((v = ws[i]) == null)                   // terminating</span><br><span class="line">            break;</span><br><span class="line">        int vs = (sp + SS_SEQ) &amp; ~INACTIVE;        // next scanState</span><br><span class="line">        int d = sp - v.scanState;                  // screen CAS</span><br><span class="line">        //活跃线程加1，唤醒一个正在等待的线程，stackPred保存的前一个等待线程的位置信息</span><br><span class="line">        long nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        if (d == 0 &amp;&amp; U.compareAndSwapLong(this, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      // activate v</span><br><span class="line">            if ((p = v.parker) != null)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (q != null &amp;&amp; q.base == q.top)          // no more work</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、ForkJoinPool的tryAddWorker"><a href="#6、ForkJoinPool的tryAddWorker" class="headerlink" title="6、ForkJoinPool的tryAddWorker"></a>6、ForkJoinPool的tryAddWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void tryAddWorker(long c) &#123;</span><br><span class="line">    boolean add = false;</span><br><span class="line">    do &#123;</span><br><span class="line">        //活跃线程，总线程数量分别加1</span><br><span class="line">        long nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        if (ctl == c) &#123;</span><br><span class="line">            int rs, stop;                 // check if terminating</span><br><span class="line">            if ((stop = (rs = lockRunState()) &amp; STOP) == 0)</span><br><span class="line">                add = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            if (stop != 0)</span><br><span class="line">                break;</span><br><span class="line">            if (add) &#123;</span><br><span class="line">                //创建工作线程</span><br><span class="line">                createWorker();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (((c = ctl) &amp; ADD_WORKER) != 0L &amp;&amp; (int)c == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、ForkJoinPool的createWorker"><a href="#7、ForkJoinPool的createWorker" class="headerlink" title="7、ForkJoinPool的createWorker"></a>7、ForkJoinPool的createWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private boolean createWorker() &#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = null;</span><br><span class="line">    ForkJoinWorkerThread wt = null;</span><br><span class="line">    //创建工作线程，并启动</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fac != null &amp;&amp; (wt = fac.newThread(this)) != null) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、实例化ForkJoinWorkerThread"><a href="#8、实例化ForkJoinWorkerThread" class="headerlink" title="8、实例化ForkJoinWorkerThread"></a>8、实例化ForkJoinWorkerThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected ForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">    // Use a placeholder until a useful name can be set in registerWorker</span><br><span class="line">    super(&quot;aForkJoinWorkerThread&quot;);</span><br><span class="line">    this.pool = pool;</span><br><span class="line">    this.workQueue = pool.registerWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、ForkJoinPool的registerWorker"><a href="#9、ForkJoinPool的registerWorker" class="headerlink" title="9、ForkJoinPool的registerWorker"></a>9、ForkJoinPool的registerWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final WorkQueue registerWorker(ForkJoinWorkerThread wt) &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(true);                           // configure thread</span><br><span class="line">    if ((handler = ueh) != null)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    //创建该工作线程的队列</span><br><span class="line">    WorkQueue w = new WorkQueue(this, wt);</span><br><span class="line">    int i = 0;                                    // assign a pool index</span><br><span class="line">    int mode = config &amp; MODE_MASK;</span><br><span class="line">    int rs = lockRunState();</span><br><span class="line">    try &#123;</span><br><span class="line">        WorkQueue[] ws; int n;                    // skip if no array</span><br><span class="line">        if ((ws = workQueues) != null &amp;&amp; (n = ws.length) &gt; 0) &#123;</span><br><span class="line">            //随机数的种子</span><br><span class="line">            int s = indexSeed += SEED_INCREMENT;  // unlikely to collide</span><br><span class="line">            int m = n - 1;</span><br><span class="line">            //奇数</span><br><span class="line">            i = ((s &lt;&lt; 1) | 1) &amp; m;               // odd-numbered indices</span><br><span class="line">            if (ws[i] != null) &#123;                  // collision</span><br><span class="line">                int probes = 0;                   // step by approx half n</span><br><span class="line">                //偶数</span><br><span class="line">                int step = (n &lt;= 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2;</span><br><span class="line">                while (ws[i = (i + step) &amp; m] != null) &#123;</span><br><span class="line">                    if (++probes &gt;= n) &#123;</span><br><span class="line">                        //数组扩容</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= 1);</span><br><span class="line">                        m = n - 1;</span><br><span class="line">                        probes = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           // use as random seed</span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            //队列中存在工作线程，数组中的下标</span><br><span class="line">            w.scanState = i;                      // publication fence</span><br><span class="line">            //队列放入数组的奇数位</span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; 1)));</span><br><span class="line">    return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、接（一、8）ForkJoinWorkerThread的run方法"><a href="#10、接（一、8）ForkJoinWorkerThread的run方法" class="headerlink" title="10、接（一、8）ForkJoinWorkerThread的run方法"></a>10、接（一、8）ForkJoinWorkerThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (workQueue.array == null) &#123; // only run once</span><br><span class="line">        Throwable exception = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //空函数,待覆盖</span><br><span class="line">            onStart();</span><br><span class="line">            //处理任务</span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                if (exception == null)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                pool.deregisterWorker(this, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、ForkJoinPool的runWorker方法"><a href="#11、ForkJoinPool的runWorker方法" class="headerlink" title="11、ForkJoinPool的runWorker方法"></a>11、ForkJoinPool的runWorker方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(WorkQueue w) &#123;</span><br><span class="line">    //数组扩容</span><br><span class="line">    w.growArray();                   // allocate queue</span><br><span class="line">    int seed = w.hint;               // initially holds randomization hint</span><br><span class="line">    int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift</span><br><span class="line">    for (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        //偷取任务</span><br><span class="line">        if ((t = scan(w, r)) != null)</span><br><span class="line">            //执行任务</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        //无任务,线程等待</span><br><span class="line">        else if (!awaitWork(w, r))</span><br><span class="line">            break;</span><br><span class="line">        //下一个随机数</span><br><span class="line">        r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // xorshift</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、ForkJoinPool的scan方法"><a href="#12、ForkJoinPool的scan方法" class="headerlink" title="12、ForkJoinPool的scan方法"></a>12、ForkJoinPool的scan方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinTask&lt;?&gt; scan(WorkQueue w, int r) &#123;</span><br><span class="line">    WorkQueue[] ws; int m;</span><br><span class="line">    if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt; 0 &amp;&amp; w != null) &#123;</span><br><span class="line">        int ss = w.scanState;                     // initially non-negative</span><br><span class="line">        for (int origin = r &amp; m, k = origin, oldSum = 0, checkSum = 0;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            int b, n; long c;</span><br><span class="line">            //从随机下标k，获取队列</span><br><span class="line">            if ((q = ws[k]) != null) &#123;</span><br><span class="line">                if ((n = (b = q.base) - q.top) &lt; 0 &amp;&amp;</span><br><span class="line">                    (a = q.array) != null) &#123;      // non-empty</span><br><span class="line">                    //从下往上获取任务</span><br><span class="line">                    long i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    if ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != null &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        //工作线程活跃状态</span><br><span class="line">                        if (ss &gt;= 0) &#123;</span><br><span class="line">                            //获取并返回任务</span><br><span class="line">                            if (U.compareAndSwapObject(a, i, t, null)) &#123;</span><br><span class="line">                                q.base = b + 1;</span><br><span class="line">                                //任务较多，创建一个工作线程</span><br><span class="line">                                if (n &lt; -1)       // signal others</span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                return t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //工作线程非活跃状态</span><br><span class="line">                        else if (oldSum == 0 &amp;&amp;   // try to activate</span><br><span class="line">                                 w.scanState &lt; 0)</span><br><span class="line">                            //释放一个等待线程</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (ss &lt; 0)                   // refresh</span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    //获取失败,随机换一个数组下标</span><br><span class="line">                    r ^= r &lt;&lt; 1; r ^= r &gt;&gt;&gt; 3; r ^= r &lt;&lt; 10;</span><br><span class="line">                    origin = k = r &amp; m;           // move and rescan</span><br><span class="line">                    oldSum = checkSum = 0;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            //查找了一圈未找到可偷窃的任务</span><br><span class="line">            if ((k = (k + 1) &amp; m) == origin) &#123;    // continue until stable</span><br><span class="line">                if ((ss &gt;= 0 || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    if (ss &lt; 0 || w.qlock &lt; 0)    // already inactive</span><br><span class="line">                        break;</span><br><span class="line">                    //工作线程转为非活跃状态</span><br><span class="line">                    int ns = ss | INACTIVE;       // try to inactivate</span><br><span class="line">                    //活跃线程数减1</span><br><span class="line">                    long nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    //上一个转非活跃线程的数组下标</span><br><span class="line">                    w.stackPred = (int)c;         // hold prev stack top</span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    if (U.compareAndSwapLong(this, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    else</span><br><span class="line">                        w.scanState = ss;         // back out</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13、接（一、11）ForkJoinWorkerThread的runTask方法"><a href="#13、接（一、11）ForkJoinWorkerThread的runTask方法" class="headerlink" title="13、接（一、11）ForkJoinWorkerThread的runTask方法"></a>13、接（一、11）ForkJoinWorkerThread的runTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final void runTask(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    if (task != null) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; // mark as busy</span><br><span class="line">        //执行任务，currentSteal为工作线程当前正在执行的任务</span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(this, QCURRENTSTEAL, null); // release for GC</span><br><span class="line">        //执行本线程队列的任务</span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        if (++nsteals &lt; 0)      // collect on overflow</span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        if (thread != null)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14、ForkJoinTask的doExec方法"><a href="#14、ForkJoinTask的doExec方法" class="headerlink" title="14、ForkJoinTask的doExec方法"></a>14、ForkJoinTask的doExec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final int doExec() &#123;</span><br><span class="line">    int s; boolean completed;</span><br><span class="line">    if ((s = status) &gt;= 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行任务</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; catch (Throwable rex) &#123;</span><br><span class="line">            return setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (completed)</span><br><span class="line">            //更新任务状态，唤醒等待任务结果的线程</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15、ForkJoinTask的exec方法"><a href="#15、ForkJoinTask的exec方法" class="headerlink" title="15、ForkJoinTask的exec方法"></a>15、ForkJoinTask的exec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean exec() &#123;</span><br><span class="line">    //执行任务</span><br><span class="line">    result = compute();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16、接（一、11）ForkJoinPool的awaitWork方法"><a href="#16、接（一、11）ForkJoinPool的awaitWork方法" class="headerlink" title="16、接（一、11）ForkJoinPool的awaitWork方法"></a>16、接（一、11）ForkJoinPool的awaitWork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private boolean awaitWork(WorkQueue w, int r) &#123;</span><br><span class="line">    if (w == null || w.qlock &lt; 0)                 // w is terminating</span><br><span class="line">        return false;</span><br><span class="line">    for (int pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        //已激活</span><br><span class="line">        if ((ss = w.scanState) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        else if (spins &gt; 0) &#123;</span><br><span class="line">            r ^= r &lt;&lt; 6; r ^= r &gt;&gt;&gt; 21; r ^= r &lt;&lt; 7;</span><br><span class="line">            if (r &gt;= 0 &amp;&amp; --spins == 0) &#123;         // randomize spins</span><br><span class="line">                WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;</span><br><span class="line">                if (pred != 0 &amp;&amp; (ws = workQueues) != null &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != null &amp;&amp;        // see if pred parking</span><br><span class="line">                    (v.parker == null || v.scanState &gt;= 0))</span><br><span class="line">                    spins = SPINS;                // continue spinning</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (w.qlock &lt; 0)                     // recheck after spins</span><br><span class="line">            return false;</span><br><span class="line">        else if (!Thread.interrupted()) &#123;</span><br><span class="line">            long c, prevctl, parkTime, deadline;</span><br><span class="line">            int ac = (int)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            if ((ac &lt;= 0 &amp;&amp; tryTerminate(false, false)) ||</span><br><span class="line">                (runState &amp; STOP) != 0)           // pool terminating</span><br><span class="line">                return false;</span><br><span class="line">            if (ac &lt;= 0 &amp;&amp; ss == (int)c) &#123;        // is last waiter</span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                int t = (short)(c &gt;&gt;&gt; TC_SHIFT);  // shrink excess spares</span><br><span class="line">                if (t &gt; 2 &amp;&amp; U.compareAndSwapLong(this, CTL, c, prevctl))</span><br><span class="line">                    return false;                 // else use timed wait</span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= 0) ? 1 : 1 - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                prevctl = parkTime = deadline = 0L;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport</span><br><span class="line">            w.parker = wt;</span><br><span class="line">            //阻塞当前线程</span><br><span class="line">            if (w.scanState &lt; 0 &amp;&amp; ctl == c)      // recheck before park</span><br><span class="line">                U.park(false, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, null);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, null);</span><br><span class="line">            if (w.scanState &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            if (parkTime != 0L &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= 0L &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(this, CTL, c, prevctl))</span><br><span class="line">                return false;                     // shrink pool</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17、ForkJoinTask的fork方法"><a href="#17、ForkJoinTask的fork方法" class="headerlink" title="17、ForkJoinTask的fork方法"></a>17、ForkJoinTask的fork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final ForkJoinTask&lt;V&gt; fork() &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)</span><br><span class="line">        //任务加入该线程的任务池</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(this);</span><br><span class="line">    else</span><br><span class="line">        //加入公共任务池</span><br><span class="line">        ForkJoinPool.common.externalPush(this);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18、ForkJoinTask的join方法"><a href="#18、ForkJoinTask的join方法" class="headerlink" title="18、ForkJoinTask的join方法"></a>18、ForkJoinTask的join方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final V join() &#123;</span><br><span class="line">    int s;</span><br><span class="line">    if ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    //返回结果</span><br><span class="line">    return getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19、ForkJoinTask的doJoin方法"><a href="#19、ForkJoinTask的doJoin方法" class="headerlink" title="19、ForkJoinTask的doJoin方法"></a>19、ForkJoinTask的doJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int doJoin() &#123;</span><br><span class="line">    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    //线程池线程则参与任务处理，非线程池线程则等待任务结束</span><br><span class="line">    return (s = status) &lt; 0 ? s :</span><br><span class="line">        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, this, 0L) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="20、ForkJoinTask的doJoin方法"><a href="#20、ForkJoinTask的doJoin方法" class="headerlink" title="20、ForkJoinTask的doJoin方法"></a>20、ForkJoinTask的doJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int doJoin() &#123;</span><br><span class="line">    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    //线程池线程则执行awaitJoin，非线程池线程则执行externalAwaitDone</span><br><span class="line">    return (s = status) &lt; 0 ? s :</span><br><span class="line">        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, this, 0L) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21、ForkJoinPool的awaitJoin方法"><a href="#21、ForkJoinPool的awaitJoin方法" class="headerlink" title="21、ForkJoinPool的awaitJoin方法"></a>21、ForkJoinPool的awaitJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final int awaitJoin(WorkQueue w, ForkJoinTask&lt;?&gt; task, long deadline) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    if (task != null &amp;&amp; w != null) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task instanceof CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : null;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if ((s = task.status) &lt; 0)</span><br><span class="line">                break;</span><br><span class="line">            if (cc != null)</span><br><span class="line">                helpComplete(w, cc, 0);</span><br><span class="line">            //尝试获取并处理本任务，若任务已被其他线程执行，且本线程队列无任务，则帮助其他线程处理任务</span><br><span class="line">            else if (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                //帮助其他线程处理任务</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            if ((s = task.status) &lt; 0)</span><br><span class="line">                break;</span><br><span class="line">            long ms, ns;</span><br><span class="line">            if (deadline == 0L)</span><br><span class="line">                ms = 0L;</span><br><span class="line">            else if ((ns = deadline - System.nanoTime()) &lt;= 0L)</span><br><span class="line">                break;</span><br><span class="line">            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= 0L)</span><br><span class="line">                ms = 1L;</span><br><span class="line">            //等待的任务未完成，且本线程队列有任务，作一定的补偿</span><br><span class="line">            if (tryCompensate(w)) &#123;</span><br><span class="line">                //任务未完成则线程等待，否则唤醒等待该任务的线程</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(this, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22、WorkQueue的tryRemoveAndExec方法"><a href="#22、WorkQueue的tryRemoveAndExec方法" class="headerlink" title="22、WorkQueue的tryRemoveAndExec方法"></a>22、WorkQueue的tryRemoveAndExec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final boolean tryRemoveAndExec(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; int m, s, b, n;</span><br><span class="line">    if ((a = array) != null &amp;&amp; (m = a.length - 1) &gt;= 0 &amp;&amp;</span><br><span class="line">        task != null) &#123;</span><br><span class="line">        while ((n = (s = top) - (b = base)) &gt; 0) &#123;</span><br><span class="line">            for (ForkJoinTask&lt;?&gt; t;;) &#123;      // traverse from s to b</span><br><span class="line">                //从上往下，查找任务</span><br><span class="line">                long j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                if ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == null)</span><br><span class="line">                    //任务已被其他线程处理，队列已无任务返回true，有任务返回false</span><br><span class="line">                    return s + 1 == top;     // shorter than expected</span><br><span class="line">                else if (t == task) &#123;</span><br><span class="line">                    boolean removed = false;</span><br><span class="line">                    //task刚好在top位置，pop出来执行</span><br><span class="line">                    if (s + 1 == top) &#123;      // pop</span><br><span class="line">                        if (U.compareAndSwapObject(a, j, task, null)) &#123;</span><br><span class="line">                            U.putOrderedInt(this, QTOP, s);</span><br><span class="line">                            removed = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //task在队列中间,则使用EmptyTask来占位,将任务取出来执行</span><br><span class="line">                    else if (base == b)      // replace with proxy</span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                            a, j, task, new EmptyTask());</span><br><span class="line">                    if (removed)</span><br><span class="line">                        task.doExec();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //任务已被取消</span><br><span class="line">                else if (t.status &lt; 0 &amp;&amp; s + 1 == top) &#123;</span><br><span class="line">                    if (U.compareAndSwapObject(a, j, t, null))</span><br><span class="line">                        U.putOrderedInt(this, QTOP, s);</span><br><span class="line">                    break;                  // was cancelled</span><br><span class="line">                &#125;</span><br><span class="line">                if (--n == 0)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //任务已执行完</span><br><span class="line">            if (task.status &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23、ForkJoinPool的helpStealer方法"><a href="#23、ForkJoinPool的helpStealer方法" class="headerlink" title="23、ForkJoinPool的helpStealer方法"></a>23、ForkJoinPool的helpStealer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">private void helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    int oldSum = 0, checkSum, m;</span><br><span class="line">    if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp; w != null &amp;&amp;</span><br><span class="line">        task != null) &#123;</span><br><span class="line">        do &#123;                                       // restart point</span><br><span class="line">            checkSum = 0;                          // for stability check</span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    // v is subtask stealer</span><br><span class="line">            descent: for (subtask = task; subtask.status &gt;= 0; ) &#123;</span><br><span class="line">                for (int h = j.hint | 1, k = 0, i; ; k += 2) &#123;</span><br><span class="line">                    if (k &gt; m)                     // can&apos;t find stealer</span><br><span class="line">                        break descent;</span><br><span class="line">                    //查找正在执行本任务的线程队列</span><br><span class="line">                    if ((v = ws[i = (h + k) &amp; m]) != null) &#123;</span><br><span class="line">                        if (v.currentSteal == subtask) &#123;</span><br><span class="line">                            j.hint = i;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (;;) &#123;                         // help v or descend</span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a; int b;</span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;</span><br><span class="line">                    if (subtask.status &lt; 0 || j.currentJoin != subtask ||</span><br><span class="line">                        v.currentSteal != subtask) // stale</span><br><span class="line">                        break descent;</span><br><span class="line">                    //帮助线程的任务队列为空，则去帮助“该线程等待任务”的执行线程</span><br><span class="line">                    if (b - v.top &gt;= 0 || (a = v.array) == null) &#123;</span><br><span class="line">                        if ((subtask = next) == null)</span><br><span class="line">                            break descent;</span><br><span class="line">                        j = v;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //从下往上获取并执行任务</span><br><span class="line">                    int i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                         U.getObjectVolatile(a, i));</span><br><span class="line">                    if (v.base == b) &#123;</span><br><span class="line">                        if (t == null)             // stale</span><br><span class="line">                            break descent;</span><br><span class="line">                        if (U.compareAndSwapObject(a, i, t, null)) &#123;</span><br><span class="line">                            v.base = b + 1;</span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;</span><br><span class="line">                            int top = w.top;</span><br><span class="line">                            do &#123;</span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                t.doExec();        // clear local tasks too</span><br><span class="line">                            &#125; while (task.status &gt;= 0 &amp;&amp;</span><br><span class="line">                                     w.top != top &amp;&amp;</span><br><span class="line">                                     (t = w.pop()) != null);</span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">                            if (w.base != w.top)</span><br><span class="line">                                return;            // can&apos;t further help</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (task.status &gt;= 0 &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24、接（一、21）ForkJoinPool的tryCompensate方法"><a href="#24、接（一、21）ForkJoinPool的tryCompensate方法" class="headerlink" title="24、接（一、21）ForkJoinPool的tryCompensate方法"></a>24、接（一、21）ForkJoinPool的tryCompensate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private boolean tryCompensate(WorkQueue w) &#123;</span><br><span class="line">    boolean canBlock;</span><br><span class="line">    WorkQueue[] ws; long c; int m, pc, sp;</span><br><span class="line">    if (w == null || w.qlock &lt; 0 ||           // caller terminating</span><br><span class="line">        (ws = workQueues) == null || (m = ws.length - 1) &lt;= 0 ||</span><br><span class="line">        (pc = config &amp; SMASK) == 0)           // parallelism disabled</span><br><span class="line">        canBlock = false;</span><br><span class="line">    //唤醒一个阻塞线程，补偿该线程</span><br><span class="line">    else if ((sp = (int)(c = ctl)) != 0)      // release idle worker</span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], 0L);</span><br><span class="line">    else &#123;</span><br><span class="line">        int ac = (int)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        int tc = (short)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        int nbusy = 0;                        // validate saturation</span><br><span class="line">        for (int i = 0; i &lt;= m; ++i) &#123;        // two passes of odd indices</span><br><span class="line">            WorkQueue v;</span><br><span class="line">            if ((v = ws[((i &lt;&lt; 1) | 1) &amp; m]) != null) &#123;</span><br><span class="line">                if ((v.scanState &amp; SCANNING) != 0)</span><br><span class="line">                    break;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nbusy != (tc &lt;&lt; 1) || ctl != c)</span><br><span class="line">            canBlock = false;                 // unstable or stale</span><br><span class="line">        //直接阻塞，无需补偿</span><br><span class="line">        else if (tc &gt;= pc &amp;&amp; ac &gt; 1 &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            long nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       // uncompensated</span><br><span class="line">            canBlock = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (this == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            throw new RejectedExecutionException(</span><br><span class="line">                &quot;Thread limit exceeded replacing blocked worker&quot;);</span><br><span class="line">        else &#123;                                // similar to tryAddWorker</span><br><span class="line">            boolean add = false; int rs;      // CAS within lock</span><br><span class="line">            long nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            if (((rs = lockRunState()) &amp; STOP) == 0)</span><br><span class="line">                add = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            //创建新线程，补偿该线程</span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); // throws on exception</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="25、ForkJoinPool的shutdown方法"><a href="#25、ForkJoinPool的shutdown方法" class="headerlink" title="25、ForkJoinPool的shutdown方法"></a>25、ForkJoinPool的shutdown方法</h4><p>关闭线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    //关闭线程池</span><br><span class="line">    tryTerminate(false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="25、ForkJoinPool的tryTerminate方法"><a href="#25、ForkJoinPool的tryTerminate方法" class="headerlink" title="25、ForkJoinPool的tryTerminate方法"></a>25、ForkJoinPool的tryTerminate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private boolean tryTerminate(boolean now, boolean enable) &#123;</span><br><span class="line">    int rs;</span><br><span class="line">    //公共池不能关闭</span><br><span class="line">    if (this == common)                       // cannot shut down</span><br><span class="line">        return false;</span><br><span class="line">    if ((rs = runState) &gt;= 0) &#123;</span><br><span class="line">        if (!enable)</span><br><span class="line">            return false;</span><br><span class="line">        rs = lockRunState();                  // enter SHUTDOWN phase</span><br><span class="line">        //进入关闭阶段</span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | SHUTDOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((rs &amp; STOP) == 0) &#123;</span><br><span class="line">        if (!now) &#123;                           // check quiescence</span><br><span class="line">            for (long oldSum = 0L;;) &#123;        // repeat until stable</span><br><span class="line">                WorkQueue[] ws; WorkQueue w; int m, b; long c;</span><br><span class="line">                long checkSum = ctl;</span><br><span class="line">                if ((int)(checkSum &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &gt; 0)</span><br><span class="line">                    return false;             // still active workers</span><br><span class="line">                if ((ws = workQueues) == null || (m = ws.length - 1) &lt;= 0)</span><br><span class="line">                    break;                    // check queues</span><br><span class="line">                //释放阻塞的队列</span><br><span class="line">                for (int i = 0; i &lt;= m; ++i) &#123;</span><br><span class="line">                    if ((w = ws[i]) != null) &#123;</span><br><span class="line">                        if ((b = w.base) != w.top || w.scanState &gt;= 0 ||</span><br><span class="line">                            w.currentSteal != null) &#123;</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT);</span><br><span class="line">                            return false;     // arrange for recheck</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += b;</span><br><span class="line">                        if ((i &amp; 1) == 0)</span><br><span class="line">                            w.qlock = -1;     // try to disable external</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (oldSum == (oldSum = checkSum))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((runState &amp; STOP) == 0) &#123;</span><br><span class="line">            rs = lockRunState();              // enter STOP phase</span><br><span class="line">            //进入stop阶段</span><br><span class="line">            unlockRunState(rs, (rs &amp; ~RSLOCK) | STOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pass = 0;                             // 3 passes to help terminate</span><br><span class="line">    for (long oldSum = 0L;;) &#123;                // or until done or stable</span><br><span class="line">        WorkQueue[] ws; WorkQueue w; ForkJoinWorkerThread wt; int m;</span><br><span class="line">        long checkSum = ctl;</span><br><span class="line">        if ((short)(checkSum &gt;&gt;&gt; TC_SHIFT) + (config &amp; SMASK) &lt;= 0 ||</span><br><span class="line">            (ws = workQueues) == null || (m = ws.length - 1) &lt;= 0) &#123;</span><br><span class="line">            if ((runState &amp; TERMINATED) == 0) &#123;</span><br><span class="line">                rs = lockRunState();          // done</span><br><span class="line">                //进入TERMINATED阶段</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | TERMINATED);</span><br><span class="line">                synchronized (this) &#123; notifyAll(); &#125; // for awaitTermination</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //取消未完成任务，中断工作线程</span><br><span class="line">        for (int i = 0; i &lt;= m; ++i) &#123;</span><br><span class="line">            if ((w = ws[i]) != null) &#123;</span><br><span class="line">                checkSum += w.base;</span><br><span class="line">                w.qlock = -1;                 // try to disable</span><br><span class="line">                if (pass &gt; 0) &#123;</span><br><span class="line">                    w.cancelAll();            // clear queue</span><br><span class="line">                    if (pass &gt; 1 &amp;&amp; (wt = w.owner) != null) &#123;</span><br><span class="line">                        if (!wt.isInterrupted()) &#123;</span><br><span class="line">                            try &#123;             // unblock join</span><br><span class="line">                                wt.interrupt();</span><br><span class="line">                            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (w.scanState &lt; 0)</span><br><span class="line">                            U.unpark(wt);     // wake up</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkSum != oldSum) &#123;             // unstable</span><br><span class="line">            oldSum = checkSum;</span><br><span class="line">            pass = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pass &gt; 3 &amp;&amp; pass &gt; m)        // can&apos;t further help</span><br><span class="line">            break;</span><br><span class="line">        else if (++pass &gt; 1) &#123;                // try to dequeue</span><br><span class="line">            long c; int j = 0, sp;            // bound attempts</span><br><span class="line">            while (j++ &lt;= m &amp;&amp; (sp = (int)(c = ctl)) != 0)</span><br><span class="line">                tryRelease(c, ws[sp &amp; m], AC_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/JUC源码/JUC线程池(2)ForkJoinPool/" data-id="cjix67ndi0003b0uepbxlpk4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/06/JUC源码/JUC锁/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JUC锁
        
      </div>
    </a>
  
  
    <a href="/2018/05/06/JUC源码/JUC线程池(1)ThreadPoolExecutor/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JUC线程池(1)ThreadPoolExecutor</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java-util-concurrent/">java.util.concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis3/">mybatis3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码整合MyBatis/">spring源码整合MyBatis</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(2) /">spring源码XmlBeanFactory(2)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码XmlBeanFactory(1)/">spring源码XmlBeanFactory(1)</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码Transaction/">spring源码Transaction</a>
          </li>
        
          <li>
            <a href="/2018/06/27/spring源码/spring源码SpringMVC/">spring源码SpringMVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>