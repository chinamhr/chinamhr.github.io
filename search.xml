<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JUC集合(3)</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E9%9B%86%E5%90%88(3)/"/>
      <content type="html"><![CDATA[<h2 id="JUC集合-3"><a href="#JUC集合-3" class="headerlink" title="JUC集合(3)"></a>JUC集合(3)</h2><h3 id="一、CopyOnWriteArrayList"><a href="#一、CopyOnWriteArrayList" class="headerlink" title="一、CopyOnWriteArrayList"></a>一、CopyOnWriteArrayList</h3><h4 id="1、实例化CopyOnWriteArrayList"><a href="#1、实例化CopyOnWriteArrayList" class="headerlink" title="1、实例化CopyOnWriteArrayList"></a>1、实例化CopyOnWriteArrayList</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public CopyOnWriteArrayList() &#123;</span><br><span class="line">    setArray(new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void setArray(Object[] a) &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//存放该list数据的数组，volatile修饰数组，代表该数组地址的可见性，</span><br><span class="line">//也即一个线程给该数组从新赋值，另一个线程能立即看到，但是数组内部成员改变不具有该性质。</span><br><span class="line">private transient volatile Object[] array;</span><br><span class="line">//该对象内部保证线程安全的独占锁</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br></pre></td></tr></table></figure><h4 id="2、CopyOnWriteArrayList的add方法"><a href="#2、CopyOnWriteArrayList的add方法" class="headerlink" title="2、CopyOnWriteArrayList的add方法"></a>2、CopyOnWriteArrayList的add方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        //新数组</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        //更新数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、CopyOnWriteArrayList的get方法"><a href="#3、CopyOnWriteArrayList的get方法" class="headerlink" title="3、CopyOnWriteArrayList的get方法"></a>3、CopyOnWriteArrayList的get方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、CopyOnWriteArrayList的remove方法"><a href="#4、CopyOnWriteArrayList的remove方法" class="headerlink" title="4、CopyOnWriteArrayList的remove方法"></a>4、CopyOnWriteArrayList的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        //获取被删除的元素</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line">        //复制一个新数组，更新到CopyOnWriteArrayList对象中</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、CopyOnWriteArrayList的iterator方法"><a href="#5、CopyOnWriteArrayList的iterator方法" class="headerlink" title="5、CopyOnWriteArrayList的iterator方法"></a>5、CopyOnWriteArrayList的iterator方法</h4><p>迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、实例化COWIterator"><a href="#6、实例化COWIterator" class="headerlink" title="6、实例化COWIterator"></a>6、实例化COWIterator</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    //集合的数组</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、COWIterator的next方法"><a href="#7、COWIterator的next方法" class="headerlink" title="7、COWIterator的next方法"></a>7、COWIterator的next方法</h4><p>获取下一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public E next() &#123;</span><br><span class="line">    //查看有没有下一个元素</span><br><span class="line">    if (! hasNext())</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    //返回下一个元素</span><br><span class="line">    return (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、COWIterator的hasNext方法"><a href="#8、COWIterator的hasNext方法" class="headerlink" title="8、COWIterator的hasNext方法"></a>8、COWIterator的hasNext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor &lt; snapshot.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、CopyOnWriteArraySet"><a href="#二、CopyOnWriteArraySet" class="headerlink" title="二、CopyOnWriteArraySet"></a>二、CopyOnWriteArraySet</h3><h4 id="1、实例化CopyOnWriteArraySet"><a href="#1、实例化CopyOnWriteArraySet" class="headerlink" title="1、实例化CopyOnWriteArraySet"></a>1、实例化CopyOnWriteArraySet</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public CopyOnWriteArraySet() &#123;</span><br><span class="line">    al = new CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、CopyOnWriteArraySet的add方法"><a href="#2、CopyOnWriteArraySet的add方法" class="headerlink" title="2、CopyOnWriteArraySet的add方法"></a>2、CopyOnWriteArraySet的add方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、CopyOnWriteArrayList的addIfAbsent方法"><a href="#3、CopyOnWriteArrayList的addIfAbsent方法" class="headerlink" title="3、CopyOnWriteArrayList的addIfAbsent方法"></a>3、CopyOnWriteArrayList的addIfAbsent方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean addIfAbsent(E e) &#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        int len = current.length;</span><br><span class="line">        //不相等，则说明数字已被更改</span><br><span class="line">        if (snapshot != current) &#123;</span><br><span class="line">            int common = Math.min(snapshot.length, len);</span><br><span class="line">            //current中查找e,找到则返回false</span><br><span class="line">            for (int i = 0; i &lt; common; i++)</span><br><span class="line">                if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    return false;</span><br><span class="line">            if (indexOf(e, current, common, len) &gt;= 0)</span><br><span class="line">                    return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、CopyOnWriteArrayList的indexOf方法"><a href="#4、CopyOnWriteArrayList的indexOf方法" class="headerlink" title="4、CopyOnWriteArrayList的indexOf方法"></a>4、CopyOnWriteArrayList的indexOf方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static int indexOf(Object o, Object[] elements,</span><br><span class="line">                           int index, int fence) &#123;</span><br><span class="line">    //在数组index到fence中查找o，有则返回下标，不存在则返回-1</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = index; i &lt; fence; i++)</span><br><span class="line">            if (elements[i] == null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = index; i &lt; fence; i++)</span><br><span class="line">            if (o.equals(elements[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove、iterator等方法，均是调用了CopyOnWriteArrayList的同名方法。</p><h3 id="三、ArrayBlockingQueue"><a href="#三、ArrayBlockingQueue" class="headerlink" title="三、ArrayBlockingQueue"></a>三、ArrayBlockingQueue</h3><h4 id="1、实例化ArrayBlockingQueue"><a href="#1、实例化ArrayBlockingQueue" class="headerlink" title="1、实例化ArrayBlockingQueue"></a>1、实例化ArrayBlockingQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    this(capacity, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //存放元素的数组</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    //独占锁</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、ArrayBlockingQueue的offer方法"><a href="#2、ArrayBlockingQueue的offer方法" class="headerlink" title="2、ArrayBlockingQueue的offer方法"></a>2、ArrayBlockingQueue的offer方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    // 创建插入的元素是否为null，是的话抛出NullPointerException异常</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == items.length)</span><br><span class="line">        // 如果队列已满，则返回false。</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">        // 如果队列未满，则插入e，并返回true。</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ArrayBlockingQueue的enqueue方法"><a href="#3、ArrayBlockingQueue的enqueue方法" class="headerlink" title="3、ArrayBlockingQueue的enqueue方法"></a>3、ArrayBlockingQueue的enqueue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    //循环数组</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    //唤醒等待线程</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ArrayBlockingQueue的take方法"><a href="#4、ArrayBlockingQueue的take方法" class="headerlink" title="4、ArrayBlockingQueue的take方法"></a>4、ArrayBlockingQueue的take方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        //队列为空，则等待</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        //取出下一个元素</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、ArrayBlockingQueue的dequeue方法"><a href="#5、ArrayBlockingQueue的dequeue方法" class="headerlink" title="5、ArrayBlockingQueue的dequeue方法"></a>5、ArrayBlockingQueue的dequeue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    //循环数组</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        //处理迭代器</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    //唤醒等待线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Itrs的elementDequeued方法"><a href="#6、Itrs的elementDequeued方法" class="headerlink" title="6、Itrs的elementDequeued方法"></a>6、Itrs的elementDequeued方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void elementDequeued() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    if (count == 0)</span><br><span class="line">        //队列为空，清空迭代器</span><br><span class="line">        queueIsEmpty();</span><br><span class="line">    else if (takeIndex == 0)</span><br><span class="line">        //循环数组，循环轮次加一，清除过期迭代器</span><br><span class="line">        takeIndexWrapped();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、Itrs的queueIsEmpty方法"><a href="#7、Itrs的queueIsEmpty方法" class="headerlink" title="7、Itrs的queueIsEmpty方法"></a>7、Itrs的queueIsEmpty方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void queueIsEmpty() &#123;</span><br><span class="line">    //清除迭代器队列,逐个关闭迭代器</span><br><span class="line">    for (Node p = head; p != null; p = p.next) &#123;</span><br><span class="line">        Itr it = p.get();</span><br><span class="line">        if (it != null) &#123;</span><br><span class="line">            p.clear();</span><br><span class="line">            it.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = null;</span><br><span class="line">    itrs = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、接（三、6）Itrs的takeIndexWrapped方法"><a href="#8、接（三、6）Itrs的takeIndexWrapped方法" class="headerlink" title="8、接（三、6）Itrs的takeIndexWrapped方法"></a>8、接（三、6）Itrs的takeIndexWrapped方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void takeIndexWrapped() &#123;</span><br><span class="line">    //循环轮次加一</span><br><span class="line">    cycles++;</span><br><span class="line">    //清除过期迭代器</span><br><span class="line">    for (Node o = null, p = head; p != null;) &#123;</span><br><span class="line">        final Itr it = p.get();</span><br><span class="line">        final Node next = p.next;</span><br><span class="line">        if (it == null || it.takeIndexWrapped()) &#123;</span><br><span class="line">        //迭代器已过期，清除节点</span><br><span class="line">            //清除过期迭代器</span><br><span class="line">            p.clear();</span><br><span class="line">            p.next = null;</span><br><span class="line">            if (o == null)</span><br><span class="line">                head = next;</span><br><span class="line">            else</span><br><span class="line">                o.next = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (head == null)   // no more iterators to track</span><br><span class="line">        itrs = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、Itrs的takeIndexWrapped方法"><a href="#9、Itrs的takeIndexWrapped方法" class="headerlink" title="9、Itrs的takeIndexWrapped方法"></a>9、Itrs的takeIndexWrapped方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean takeIndexWrapped() &#123;</span><br><span class="line">    //迭代器已使用完</span><br><span class="line">    if (isDetached())</span><br><span class="line">        return true;</span><br><span class="line">    //过期</span><br><span class="line">    if (itrs.cycles - prevCycles &gt; 1) &#123;</span><br><span class="line">        //废弃该迭代器</span><br><span class="line">        shutdown();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、Itrs的shutdown方法"><a href="#10、Itrs的shutdown方法" class="headerlink" title="10、Itrs的shutdown方法"></a>10、Itrs的shutdown方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void shutdown() &#123;</span><br><span class="line">    cursor = NONE;</span><br><span class="line">    if (nextIndex &gt;= 0)</span><br><span class="line">        nextIndex = REMOVED;</span><br><span class="line">    if (lastRet &gt;= 0) &#123;</span><br><span class="line">        lastRet = REMOVED;</span><br><span class="line">        lastItem = null;</span><br><span class="line">    &#125;</span><br><span class="line">    prevTakeIndex = DETACHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、ArrayBlockingQueue的remove方法"><a href="#11、ArrayBlockingQueue的remove方法" class="headerlink" title="11、ArrayBlockingQueue的remove方法"></a>11、ArrayBlockingQueue的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) return false;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            final int putIndex = this.putIndex;</span><br><span class="line">            int i = takeIndex;</span><br><span class="line">            //takeIndex到putIndex之间为队列现有元素</span><br><span class="line">            do &#123;</span><br><span class="line">                if (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (++i == items.length)</span><br><span class="line">                    i = 0;</span><br><span class="line">            &#125; while (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="12、ArrayBlockingQueue的removeAt方法"><a href="#12、ArrayBlockingQueue的removeAt方法" class="headerlink" title="12、ArrayBlockingQueue的removeAt方法"></a>12、ArrayBlockingQueue的removeAt方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void removeAt(final int removeIndex) &#123;</span><br><span class="line">    //删除元素，后面的元素迁移</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    if (removeIndex == takeIndex) &#123;</span><br><span class="line">        // removing front item; just advance</span><br><span class="line">        items[takeIndex] = null;</span><br><span class="line">        if (++takeIndex == items.length)</span><br><span class="line">            takeIndex = 0;</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int putIndex = this.putIndex;</span><br><span class="line">        for (int i = removeIndex;;) &#123;</span><br><span class="line">            int next = i + 1;</span><br><span class="line">            if (next == items.length)</span><br><span class="line">                next = 0;</span><br><span class="line">            if (next != putIndex) &#123;</span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                items[i] = null;</span><br><span class="line">                this.putIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        //跟新迭代器</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、Itrs的removeAt方法"><a href="#13、Itrs的removeAt方法" class="headerlink" title="13、Itrs的removeAt方法"></a>13、Itrs的removeAt方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void removedAt(int removedIndex) &#123;</span><br><span class="line">    for (Node o = null, p = head; p != null;) &#123;</span><br><span class="line">        final Itr it = p.get();</span><br><span class="line">        final Node next = p.next;</span><br><span class="line">        if (it == null || it.removedAt(removedIndex)) &#123;</span><br><span class="line">            //清除过期的迭代器</span><br><span class="line">            p.clear();</span><br><span class="line">            p.next = null;</span><br><span class="line">            if (o == null)</span><br><span class="line">                head = next;</span><br><span class="line">            else</span><br><span class="line">                o.next = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (head == null)   // no more iterators to track</span><br><span class="line">        itrs = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、Itr的removeAt方法"><a href="#14、Itr的removeAt方法" class="headerlink" title="14、Itr的removeAt方法"></a>14、Itr的removeAt方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">boolean removedAt(int removedIndex) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    if (isDetached())</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    final int cycles = itrs.cycles;</span><br><span class="line">    final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">    final int prevCycles = this.prevCycles;</span><br><span class="line">    final int prevTakeIndex = this.prevTakeIndex;</span><br><span class="line">    final int len = items.length;</span><br><span class="line">    int cycleDiff = cycles - prevCycles;</span><br><span class="line">    if (removedIndex &lt; takeIndex)</span><br><span class="line">        cycleDiff++;</span><br><span class="line">    //删除的元素到上个take元素的距离</span><br><span class="line">    final int removedDistance =</span><br><span class="line">        (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">    // assert removedDistance &gt;= 0;</span><br><span class="line">    int cursor = this.cursor;</span><br><span class="line">    //更新游标</span><br><span class="line">    if (cursor &gt;= 0) &#123;</span><br><span class="line">        int x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">        if (x == removedDistance) &#123;</span><br><span class="line">        //删除的是cursor上的元素</span><br><span class="line">            if (cursor == putIndex)</span><br><span class="line">                this.cursor = cursor = NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x &gt; removedDistance) &#123;</span><br><span class="line">        //删除的元素在cursor之前,cursor前移一位</span><br><span class="line">            this.cursor = cursor = dec(cursor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int lastRet = this.lastRet;</span><br><span class="line">    //更新最近获取元素下标</span><br><span class="line">    if (lastRet &gt;= 0) &#123;</span><br><span class="line">        int x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">        //删除的正好是</span><br><span class="line">        if (x == removedDistance)</span><br><span class="line">            this.lastRet = lastRet = REMOVED;</span><br><span class="line">        else if (x &gt; removedDistance)</span><br><span class="line">            this.lastRet = lastRet = dec(lastRet);</span><br><span class="line">    &#125;</span><br><span class="line">    int nextIndex = this.nextIndex;</span><br><span class="line">    //更新下一个元素下标</span><br><span class="line">    if (nextIndex &gt;= 0) &#123;</span><br><span class="line">        int x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">        if (x == removedDistance)</span><br><span class="line">            this.nextIndex = nextIndex = REMOVED;</span><br><span class="line">        else if (x &gt; removedDistance)</span><br><span class="line">            this.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) &#123;</span><br><span class="line">    //迭代器，已被关闭</span><br><span class="line">        this.prevTakeIndex = DETACHED;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、ArrayBlockingQueue的removeAt方法"><a href="#15、ArrayBlockingQueue的removeAt方法" class="headerlink" title="15、ArrayBlockingQueue的removeAt方法"></a>15、ArrayBlockingQueue的removeAt方法</h4><p>获取迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="16、实例化Itr"><a href="#16、实例化Itr" class="headerlink" title="16、实例化Itr"></a>16、实例化Itr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;</span><br><span class="line">    lastRet = NONE;</span><br><span class="line">    final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            // assert itrs == null;</span><br><span class="line">            cursor = NONE;</span><br><span class="line">            nextIndex = NONE;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">            prevTakeIndex = takeIndex;</span><br><span class="line">            nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">            //游标，下标后移一位,该位置元素不存在则返回-1</span><br><span class="line">            cursor = incCursor(takeIndex);</span><br><span class="line">            if (itrs == null) &#123;</span><br><span class="line">                //创建迭代器容器，并创建迭代器</span><br><span class="line">                itrs = new Itrs(this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //将迭代器，加入队列</span><br><span class="line">                itrs.register(this); // in this order</span><br><span class="line">                //清除过期迭代器</span><br><span class="line">                itrs.doSomeSweeping(false);</span><br><span class="line">            &#125;</span><br><span class="line">            //循环数组轮次</span><br><span class="line">            prevCycles = itrs.cycles;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、实例化Itrs"><a href="#17、实例化Itrs" class="headerlink" title="17、实例化Itrs"></a>17、实例化Itrs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Itrs(Itr initial) &#123;</span><br><span class="line">    register(initial);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、Itrs的register方法"><a href="#18、Itrs的register方法" class="headerlink" title="18、Itrs的register方法"></a>18、Itrs的register方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void register(Itr itr) &#123;</span><br><span class="line">    //新节点放在队首 </span><br><span class="line">    head = new Node(itr, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19、接（三、16）Itrs的doSomeSweeping方法"><a href="#19、接（三、16）Itrs的doSomeSweeping方法" class="headerlink" title="19、接（三、16）Itrs的doSomeSweeping方法"></a>19、接（三、16）Itrs的doSomeSweeping方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void doSomeSweeping(boolean tryHarder) &#123;</span><br><span class="line">    //迭代次数</span><br><span class="line">    int probes = tryHarder ? LONG_SWEEP_PROBES : SHORT_SWEEP_PROBES;</span><br><span class="line">    Node o, p;</span><br><span class="line">    final Node sweeper = this.sweeper;</span><br><span class="line">    boolean passedGo;   // to limit search to one full sweep</span><br><span class="line">    //sweeper不存在从头开始，存在从sweeper开始</span><br><span class="line">    if (sweeper == null) &#123;</span><br><span class="line">        o = null;</span><br><span class="line">        p = head;</span><br><span class="line">        passedGo = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        o = sweeper;</span><br><span class="line">        p = o.next;</span><br><span class="line">        passedGo = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (; probes &gt; 0; probes--) &#123;</span><br><span class="line">        //sweeper后一个不存在，从头开始</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            if (passedGo)</span><br><span class="line">                break;</span><br><span class="line">            o = null;</span><br><span class="line">            p = head;</span><br><span class="line">            passedGo = true;</span><br><span class="line">        &#125;</span><br><span class="line">        final Itr it = p.get();</span><br><span class="line">        final Node next = p.next;</span><br><span class="line">        if (it == null || it.isDetached()) &#123;</span><br><span class="line">            //发现一个过期迭代器，继续往后排查16个</span><br><span class="line">            probes = LONG_SWEEP_PROBES; // &quot;try harder&quot;</span><br><span class="line">            //清除过期迭代器</span><br><span class="line">            p.clear();</span><br><span class="line">            p.next = null;</span><br><span class="line">            if (o == null) &#123;</span><br><span class="line">                head = next;</span><br><span class="line">                if (next == null) &#123;</span><br><span class="line">                    // We&apos;ve run out of iterators to track; retire</span><br><span class="line">                    itrs = null;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                o.next = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    //本次排查到的位置</span><br><span class="line">    this.sweeper = (p == null) ? null : o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20、Itr的hasNext方法"><a href="#20、Itr的hasNext方法" class="headerlink" title="20、Itr的hasNext方法"></a>20、Itr的hasNext方法</h4><p>查看是否有下一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 0;</span><br><span class="line">    if (nextItem != null)</span><br><span class="line">        return true;</span><br><span class="line">    //废弃迭代器</span><br><span class="line">    noNext();</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="21、Itr的noNext方法"><a href="#21、Itr的noNext方法" class="headerlink" title="21、Itr的noNext方法"></a>21、Itr的noNext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void noNext() &#123;</span><br><span class="line">    final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //迭代器有效</span><br><span class="line">        if (!isDetached()) &#123;</span><br><span class="line">            //更新迭代器</span><br><span class="line">            incorporateDequeues(); // might update lastRet</span><br><span class="line">            if (lastRet &gt;= 0) &#123;</span><br><span class="line">                lastItem = itemAt(lastRet);</span><br><span class="line">                //废弃该迭代器</span><br><span class="line">                detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22、Itr的next方法"><a href="#22、Itr的next方法" class="headerlink" title="22、Itr的next方法"></a>22、Itr的next方法</h4><p>获取下一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    final E x = nextItem;</span><br><span class="line">    if (x == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (!isDetached())</span><br><span class="line">            //更新迭代器</span><br><span class="line">            incorporateDequeues();</span><br><span class="line">        lastRet = nextIndex;</span><br><span class="line">        final int cursor = this.cursor;</span><br><span class="line">        if (cursor &gt;= 0) &#123;</span><br><span class="line">            //下一个元素</span><br><span class="line">            nextItem = itemAt(nextIndex = cursor);</span><br><span class="line">            //游标后移</span><br><span class="line">            this.cursor = incCursor(cursor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //下一个元素不存在</span><br><span class="line">            nextIndex = NONE;</span><br><span class="line">            nextItem = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="23、Itr的incorporateDequeues方法"><a href="#23、Itr的incorporateDequeues方法" class="headerlink" title="23、Itr的incorporateDequeues方法"></a>23、Itr的incorporateDequeues方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void incorporateDequeues() &#123;</span><br><span class="line"></span><br><span class="line">    final int cycles = itrs.cycles;</span><br><span class="line">    final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">    final int prevCycles = this.prevCycles;</span><br><span class="line">    final int prevTakeIndex = this.prevTakeIndex;</span><br><span class="line"></span><br><span class="line">    if (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;</span><br><span class="line">        final int len = items.length;</span><br><span class="line">       </span><br><span class="line">        long dequeues = (cycles - prevCycles) * len</span><br><span class="line">            + (takeIndex - prevTakeIndex);</span><br><span class="line"></span><br><span class="line">        //新的takeIndex在lastRet之后</span><br><span class="line">        if (invalidated(lastRet, prevTakeIndex, dequeues, len))</span><br><span class="line">            lastRet = REMOVED;</span><br><span class="line">        //新的takeIndex在nextIndex之后</span><br><span class="line">        if (invalidated(nextIndex, prevTakeIndex, dequeues, len))</span><br><span class="line">            nextIndex = REMOVED;</span><br><span class="line">        //新的takeIndex在cursor之后</span><br><span class="line">        if (invalidated(cursor, prevTakeIndex, dequeues, len))</span><br><span class="line">            cursor = takeIndex;</span><br><span class="line">        if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0)</span><br><span class="line">            //废弃迭代器</span><br><span class="line">            detach();</span><br><span class="line">        else &#123;</span><br><span class="line">            this.prevCycles = cycles;</span><br><span class="line">            this.prevTakeIndex = takeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、LinkedBlockingQueue"><a href="#四、LinkedBlockingQueue" class="headerlink" title="四、LinkedBlockingQueue"></a>四、LinkedBlockingQueue</h3><h4 id="1、实例化LinkedBlockingQueue"><a href="#1、实例化LinkedBlockingQueue" class="headerlink" title="1、实例化LinkedBlockingQueue"></a>1、实例化LinkedBlockingQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LinkedBlockingQueue的offer方法"><a href="#2、LinkedBlockingQueue的offer方法" class="headerlink" title="2、LinkedBlockingQueue的offer方法"></a>2、LinkedBlockingQueue的offer方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    //达到最大限制</span><br><span class="line">    if (count.get() == capacity)</span><br><span class="line">        return false;</span><br><span class="line">    int c = -1;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    //获取写锁</span><br><span class="line">    putLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &lt; capacity) &#123;</span><br><span class="line">            //新增节点加入队尾</span><br><span class="line">            enqueue(node);</span><br><span class="line">            //元素数量加一</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                //唤醒等待的写线程</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        //唤醒等待获取的线程</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return c &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、LinkedBlockingQueue的take方法"><a href="#3、LinkedBlockingQueue的take方法" class="headerlink" title="3、LinkedBlockingQueue的take方法"></a>3、LinkedBlockingQueue的take方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            //队列为空，线程等待</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        //从队首获取元素</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            //唤醒等待获取的线程</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        //释放等待添加的线程</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、LinkedBlockingQueue的remove方法"><a href="#4、LinkedBlockingQueue的remove方法" class="headerlink" title="4、LinkedBlockingQueue的remove方法"></a>4、LinkedBlockingQueue的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) return false;</span><br><span class="line">    //获取锁</span><br><span class="line">    fullyLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != null;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            if (o.equals(p.item)) &#123;</span><br><span class="line">                //删除该元素</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、LinkedBlockingQueue的iterator方法"><a href="#5、LinkedBlockingQueue的iterator方法" class="headerlink" title="5、LinkedBlockingQueue的iterator方法"></a>5、LinkedBlockingQueue的iterator方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、实例化Itr"><a href="#6、实例化Itr" class="headerlink" title="6、实例化Itr"></a>6、实例化Itr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;</span><br><span class="line">    fullyLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //初始化当前元素</span><br><span class="line">        current = head.next;</span><br><span class="line">        if (current != null)</span><br><span class="line">            currentElement = current.item;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、Itr的hasNext方法"><a href="#7、Itr的hasNext方法" class="headerlink" title="7、Itr的hasNext方法"></a>7、Itr的hasNext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return current != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、Itr的next方法"><a href="#8、Itr的next方法" class="headerlink" title="8、Itr的next方法"></a>8、Itr的next方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    fullyLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (current == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        E x = currentElement;</span><br><span class="line">        //最近获取元素</span><br><span class="line">        lastRet = current;</span><br><span class="line">        //更新current</span><br><span class="line">        current = nextNode(current);</span><br><span class="line">        currentElement = (current == null) ? null : current.item;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、Itr的nextNode方法"><a href="#9、Itr的nextNode方法" class="headerlink" title="9、Itr的nextNode方法"></a>9、Itr的nextNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node&lt;E&gt; s = p.next;</span><br><span class="line">        //p已被取出</span><br><span class="line">        if (s == p)</span><br><span class="line">            return head.next;</span><br><span class="line">        if (s == null || s.item != null)</span><br><span class="line">            return s;</span><br><span class="line">        //s已被删除，向后迭代获取</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、LinkedBlockingDeque"><a href="#五、LinkedBlockingDeque" class="headerlink" title="五、LinkedBlockingDeque"></a>五、LinkedBlockingDeque</h3><h4 id="1、实例化LinkedBlockingDeque"><a href="#1、实例化LinkedBlockingDeque" class="headerlink" title="1、实例化LinkedBlockingDeque"></a>1、实例化LinkedBlockingDeque</h4><p>LinkedBlockingDeque为双向队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingDeque() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingDeque(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LinkedBlockingDeque的offer方法"><a href="#2、LinkedBlockingDeque的offer方法" class="headerlink" title="2、LinkedBlockingDeque的offer方法"></a>2、LinkedBlockingDeque的offer方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    return offerLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、LinkedBlockingDeque的offerLast方法"><a href="#3、LinkedBlockingDeque的offerLast方法" class="headerlink" title="3、LinkedBlockingDeque的offerLast方法"></a>3、LinkedBlockingDeque的offerLast方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return linkLast(node);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、LinkedBlockingDeque的linkLast方法"><a href="#4、LinkedBlockingDeque的linkLast方法" class="headerlink" title="4、LinkedBlockingDeque的linkLast方法"></a>4、LinkedBlockingDeque的linkLast方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private boolean linkLast(Node&lt;E&gt; node) &#123;</span><br><span class="line">    //超出数量限制</span><br><span class="line">    if (count &gt;= capacity)</span><br><span class="line">        return false;</span><br><span class="line">    //获取队尾</span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    //添加到队尾</span><br><span class="line">    node.prev = l;</span><br><span class="line">    //更新队尾</span><br><span class="line">    last = node;</span><br><span class="line">    //设置队首</span><br><span class="line">    if (first == null)</span><br><span class="line">        first = node;</span><br><span class="line">    else</span><br><span class="line">        l.next = node;</span><br><span class="line">    ++count;</span><br><span class="line">    //唤醒等待获取的线程</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、LinkedBlockingDeque的take方法"><a href="#5、LinkedBlockingDeque的take方法" class="headerlink" title="5、LinkedBlockingDeque的take方法"></a>5、LinkedBlockingDeque的take方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    return takeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、LinkedBlockingDeque的takeFirst方法"><a href="#6、LinkedBlockingDeque的takeFirst方法" class="headerlink" title="6、LinkedBlockingDeque的takeFirst方法"></a>6、LinkedBlockingDeque的takeFirst方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E takeFirst() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        E x;</span><br><span class="line">        // 若队列为空，则一直等待。否则，通过unlinkFirst()删除第一个节点。</span><br><span class="line">        while ( (x = unlinkFirst()) == null)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、LinkedBlockingDeque的unlinkFirst方法"><a href="#7、LinkedBlockingDeque的unlinkFirst方法" class="headerlink" title="7、LinkedBlockingDeque的unlinkFirst方法"></a>7、LinkedBlockingDeque的unlinkFirst方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private E unlinkFirst() &#123;</span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        return null;</span><br><span class="line">    // 删除并更新第一个节点</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = null;</span><br><span class="line">    f.next = f; // help GC</span><br><span class="line">    first = n;</span><br><span class="line">    if (n == null)</span><br><span class="line">        last = null;</span><br><span class="line">    else</span><br><span class="line">        n.prev = null;</span><br><span class="line">    --count;</span><br><span class="line">    //唤醒等待添加线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、LinkedBlockingDeque的iterator方法"><a href="#8、LinkedBlockingDeque的iterator方法" class="headerlink" title="8、LinkedBlockingDeque的iterator方法"></a>8、LinkedBlockingDeque的iterator方法</h4><p>正向迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9、实例化Itr"><a href="#9、实例化Itr" class="headerlink" title="9、实例化Itr"></a>9、实例化Itr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractItr() &#123;</span><br><span class="line">    // set to initial position</span><br><span class="line">    final ReentrantLock lock = LinkedBlockingDeque.this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        next = firstNode();</span><br><span class="line">        nextItem = (next == null) ? null : next.item;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private class Itr extends AbstractItr &#123;</span><br><span class="line">    Node&lt;E&gt; firstNode() &#123; return first; &#125;</span><br><span class="line">    Node&lt;E&gt; nextNode(Node&lt;E&gt; n) &#123; return n.next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、Itr的hasNext方法"><a href="#10、Itr的hasNext方法" class="headerlink" title="10、Itr的hasNext方法"></a>10、Itr的hasNext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return next != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、Itr的next方法"><a href="#11、Itr的next方法" class="headerlink" title="11、Itr的next方法"></a>11、Itr的next方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    if (next == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    lastRet = next;</span><br><span class="line">    E x = nextItem;</span><br><span class="line">    //更新next和nextItem</span><br><span class="line">    advance();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、Itr的advance方法"><a href="#12、Itr的advance方法" class="headerlink" title="12、Itr的advance方法"></a>12、Itr的advance方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void advance() &#123;</span><br><span class="line">    final ReentrantLock lock = LinkedBlockingDeque.this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取下一个节点</span><br><span class="line">        next = succ(next);</span><br><span class="line">        nextItem = (next == null) ? null : next.item;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、Itr的succ方法"><a href="#13、Itr的succ方法" class="headerlink" title="13、Itr的succ方法"></a>13、Itr的succ方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Node&lt;E&gt; succ(Node&lt;E&gt; n) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取下一个节点</span><br><span class="line">        Node&lt;E&gt; s = nextNode(n);</span><br><span class="line">        if (s == null)</span><br><span class="line">            return null;</span><br><span class="line">        else if (s.item != null)</span><br><span class="line">            return s;</span><br><span class="line">        else if (s == n)</span><br><span class="line">        //n节点已被取出，重新返回头节点</span><br><span class="line">            return firstNode();</span><br><span class="line">        else</span><br><span class="line">        //n被删除，迭代下一个节点</span><br><span class="line">            n = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、ConcurrentLinkedQueue"><a href="#六、ConcurrentLinkedQueue" class="headerlink" title="六、ConcurrentLinkedQueue"></a>六、ConcurrentLinkedQueue</h3><h4 id="1、实例化ConcurrentLinkedQueue"><a href="#1、实例化ConcurrentLinkedQueue" class="headerlink" title="1、实例化ConcurrentLinkedQueue"></a>1、实例化ConcurrentLinkedQueue</h4><p>item为删除的锁<br>next为添加的锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    head = tail = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、ConcurrentLinkedQueue的add方法"><a href="#2、ConcurrentLinkedQueue的add方法" class="headerlink" title="2、ConcurrentLinkedQueue的add方法"></a>2、ConcurrentLinkedQueue的add方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ConcurrentLinkedQueue的offer方法"><a href="#3、ConcurrentLinkedQueue的offer方法" class="headerlink" title="3、ConcurrentLinkedQueue的offer方法"></a>3、ConcurrentLinkedQueue的offer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            //新节点加入队尾，失败了重新循环</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                //更新队尾</span><br><span class="line">                if (p != t) // hop two nodes at a time</span><br><span class="line">                    casTail(t, newNode);  // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p == q)</span><br><span class="line">        //p已被删除，重新查找队尾 </span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">        //p已不是队尾，向后迭代</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ConcurrentLinkedQueue的poll方法"><a href="#4、ConcurrentLinkedQueue的poll方法" class="headerlink" title="4、ConcurrentLinkedQueue的poll方法"></a>4、ConcurrentLinkedQueue的poll方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">            //获取该节点</span><br><span class="line">                //更新头节点</span><br><span class="line">                if (p != h) // hop two nodes at a time</span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">            //队列已空，获取不到</span><br><span class="line">                //更新头节点</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p == q)</span><br><span class="line">            //p节点已被删除，重新查找</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else</span><br><span class="line">            //该节点已被其他线程获取，向后迭代</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、ConcurrentLinkedQueue的remove方法"><a href="#5、ConcurrentLinkedQueue的remove方法" class="headerlink" title="5、ConcurrentLinkedQueue的remove方法"></a>5、ConcurrentLinkedQueue的remove方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o != null) &#123;</span><br><span class="line">        Node&lt;E&gt; next, pred = null;</span><br><span class="line">        for (Node&lt;E&gt; p = first(); p != null; pred = p, p = next) &#123;</span><br><span class="line">            boolean removed = false;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            if (item != null) &#123;</span><br><span class="line">                if (!o.equals(item)) &#123;</span><br><span class="line">                    //查找下一个节点继续迭代</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //删除p</span><br><span class="line">                removed = p.casItem(item, null);</span><br><span class="line">            &#125;</span><br><span class="line">            next = succ(p);</span><br><span class="line">            if (pred != null &amp;&amp; next != null) // unlink</span><br><span class="line">                //节点踢出队列</span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            if (removed)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC集合(2)ConcurrentSkipListMap</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E9%9B%86%E5%90%88(2)ConcurrentSkipListMap/"/>
      <content type="html"><![CDATA[<h2 id="JUC集合-2-ConcurrentSkipListMap"><a href="#JUC集合-2-ConcurrentSkipListMap" class="headerlink" title="JUC集合(2)ConcurrentSkipListMap"></a>JUC集合(2)ConcurrentSkipListMap</h2><h3 id="一、ConcurrentSkipListMap"><a href="#一、ConcurrentSkipListMap" class="headerlink" title="一、ConcurrentSkipListMap"></a>一、ConcurrentSkipListMap</h3><h4 id="1、实例化ConcurrentSkipListMap"><a href="#1、实例化ConcurrentSkipListMap" class="headerlink" title="1、实例化ConcurrentSkipListMap"></a>1、实例化ConcurrentSkipListMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = Node.class;</span><br><span class="line">        //value的位置偏移。删除节点的锁</span><br><span class="line">        valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        /后继节点的位置偏移。新增节点的锁</span><br><span class="line">        nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;next&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentSkipListMap() &#123;</span><br><span class="line">    this.comparator = null;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void initialize() &#123;</span><br><span class="line">    keySet = null;</span><br><span class="line">    entrySet = null;</span><br><span class="line">    values = null;</span><br><span class="line">    descendingMap = null;</span><br><span class="line">    head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null),</span><br><span class="line">                              null, null, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实例化Index"><a href="#2、实例化Index" class="headerlink" title="2、实例化Index"></a>2、实例化Index</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = Index.class;</span><br><span class="line">        //right的位置偏移。操作索引的锁</span><br><span class="line">        rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;right&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">    this.node = node;</span><br><span class="line">    this.down = down;</span><br><span class="line">    this.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、ConcurrentSkipListMap的put方法"><a href="#3、ConcurrentSkipListMap的put方法" class="headerlink" title="3、ConcurrentSkipListMap的put方法"></a>3、ConcurrentSkipListMap的put方法</h4><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return doPut(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、ConcurrentSkipListMap的doPut方法"><a href="#4、ConcurrentSkipListMap的doPut方法" class="headerlink" title="4、ConcurrentSkipListMap的doPut方法"></a>4、ConcurrentSkipListMap的doPut方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> private V doPut(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             // added node</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    outer: for (;;) &#123;</span><br><span class="line">        //由索引查找队列前面最接近的节点</span><br><span class="line">        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            if (n != null) &#123;</span><br><span class="line">                Object v; int c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                //b节点的后继节点已被更改，跳出内循环，重新查找</span><br><span class="line">                if (n != b.next)               // inconsistent read</span><br><span class="line">                    break;</span><br><span class="line">                //n节点被删除，帮助删除，然后重新查找</span><br><span class="line">                if ((v = n.value) == null) &#123;   // n is deleted</span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //b节点已删除</span><br><span class="line">                if (b.value == null || v == n) // b is deleted</span><br><span class="line">                    break;</span><br><span class="line">                //新增节点大于后继节点，后继节点作为当前结点，继续迭代</span><br><span class="line">                if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //新增节点已存在，如果允许则替换</span><br><span class="line">                if (c == 0) &#123;</span><br><span class="line">                    if (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                        return vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break; // restart if lost race to replace value</span><br><span class="line">                &#125;</span><br><span class="line">                // else c &lt; 0; fall through</span><br><span class="line">            &#125;</span><br><span class="line">            z = new Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            //找到前继节点，添加当前节点</span><br><span class="line">            if (!b.casNext(n, z))</span><br><span class="line">                break;         // restart if lost race to append to b</span><br><span class="line">            break outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //随机数</span><br><span class="line">    int rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    if ((rnd &amp; 0x80000001) == 0) &#123; // test highest and lowest bits</span><br><span class="line">        int level = 1, max;</span><br><span class="line">        //1的个数，作为level</span><br><span class="line">        while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = null;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        if (level &lt;= (max = h.level)) &#123;</span><br><span class="line">        //level小于已有的max，直接创建新增节点的索引</span><br><span class="line">            for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // try to grow by one level</span><br><span class="line">        //level大于已有的max</span><br><span class="line">            //将当前的max加一</span><br><span class="line">            level = max + 1; // hold in array and later pick the one to use</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];</span><br><span class="line">            //创建新增节点的索引</span><br><span class="line">            for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                int oldLevel = h.level;</span><br><span class="line">                //其它线程已经，增加了头节点的索引</span><br><span class="line">                if (level &lt;= oldLevel) // lost race to add level</span><br><span class="line">                    break;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                //头节点新增的索引</span><br><span class="line">                for (int j = oldLevel+1; j &lt;= level; ++j)</span><br><span class="line">                    newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                //更新索引头</span><br><span class="line">                if (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // find insertion points and splice in</span><br><span class="line">        splice: for (int insertionLevel = level;;) &#123;</span><br><span class="line">            int j = h.level;</span><br><span class="line">            for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                //节点被删除，重新添加</span><br><span class="line">                if (q == null || t == null)</span><br><span class="line">                    break splice;</span><br><span class="line">                if (r != null) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    // compare before deletion check avoids needing recheck</span><br><span class="line">                    int c = cpr(cmp, key, n.key);</span><br><span class="line">                    //n被删除，获取q的新右索引</span><br><span class="line">                    if (n.value == null) &#123;</span><br><span class="line">                        if (!q.unlink(r))</span><br><span class="line">                            break;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //右节点做当前节点，继续迭代</span><br><span class="line">                    if (c &gt; 0) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (j == insertionLevel) &#123;</span><br><span class="line">                    //添加索引</span><br><span class="line">                    if (!q.link(r, t))</span><br><span class="line">                        break; // restart</span><br><span class="line">                    //节点已删除</span><br><span class="line">                    if (t.node.value == null) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        break splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //全部处理完成</span><br><span class="line">                    if (--insertionLevel == 0)</span><br><span class="line">                        break splice;</span><br><span class="line">                &#125;</span><br><span class="line">                //继续处理下一层索引</span><br><span class="line">                if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、ConcurrentSkipListMap的put方法"><a href="#5、ConcurrentSkipListMap的put方法" class="headerlink" title="5、ConcurrentSkipListMap的put方法"></a>5、ConcurrentSkipListMap的put方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    return doGet(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、ConcurrentSkipListMap的doGet方法"><a href="#6、ConcurrentSkipListMap的doGet方法" class="headerlink" title="6、ConcurrentSkipListMap的doGet方法"></a>6、ConcurrentSkipListMap的doGet方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private V doGet(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    outer: for (;;) &#123;</span><br><span class="line">        //由索引查找队列前面最接近的节点</span><br><span class="line">        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; int c;</span><br><span class="line">            //查到队尾,未找到</span><br><span class="line">            if (n == null)</span><br><span class="line">                break outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            //后继节点已变更，重新查找</span><br><span class="line">            if (n != b.next)                // inconsistent read</span><br><span class="line">                break;</span><br><span class="line">            //n节点已被删除，帮助删除</span><br><span class="line">            if ((v = n.value) == null) &#123;    // n is deleted</span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //b已被删除，重新查找</span><br><span class="line">            if (b.value == null || v == n)  // b is deleted</span><br><span class="line">                break;</span><br><span class="line">            //找到</span><br><span class="line">            if ((c = cpr(cmp, key, n.key)) == 0) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                return vv;</span><br><span class="line">            &#125;</span><br><span class="line">            //未找到</span><br><span class="line">            if (c &lt; 0)</span><br><span class="line">                break outer;</span><br><span class="line">            //后继节点做当前节点，继续迭代</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、ConcurrentSkipListMap的findPredecessor方法"><a href="#7、ConcurrentSkipListMap的findPredecessor方法" class="headerlink" title="7、ConcurrentSkipListMap的findPredecessor方法"></a>7、ConcurrentSkipListMap的findPredecessor方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException(); // don&apos;t postpone errors</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            if (r != null) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                //节点已被删除，帮助删除</span><br><span class="line">                if (n.value == null) &#123;</span><br><span class="line">                    if (!q.unlink(r))</span><br><span class="line">                        break;           // restart</span><br><span class="line">                    r = q.right;         // reread r</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //先往右查找</span><br><span class="line">                if (cpr(cmp, key, k) &gt; 0) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //往下查找，直到索引最下行</span><br><span class="line">            if ((d = q.down) == null)</span><br><span class="line">                return q.node;</span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、ConcurrentSkipListMap的remove方法"><a href="#8、ConcurrentSkipListMap的remove方法" class="headerlink" title="8、ConcurrentSkipListMap的remove方法"></a>8、ConcurrentSkipListMap的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    return doRemove(key, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9、ConcurrentSkipListMap的doRemove方法"><a href="#9、ConcurrentSkipListMap的doRemove方法" class="headerlink" title="9、ConcurrentSkipListMap的doRemove方法"></a>9、ConcurrentSkipListMap的doRemove方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">final V doRemove(Object key, Object value) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    outer: for (;;) &#123;</span><br><span class="line">        //由索引查找队列前面最接近的节点</span><br><span class="line">        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; int c;</span><br><span class="line">            //查到队尾,未找到</span><br><span class="line">            if (n == null)</span><br><span class="line">                break outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            //后继节点已被更改</span><br><span class="line">            if (n != b.next)                    // inconsistent read</span><br><span class="line">                break;</span><br><span class="line">            //节点被删除，帮助删除</span><br><span class="line">            if ((v = n.value) == null) &#123;        // n is deleted</span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //b节点被删除</span><br><span class="line">            if (b.value == null || v == n)      // b is deleted</span><br><span class="line">                break;</span><br><span class="line">            //未找到</span><br><span class="line">            if ((c = cpr(cmp, key, n.key)) &lt; 0)</span><br><span class="line">                break outer;</span><br><span class="line">            //后继节点做当前节点，继续迭代</span><br><span class="line">            if (c &gt; 0) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //该节点值已被替换</span><br><span class="line">            if (value != null &amp;&amp; !value.equals(v))</span><br><span class="line">                break outer;</span><br><span class="line">            //节点值置空</span><br><span class="line">            if (!n.casValue(v, null))</span><br><span class="line">                break;</span><br><span class="line">            if (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">            //标记n节点已被删除且删除节点</span><br><span class="line">                //清空节点索引</span><br><span class="line">                findNode(key);                  // retry via findNode</span><br><span class="line">            else &#123;</span><br><span class="line">                //清空节点索引</span><br><span class="line">                findPredecessor(key, cmp);      // clean index</span><br><span class="line">                //减少索引高度</span><br><span class="line">                if (head.right == null)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">            return vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、ConcurrentSkipListMap的helpDelete方法"><a href="#10、ConcurrentSkipListMap的helpDelete方法" class="headerlink" title="10、ConcurrentSkipListMap的helpDelete方法"></a>10、ConcurrentSkipListMap的helpDelete方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    //尚未标记且尚未删除</span><br><span class="line">    if (f == next &amp;&amp; this == b.next) &#123;</span><br><span class="line">        if (f == null || f.value != f) // not already marked</span><br><span class="line">            //标记n节点被删除</span><br><span class="line">            casNext(f, new Node&lt;K,V&gt;(f));</span><br><span class="line">        else</span><br><span class="line">            //删除n节点</span><br><span class="line">            b.casNext(this, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、接（一、8）ConcurrentSkipListMap的tryReduceLevel方法"><a href="#11、接（一、8）ConcurrentSkipListMap的tryReduceLevel方法" class="headerlink" title="11、接（一、8）ConcurrentSkipListMap的tryReduceLevel方法"></a>11、接（一、8）ConcurrentSkipListMap的tryReduceLevel方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void tryReduceLevel() &#123;</span><br><span class="line">    HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">    HeadIndex&lt;K,V&gt; d;</span><br><span class="line">    HeadIndex&lt;K,V&gt; e;</span><br><span class="line">    //索引高度大于3，</span><br><span class="line">    //最高三层头索引，右节点索引都不存在,减一层索引，并检查删除的头节点索引是否又被新的右索引</span><br><span class="line">    if (h.level &gt; 3 &amp;&amp;</span><br><span class="line">        (d = (HeadIndex&lt;K,V&gt;)h.down) != null &amp;&amp;</span><br><span class="line">        (e = (HeadIndex&lt;K,V&gt;)d.down) != null &amp;&amp;</span><br><span class="line">        e.right == null &amp;&amp;</span><br><span class="line">        d.right == null &amp;&amp;</span><br><span class="line">        h.right == null &amp;&amp;</span><br><span class="line">        casHead(h, d) &amp;&amp; // try to set</span><br><span class="line">        h.right != null) // recheck</span><br><span class="line">        casHead(d, h);   // try to backout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、ConcurrentSkipListSet"><a href="#二、ConcurrentSkipListSet" class="headerlink" title="二、ConcurrentSkipListSet"></a>二、ConcurrentSkipListSet</h3><h4 id="1、实例化ConcurrentSkipListSet"><a href="#1、实例化ConcurrentSkipListSet" class="headerlink" title="1、实例化ConcurrentSkipListSet"></a>1、实例化ConcurrentSkipListSet</h4><p>内部通过一个ConcurrentSkipListMap实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentSkipListSet() &#123;</span><br><span class="line">    m = new ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、ConcurrentSkipListSet的add方法"><a href="#2、ConcurrentSkipListSet的add方法" class="headerlink" title="2、ConcurrentSkipListSet的add方法"></a>2、ConcurrentSkipListSet的add方法</h4><p>添加元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return m.putIfAbsent(e, Boolean.TRUE) == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ConcurrentSkipListMap的putIfAbsent方法"><a href="#3、ConcurrentSkipListMap的putIfAbsent方法" class="headerlink" title="3、ConcurrentSkipListMap的putIfAbsent方法"></a>3、ConcurrentSkipListMap的putIfAbsent方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V putIfAbsent(K key, V value) &#123;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return doPut(key, value, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ConcurrentSkipListSet的contains方法"><a href="#4、ConcurrentSkipListSet的contains方法" class="headerlink" title="4、ConcurrentSkipListSet的contains方法"></a>4、ConcurrentSkipListSet的contains方法</h4><p>元素是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return m.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、ConcurrentSkipListMap的containsKey方法"><a href="#5、ConcurrentSkipListMap的containsKey方法" class="headerlink" title="5、ConcurrentSkipListMap的containsKey方法"></a>5、ConcurrentSkipListMap的containsKey方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsKey(Object key) &#123;</span><br><span class="line">    return doGet(key) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、ConcurrentSkipListMap的doGet方法-1"><a href="#6、ConcurrentSkipListMap的doGet方法-1" class="headerlink" title="6、ConcurrentSkipListMap的doGet方法"></a>6、ConcurrentSkipListMap的doGet方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private V doGet(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    outer: for (;;) &#123;</span><br><span class="line">        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; int c;</span><br><span class="line">            if (n == null)</span><br><span class="line">                break outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            if (n != b.next)                // inconsistent read</span><br><span class="line">                break;</span><br><span class="line">            if ((v = n.value) == null) &#123;    // n is deleted</span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (b.value == null || v == n)  // b is deleted</span><br><span class="line">                break;</span><br><span class="line">            if ((c = cpr(cmp, key, n.key)) == 0) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                return vv;</span><br><span class="line">            &#125;</span><br><span class="line">            if (c &lt; 0)</span><br><span class="line">                break outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、ConcurrentSkipListSet的remove方法"><a href="#7、ConcurrentSkipListSet的remove方法" class="headerlink" title="7、ConcurrentSkipListSet的remove方法"></a>7、ConcurrentSkipListSet的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return m.remove(o, Boolean.TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、ConcurrentSkipListMap的remove方法-1"><a href="#8、ConcurrentSkipListMap的remove方法-1" class="headerlink" title="8、ConcurrentSkipListMap的remove方法"></a>8、ConcurrentSkipListMap的remove方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object key, Object value) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return value != null &amp;&amp; doRemove(key, value) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC集合(1)ConcurrentHashMap</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E9%9B%86%E5%90%88(1)ConcurrentHashMap/"/>
      <content type="html"><![CDATA[<h2 id="JUC集合-1-ConcurrentHashMap"><a href="#JUC集合-1-ConcurrentHashMap" class="headerlink" title="JUC集合(1)ConcurrentHashMap"></a>JUC集合(1)ConcurrentHashMap</h2><h3 id="一、ConcurrentHashMap"><a href="#一、ConcurrentHashMap" class="headerlink" title="一、ConcurrentHashMap"></a>一、ConcurrentHashMap</h3><h4 id="1、实例化ConcurrentHashMap"><a href="#1、实例化ConcurrentHashMap" class="headerlink" title="1、实例化ConcurrentHashMap"></a>1、实例化ConcurrentHashMap</h4><p>JDK1.8的ConcurrentHashMap的实现方式与之前不同，采用的是数组链表方式，当链表里数据过多的时候，链表自动转换为红黑树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        //数组扩容的锁，在对象中的位置偏移</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;sizeCtl&quot;));</span><br><span class="line">        //transferIndex扩容时处理到的数组下标值，在对象中的位置偏移。扩容时线程获取处理链表的锁</span><br><span class="line">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;transferIndex&quot;));</span><br><span class="line">        //元素的数量，在对象中的位置偏移</span><br><span class="line">        BASECOUNT = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;baseCount&quot;));</span><br><span class="line">        //存放元素数量数组扩容锁，在对象中的位置偏移</span><br><span class="line">        CELLSBUSY = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;cellsBusy&quot;));</span><br><span class="line">        Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        //存放的是部分元素的数量</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">            (ck.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        //数组第一个元素相对于数组起始位置的偏移</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        //数组元素的大小</span><br><span class="line">        int scale = U.arrayIndexScale(ak);</span><br><span class="line">        if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">            throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">        ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、ConcurrentHashMap的put方法"><a href="#2、ConcurrentHashMap的put方法" class="headerlink" title="2、ConcurrentHashMap的put方法"></a>2、ConcurrentHashMap的put方法</h4><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ConcurrentHashMap的putVal方法"><a href="#3、ConcurrentHashMap的putVal方法" class="headerlink" title="3、ConcurrentHashMap的putVal方法"></a>3、ConcurrentHashMap的putVal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //获取key的hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            //节点数组不存在</span><br><span class="line">            //初始化节点数组</span><br><span class="line">            tab = initTable();</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //节点数组长度与key的hash值取模作为key在节点数组中的下标</span><br><span class="line">            //若数组该下标节点不存在，则用当前的key、value新建一个节点，添加进数组</span><br><span class="line">            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            //数组正在扩容</span><br><span class="line">            //参与到扩容中去</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            //数组该下标节点已存在，且有效</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            //获取该节点的对象锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //数组该下标节点任然等于f，说明未被其他线程更改</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        //该节点hash值大于零，表示该节点仍为普通节点</span><br><span class="line">                        //该链表节点数</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            //该节点key与添加的key相等</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                //是否允许覆盖</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                //将当前key、value新建节点，加入链表最后</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        //f节点为红黑树</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        //往红黑树中添加该key、value</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                //链表元素超过8个</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    //重新设置数组长度或者将链表转换为红黑树</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //增加元素数量</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ConcurrentHashMap的initTable方法"><a href="#4、ConcurrentHashMap的initTable方法" class="headerlink" title="4、ConcurrentHashMap的initTable方法"></a>4、ConcurrentHashMap的initTable方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    //table不存在</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            //其他线程已经在初始化，本线程进入待执行状态</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            //将sizeCtl改为-1，获取数组扩容锁</span><br><span class="line">            try &#123;</span><br><span class="line">                //table不存在，须初始化</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    //sc大于零说明实例化的时候给了数组的容量</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    //创建一个空数组，赋值给table</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（一、3）ConcurrentHashMap的helpTransfer方法"><a href="#5、接（一、3）ConcurrentHashMap的helpTransfer方法" class="headerlink" title="5、接（一、3）ConcurrentHashMap的helpTransfer方法"></a>5、接（一、3）ConcurrentHashMap的helpTransfer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">    //正在扩容</span><br><span class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">        //获取锁标志</span><br><span class="line">        int rs = resizeStamp(tab.length);</span><br><span class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">            //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 表示数组初始化状态</span><br><span class="line">            //sc == rs + 1 表示数组扩容已完成</span><br><span class="line">            //sc == rs + MAX_RESIZERS 表示获取锁的线程已达到上限</span><br><span class="line">            //剩余条件均表示扩容已完成</span><br><span class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            //获取锁</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                //参与扩容</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、接（一、3）ConcurrentHashMap的treeifyBin方法"><a href="#6、接（一、3）ConcurrentHashMap的treeifyBin方法" class="headerlink" title="6、接（一、3）ConcurrentHashMap的treeifyBin方法"></a>6、接（一、3）ConcurrentHashMap的treeifyBin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            //数组长度未达到，最小转换红黑数的长度</span><br><span class="line">            //扩大数组容量</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            //b.hash大于等于零,b是普通节点</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line">                //节点b未发生改变</span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    //将b及之后的元素，加入一个TreeNode队列</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        //创建双向队列</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //把TreeNode队列加入TreeBin，并转换为红黑树，然后加入数组</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、ConcurrentHashMap的tryPresize方法"><a href="#7、ConcurrentHashMap的tryPresize方法" class="headerlink" title="7、ConcurrentHashMap的tryPresize方法"></a>7、ConcurrentHashMap的tryPresize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    //获取新数组的容量</span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    //锁未被获取</span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123;</span><br><span class="line">        //数组不存在</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            //获取锁</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //数组未改变，初始化数组</span><br><span class="line">                    if (table == tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        //无需扩容</span><br><span class="line">            break;</span><br><span class="line">        else if (tab == table) &#123;</span><br><span class="line">            //由数组长度，获取锁标志</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">            //锁已被获取</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 表示数组初始化状态</span><br><span class="line">                //sc == rs + 1 表示数组扩容已完成</span><br><span class="line">                //sc == rs + MAX_RESIZERS 表示获取锁的线程已达到上限</span><br><span class="line">                //剩余条件均表示扩容已完成</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                //获取锁，并参与到扩容中去</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">            //锁未被其他线程获取，并且本线程已获取到锁</span><br><span class="line">                //扩容数组</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、ConcurrentHashMap的transfer方法"><a href="#8、ConcurrentHashMap的transfer方法" class="headerlink" title="8、ConcurrentHashMap的transfer方法"></a>8、ConcurrentHashMap的transfer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    //stride线程一批处理数组中链表的个数</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    //扩容后的数组尚不存在，初始化</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    //扩容后数组的长度</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    //扩容数组时，替代老数组中的处理完的链表</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    //本批次是否处理完成</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    //数组扩容完成</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">            //本批次尚未处理完成，或已经全部处理完成</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">            //已没有可以处理的批次</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                //transferIndex当前处理到的数组下标</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">        //已处理完</span><br><span class="line">            int sc;</span><br><span class="line">            //全部处理完成</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                //更新table</span><br><span class="line">                table = nextTab;</span><br><span class="line">                //释放锁</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">            //释放一层锁</span><br><span class="line">                //表明尚有其他线程正在处理</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                //已全部处理完成</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">        //数组该位置未有元素</span><br><span class="line">            //设置老数组该位置元素为fwd</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">        //已处理</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //数组该位置未改变</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                    //f为普通节点</span><br><span class="line">                        //hash值&amp;n表示扩容后取模的值，是否增加n</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                //链表最后的元素</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //将原链表元素，重新分为两个链表</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //更新新数组元素</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //更新老数组元素</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                    //f为红黑树</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        //根据扩容后的数组长度与hash值取模的值，创建两个TreeNode队列</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //根据节点数量，判断构造红黑树，或者构造链表</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、ConcurrentHashMap的untreeify方法"><a href="#9、ConcurrentHashMap的untreeify方法" class="headerlink" title="9、ConcurrentHashMap的untreeify方法"></a>9、ConcurrentHashMap的untreeify方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; Node&lt;K,V&gt; untreeify(Node&lt;K,V&gt; b) &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">    //创建链表</span><br><span class="line">    for (Node&lt;K,V&gt; q = b; q != null; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = new Node&lt;K,V&gt;(q.hash, q.key, q.val, null);</span><br><span class="line">        if (tl == null)</span><br><span class="line">            hd = p;</span><br><span class="line">        else</span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    return hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、接（一、3）ConcurrentHashMap的addCount方法"><a href="#10、接（一、3）ConcurrentHashMap的addCount方法" class="headerlink" title="10、接（一、3）ConcurrentHashMap的addCount方法"></a>10、接（一、3）ConcurrentHashMap的addCount方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">    CounterCell[] as; long b, s;</span><br><span class="line">    //默认用baseCount计数，如果并发争用失败，创建counterCells数组用于计数</span><br><span class="line">    if ((as = counterCells) != null ||</span><br><span class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; long v; int m;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            //元素数量增加x</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &lt;= 1)</span><br><span class="line">            return;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    if (check &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">        //元素个数大于sizeCtl扩容数组</span><br><span class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、ConcurrentHashMap的fullAddCount方法"><a href="#11、ConcurrentHashMap的fullAddCount方法" class="headerlink" title="11、ConcurrentHashMap的fullAddCount方法"></a>11、ConcurrentHashMap的fullAddCount方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">private final void fullAddCount(long x, boolean wasUncontended) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //获取一个随机数</span><br><span class="line">    if ((h = ThreadLocalRandom.getProbe()) == 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      // force initialization</span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean collide = false;                // True if last slot nonempty</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; int n; long v;</span><br><span class="line">        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;</span><br><span class="line">        //counterCells数组存在</span><br><span class="line">            if ((a = as[(n - 1) &amp; h]) == null) &#123;</span><br><span class="line">            //该位置没有元素</span><br><span class="line">                if (cellsBusy == 0) &#123;            // Try to attach new Cell</span><br><span class="line">                //cellsBusy锁空闲</span><br><span class="line">                    //创建一个计数器</span><br><span class="line">                    CounterCell r = new CounterCell(x); // Optimistic create</span><br><span class="line">                    //获取锁</span><br><span class="line">                    if (cellsBusy == 0 &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">                        boolean created = false;</span><br><span class="line">                        try &#123;               // Recheck under lock</span><br><span class="line">                            CounterCell[] rs; int m, j;</span><br><span class="line">                            if ((rs = counterCells) != null &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                                rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                                //添加进数组</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            //释放锁</span><br><span class="line">                            cellsBusy = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (created)</span><br><span class="line">                            break;</span><br><span class="line">                        continue;           // Slot is now non-empty</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (!wasUncontended)       // CAS already known to fail</span><br><span class="line">                wasUncontended = true;      // Continue after rehash</span><br><span class="line">            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">            //增加元素数量，成功则跳出循环</span><br><span class="line">                break;</span><br><span class="line">            else if (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = false;            // At max size or stale</span><br><span class="line">            else if (!collide)</span><br><span class="line">                collide = true;</span><br><span class="line">            else if (cellsBusy == 0 &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">            //获取锁,counterCells数组扩容</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (counterCells == as) &#123;// Expand table unless stale</span><br><span class="line">                        CounterCell[] rs = new CounterCell[n &lt;&lt; 1];</span><br><span class="line">                        for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    cellsBusy = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = false;</span><br><span class="line">                continue;                   // Retry with expanded table</span><br><span class="line">            &#125;</span><br><span class="line">            //获取下一个随机数</span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123;</span><br><span class="line">        //counterCells数组不存在，获取锁，初始化counterCells数组</span><br><span class="line">            boolean init = false;</span><br><span class="line">            try &#123;                           // Initialize table</span><br><span class="line">                if (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = new CounterCell[2];</span><br><span class="line">                    //添加计数</span><br><span class="line">                    rs[h &amp; 1] = new CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (init)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">        //任然用baseCount计数</span><br><span class="line">            break;                          // Fall back on using base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、ConcurrentHashMap的get方法"><a href="#12、ConcurrentHashMap的get方法" class="headerlink" title="12、ConcurrentHashMap的get方法"></a>12、ConcurrentHashMap的get方法</h4><p>获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    //获取hash值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    //获取hash值对应的数组中的链表</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">            //正好在表头</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            //从ForwardingNode或红黑树中获取</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        //从链表中逐一查找</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="13、ForwardingNode的find方法"><a href="#13、ForwardingNode的find方法" class="headerlink" title="13、ForwardingNode的find方法"></a>13、ForwardingNode的find方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">    //从新数组里获取链表</span><br><span class="line">    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; int n;</span><br><span class="line">        if (k == null || tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) == null)</span><br><span class="line">            //数组该索引位置为空</span><br><span class="line">            return null;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int eh; K ek;</span><br><span class="line">            if ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                //从链表中查找到</span><br><span class="line">                return e;</span><br><span class="line">            if (eh &lt; 0) &#123;</span><br><span class="line">                //再次扩容，从下个数组中查找</span><br><span class="line">                if (e instanceof ForwardingNode) &#123;</span><br><span class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                    continue outer;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    //从红黑树中查找</span><br><span class="line">                    return e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line">            if ((e = e.next) == null)</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、ConcurrentHashMap的remove方法"><a href="#14、ConcurrentHashMap的remove方法" class="headerlink" title="14、ConcurrentHashMap的remove方法"></a>14、ConcurrentHashMap的remove方法</h4><p>删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    return replaceNode(key, null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="15、ConcurrentHashMap的replaceNode方法"><a href="#15、ConcurrentHashMap的replaceNode方法" class="headerlink" title="15、ConcurrentHashMap的replaceNode方法"></a>15、ConcurrentHashMap的replaceNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">final V replaceNode(Object key, V value, Object cv) &#123;</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        if (tab == null || (n = tab.length) == 0 ||</span><br><span class="line">            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</span><br><span class="line">            //未找到该元素</span><br><span class="line">            break;</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            //正在扩容数组，帮助扩容</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            boolean validated = false;</span><br><span class="line">            //获取f的对象锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                    //正常节点</span><br><span class="line">                        validated = true;</span><br><span class="line">                        //遍历链表</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                if (cv == null || cv == ev ||</span><br><span class="line">                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    if (value != null)</span><br><span class="line">                                        //替换</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    else if (pred != null)</span><br><span class="line">                                        //删除</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    else</span><br><span class="line">                                        //删除</span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            if ((e = e.next) == null)</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                    //f为红黑树</span><br><span class="line">                        validated = true;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        //从红黑树中查找到该节点</span><br><span class="line">                        if ((r = t.root) != null &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, null)) != null) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            if (cv == null || cv == pv ||</span><br><span class="line">                                (pv != null &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                if (value != null)</span><br><span class="line">                                    //替换</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                else if (t.removeTreeNode(p))</span><br><span class="line">                                //红黑树删除该节点，并返回是否需要将红黑树转换回链表</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (validated) &#123;</span><br><span class="line">                if (oldVal != null) &#123;</span><br><span class="line">                    if (value == null)</span><br><span class="line">                        //数量减一</span><br><span class="line">                        addCount(-1L, -1);</span><br><span class="line">                    return oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、红黑树TreeBin"><a href="#二、红黑树TreeBin" class="headerlink" title="二、红黑树TreeBin"></a>二、红黑树TreeBin</h3><h4 id="1、实例化TreeBin"><a href="#1、实例化TreeBin" class="headerlink" title="1、实例化TreeBin"></a>1、实例化TreeBin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = TreeBin.class;</span><br><span class="line">        //根节点root锁的位置偏移</span><br><span class="line">        LOCKSTATE = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;lockState&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造红黑树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    super(TREEBIN, null, null, null);</span><br><span class="line">    //红黑树中同时维护了一个双向队列</span><br><span class="line">    this.first = b;</span><br><span class="line">    TreeNode&lt;K,V&gt; r = null;</span><br><span class="line">    //逐个处理节点</span><br><span class="line">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = null;</span><br><span class="line">        if (r == null) &#123;</span><br><span class="line">        //尚未有根节点，当前节点设置为根节点</span><br><span class="line">            x.parent = null;</span><br><span class="line">            x.red = false;</span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            int h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = null;</span><br><span class="line">            //查找新增节点的父节点，并新增</span><br><span class="line">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                int dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                //hash小的在左边，大的在右边</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir = 1;</span><br><span class="line">                else if ((kc == null &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                //先用比较器比较</span><br><span class="line">                    //先用类名比较，不成功则用内存地址比较</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                //找到新增节点应当添加的位置</span><br><span class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    //对象不等但无法区分大小,也存入左子结点</span><br><span class="line">                    if (dir &lt;= 0)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    //新增节点之后，平衡红黑树</span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root = r;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、TreeBin的balanceInsertion方法"><a href="#2、TreeBin的balanceInsertion方法" class="headerlink" title="2、TreeBin的balanceInsertion方法"></a>2、TreeBin的balanceInsertion方法</h4><p>新增节点后，平衡红黑树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">    //新增节点默认红色</span><br><span class="line">    x.red = true;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        if ((xp = x.parent) == null) &#123;</span><br><span class="line">        //新增节点为根节点，直接染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">        //父节点为黑色，或者父节点为根节点，无须处理</span><br><span class="line">            return root;</span><br><span class="line">        if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">        //新增节点的父节点为左子结点</span><br><span class="line">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">            //新增节点的父节点的兄弟节点为红色</span><br><span class="line">            //已知父节点为红色，将父节点和叔叔节点同时设置为黑色，</span><br><span class="line">            //把爷爷节点染红，当成新增节点继续处理</span><br><span class="line">                xppr.red = false;</span><br><span class="line">                xp.red = false;</span><br><span class="line">                xpp.red = true;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">            //叔叔节点为黑色</span><br><span class="line">                if (x == xp.right) &#123;</span><br><span class="line">                //新增节点为右子节点</span><br><span class="line">                    //将父节点当成新增节点，并左旋</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    //我觉得x.parent不会出现null？？</span><br><span class="line">                    xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                //父节点和爷爷节点互换颜色</span><br><span class="line">                //右旋爷爷节点</span><br><span class="line">                if (xp != null) &#123;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    if (xpp != null) &#123;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        //新增节点的父节点为右子结点，处理过程与之前对称</span><br><span class="line">            if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = false;</span><br><span class="line">                xp.red = false;</span><br><span class="line">                xpp.red = true;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                if (xp != null) &#123;</span><br><span class="line">                    xp.red = false;</span><br><span class="line">                    if (xpp != null) &#123;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、TreeBin的putTreeVal方法"><a href="#3、TreeBin的putTreeVal方法" class="headerlink" title="3、TreeBin的putTreeVal方法"></a>3、TreeBin的putTreeVal方法</h4><p>新增节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) &#123;</span><br><span class="line">    Class&lt;?&gt; kc = null;</span><br><span class="line">    boolean searched = false;</span><br><span class="line">    //查找新增节点的父节点，并新增</span><br><span class="line">    for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        int dir, ph; K pk;</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            //红黑树尚未有节点，新增节点为第一个节点</span><br><span class="line">            first = root = new TreeNode&lt;K,V&gt;(h, k, v, null, null);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -1;</span><br><span class="line">        else if (ph &lt; h)</span><br><span class="line">            dir = 1;</span><br><span class="line">        else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">            //已存在该节点</span><br><span class="line">            return p;</span><br><span class="line">        else if ((kc == null &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">            //查找红黑树中是否已存在key</span><br><span class="line">            if (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = true;</span><br><span class="line">                if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != null) ||</span><br><span class="line">                    ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != null))</span><br><span class="line">                    return q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        //找到新增节点的父节点</span><br><span class="line">        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            //创建新节点，放在队首</span><br><span class="line">            first = x = new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line">            if (f != null)</span><br><span class="line">                f.prev = x;</span><br><span class="line">            if (dir &lt;= 0)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            else</span><br><span class="line">                xp.right = x;</span><br><span class="line">            if (!xp.red)</span><br><span class="line">                //新增节点默认为红色</span><br><span class="line">                x.red = true;</span><br><span class="line">            else &#123;</span><br><span class="line">                //获取根节点锁</span><br><span class="line">                lockRoot();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //新增后，平衡红黑树</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放锁</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、TreeBin的lockRoot方法"><a href="#4、TreeBin的lockRoot方法" class="headerlink" title="4、TreeBin的lockRoot方法"></a>4、TreeBin的lockRoot方法</h4><p>获取根节点锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final void lockRoot() &#123;</span><br><span class="line">    //获取写锁</span><br><span class="line">    if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))</span><br><span class="line">        //获取失败，进入等待</span><br><span class="line">        contendedLock(); // offload to separate method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、TreeBin的contendedLock方法"><a href="#5、TreeBin的contendedLock方法" class="headerlink" title="5、TreeBin的contendedLock方法"></a>5、TreeBin的contendedLock方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final void contendedLock() &#123;</span><br><span class="line">    boolean waiting = false;</span><br><span class="line">    for (int s;;) &#123;</span><br><span class="line">        if (((s = lockState) &amp; ~WAITER) == 0) &#123;</span><br><span class="line">        //锁未被获取，读和写均未被获取</span><br><span class="line">            //获取写锁</span><br><span class="line">            if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line">                if (waiting)</span><br><span class="line">                    waiter = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((s &amp; WAITER) == 0) &#123;</span><br><span class="line">        //没有等待线程</span><br><span class="line">            //获取等待锁</span><br><span class="line">            if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) &#123;</span><br><span class="line">                waiting = true;</span><br><span class="line">                waiter = Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (waiting)</span><br><span class="line">            //阻塞线程</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、TreeBin的unlockRoot方法"><a href="#6、TreeBin的unlockRoot方法" class="headerlink" title="6、TreeBin的unlockRoot方法"></a>6、TreeBin的unlockRoot方法</h4><p>释放根节点锁<br>写操作时，会锁整个节点，因此不会存在线程等待些操作，而读操作在这种情况下会直接查找队列，因此不会存在等待线程<br>读操作时，可能会存在线程等待写操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final void unlockRoot() &#123;</span><br><span class="line">    lockState = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、TreeBin的find方法"><a href="#7、TreeBin的find方法" class="headerlink" title="7、TreeBin的find方法"></a>7、TreeBin的find方法</h4><p>查找元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        for (Node&lt;K,V&gt; e = first; e != null; ) &#123;</span><br><span class="line">            int s; K ek;</span><br><span class="line">            if (((s = lockState) &amp; (WAITER|WRITER)) != 0) &#123;</span><br><span class="line">            //根节点锁，已被获取，从队列中查找</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</span><br><span class="line">                    return e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt(this, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">            //获取读锁</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //从红黑树中查找</span><br><span class="line">                    p = ((r = root) == null ? null :</span><br><span class="line">                         r.findTreeNode(h, k, null));</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Thread w;</span><br><span class="line">                    //释放读锁，若完全释放读锁，且存在等待线程，则唤醒等待线程</span><br><span class="line">                    if (U.getAndAddInt(this, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != null)</span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、TreeBin的findTreeNode方法"><a href="#8、TreeBin的findTreeNode方法" class="headerlink" title="8、TreeBin的findTreeNode方法"></a>8、TreeBin的findTreeNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">    if (k != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">        do  &#123;</span><br><span class="line">            int ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">            if ((ph = p.hash) &gt; h)</span><br><span class="line">            //往左查找</span><br><span class="line">                p = pl;</span><br><span class="line">            else if (ph &lt; h)</span><br><span class="line">            //往右查找</span><br><span class="line">                p = pr;</span><br><span class="line">            else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</span><br><span class="line">            //已找到</span><br><span class="line">                return p;</span><br><span class="line">            else if (pl == null)</span><br><span class="line">                p = pr;</span><br><span class="line">            else if (pr == null)</span><br><span class="line">                p = pl;</span><br><span class="line">            else if ((kc != null ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">            //hash值相等，对象不相等，进一步比较</span><br><span class="line">                p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">            else if ((q = pr.findTreeNode(h, k, kc)) != null)</span><br><span class="line">                //对象不等但无法区分大小，向右查找</span><br><span class="line">                return q;</span><br><span class="line">            else</span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; while (p != null);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、TreeBin的removeTreeNode方法"><a href="#9、TreeBin的removeTreeNode方法" class="headerlink" title="9、TreeBin的removeTreeNode方法"></a>9、TreeBin的removeTreeNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">final boolean removeTreeNode(TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; next = (TreeNode&lt;K,V&gt;)p.next;</span><br><span class="line">    TreeNode&lt;K,V&gt; pred = p.prev;  // unlink traversal pointers</span><br><span class="line">    TreeNode&lt;K,V&gt; r, rl;</span><br><span class="line">    if (pred == null)</span><br><span class="line">    //删除的是队首</span><br><span class="line">        first = next;</span><br><span class="line">    else</span><br><span class="line">        pred.next = next;</span><br><span class="line">    if (next != null)</span><br><span class="line">        next.prev = pred;</span><br><span class="line">    //删除了最后一个节点</span><br><span class="line">    if (first == null) &#123;</span><br><span class="line">        root = null;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //节点过少</span><br><span class="line">    if ((r = root) == null || r.right == null || // too small</span><br><span class="line">        (rl = r.left) == null || rl.left == null)</span><br><span class="line">        return true;</span><br><span class="line">    //获取根节点锁</span><br><span class="line">    lockRoot();</span><br><span class="line">    try &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; replacement;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left;</span><br><span class="line">        TreeNode&lt;K,V&gt; pr = p.right;</span><br><span class="line">        if (pl != null &amp;&amp; pr != null) &#123;</span><br><span class="line">        //待删除节点有两个子节点</span><br><span class="line">            TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">            //找到后继节点</span><br><span class="line">            while ((sl = s.left) != null) // find successor</span><br><span class="line">                s = sl;</span><br><span class="line">            //交换节点颜色</span><br><span class="line">            boolean c = s.red; s.red = p.red; p.red = c; // swap colors</span><br><span class="line">            //交换节点位置</span><br><span class="line">            TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">            if (s == pr) &#123; // p was s&apos;s direct parent</span><br><span class="line">            //后继节点刚好为删除节点的右子节点</span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                if ((p.parent = sp) != null) &#123;</span><br><span class="line">                    if (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    else</span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((s.right = pr) != null)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            p.left = null;</span><br><span class="line">            if ((p.right = sr) != null)</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            if ((s.left = pl) != null)</span><br><span class="line">                pl.parent = s;</span><br><span class="line">            if ((s.parent = pp) == null)</span><br><span class="line">                r = s;</span><br><span class="line">            else if (p == pp.left)</span><br><span class="line">                pp.left = s;</span><br><span class="line">            else</span><br><span class="line">                pp.right = s;</span><br><span class="line">            //删除后的替代节点</span><br><span class="line">            if (sr != null)</span><br><span class="line">                replacement = sr;</span><br><span class="line">            else</span><br><span class="line">                replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pl != null)</span><br><span class="line">        //待删除节点只有左子结点</span><br><span class="line">            replacement = pl;</span><br><span class="line">        else if (pr != null)</span><br><span class="line">        //待删除节点只有右子结点</span><br><span class="line">            replacement = pr;</span><br><span class="line">        else</span><br><span class="line">        //待删除节点没有子结点</span><br><span class="line">            replacement = p;</span><br><span class="line">        if (replacement != p) &#123;</span><br><span class="line">        //删除后，替代操作</span><br><span class="line">            TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            if (pp == null)</span><br><span class="line">                r = replacement;</span><br><span class="line">            else if (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            else</span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除节点为红色则不处理，否则平衡红黑树</span><br><span class="line">        root = (p.red) ? r : balanceDeletion(r, replacement);</span><br><span class="line">        //无替代节点</span><br><span class="line">        if (p == replacement) &#123;  // detach pointers</span><br><span class="line">            TreeNode&lt;K,V&gt; pp;</span><br><span class="line">            if ((pp = p.parent) != null) &#123;</span><br><span class="line">                if (p == pp.left)</span><br><span class="line">                    pp.left = null;</span><br><span class="line">                else if (p == pp.right)</span><br><span class="line">                    pp.right = null;</span><br><span class="line">                p.parent = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        unlockRoot();</span><br><span class="line">    &#125;</span><br><span class="line">    assert checkInvariants(root);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、TreeBin的balanceDeletion方法"><a href="#10、TreeBin的balanceDeletion方法" class="headerlink" title="10、TreeBin的balanceDeletion方法"></a>10、TreeBin的balanceDeletion方法</h4><p>删除节点后，平衡红黑树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        if (x == null || x == root)</span><br><span class="line">            //x迭代到根节点</span><br><span class="line">            return root;</span><br><span class="line">        else if ((xp = x.parent) == null) &#123;</span><br><span class="line">            //x迭代到根节点，染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (x.red) &#123;</span><br><span class="line">            //新x节点为红色，直接染黑</span><br><span class="line">            x.red = false;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((xpl = xp.left) == x) &#123;</span><br><span class="line">        //删除节点为左子节点</span><br><span class="line">            //兄弟节点为红色</span><br><span class="line">            //兄弟节点和父节点互换颜色，左旋父节点</span><br><span class="line">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = false;</span><br><span class="line">                xp.red = true;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                //更新兄弟节点</span><br><span class="line">                xpr = (xp = x.parent) == null ? null : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (xpr == null)</span><br><span class="line">            //兄弟节点不可能为null？？？</span><br><span class="line">                x = xp;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                if ((sr == null || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == null || !sl.red)) &#123;</span><br><span class="line">                    //兄弟节点为黑色，兄弟节点的子节点都为黑色</span><br><span class="line">                    //染红兄弟节点，将父节点作为新的x节点,继续迭代</span><br><span class="line">                    xpr.red = true;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //兄弟节点的右子节点为黑色，左子节点为红色</span><br><span class="line">                    //兄弟节点与左子节点互换颜色，右旋兄弟节点</span><br><span class="line">                    if (sr == null || !sr.red) &#123;</span><br><span class="line">                        if (sl != null)</span><br><span class="line">                            sl.red = false;</span><br><span class="line">                        xpr.red = true;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == null ?</span><br><span class="line">                            null : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //兄弟节点的右子节点为红色，左子节点随意</span><br><span class="line">                    //兄弟节点和父节点互换颜色，左旋父节点，染黑兄弟节点的右子节点</span><br><span class="line">                    if (xpr != null) &#123;</span><br><span class="line">                        xpr.red = (xp == null) ? false : xp.red;</span><br><span class="line">                        if ((sr = xpr.right) != null)</span><br><span class="line">                            sr.red = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; </span><br><span class="line">        //删除节点为右子节点，与之前对称</span><br><span class="line">            if (xpl != null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = false;</span><br><span class="line">                xp.red = true;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == null ? null : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (xpl == null)</span><br><span class="line">                x = xp;</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                if ((sl == null || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == null || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = true;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (sl == null || !sl.red) &#123;</span><br><span class="line">                        if (sr != null)</span><br><span class="line">                            sr.red = false;</span><br><span class="line">                        xpl.red = true;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == null ?</span><br><span class="line">                            null : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpl != null) &#123;</span><br><span class="line">                        xpl.red = (xp == null) ? false : xp.red;</span><br><span class="line">                        if ((sl = xpl.left) != null)</span><br><span class="line">                            sl.red = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xp != null) &#123;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="11、TreeBin的rotateLeft方法"><a href="#11、TreeBin的rotateLeft方法" class="headerlink" title="11、TreeBin的rotateLeft方法"></a>11、TreeBin的rotateLeft方法</h4><p>左旋<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                          TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">        if ((rl = p.right = r.left) != null)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        if ((pp = r.parent = p.parent) == null)</span><br><span class="line">            (root = r).red = false;</span><br><span class="line">        else if (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        else</span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="12、TreeBin的rotateRight方法"><a href="#12、TreeBin的rotateRight方法" class="headerlink" title="12、TreeBin的rotateRight方法"></a>12、TreeBin的rotateRight方法</h4><p>右旋<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">        if ((lr = p.left = l.right) != null)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        if ((pp = l.parent = p.parent) == null)</span><br><span class="line">            (root = l).red = false;</span><br><span class="line">        else if (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        else</span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC锁</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E9%94%81/"/>
      <content type="html"><![CDATA[<h2 id="JUC锁"><a href="#JUC锁" class="headerlink" title="JUC锁"></a>JUC锁</h2><h3 id="一、独占锁ReentrantLock"><a href="#一、独占锁ReentrantLock" class="headerlink" title="一、独占锁ReentrantLock"></a>一、独占锁ReentrantLock</h3><h4 id="1、实例化ReentrantLock"><a href="#1、实例化ReentrantLock" class="headerlink" title="1、实例化ReentrantLock"></a>1、实例化ReentrantLock</h4><p>AbstractQueuedSynchronizer的静态代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //锁状态state字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        //CLH队首head字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">        //CLH队尾head字段，在AbstractQueuedSynchronizer对象中的地址偏移</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">        //节点状态waitStatus字段,在Node对象中的位置偏移</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">        //后继节点next字段,在Node对象中的位置偏移</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    //默认非公平锁</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、ReentrantLock的lock方法"><a href="#2、ReentrantLock的lock方法" class="headerlink" title="2、ReentrantLock的lock方法"></a>2、ReentrantLock的lock方法</h4><p>lock方法获取锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、NonfairSync的lock方法"><a href="#3、NonfairSync的lock方法" class="headerlink" title="3、NonfairSync的lock方法"></a>3、NonfairSync的lock方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    //锁状态state为0则表示锁空闲,state&gt;0则表示锁已被获取</span><br><span class="line">    //将state状态由0改为1</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        //成功则，设置锁的拥有线程为当前线程</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        //不成功，说明锁状态不为0，已被其他线程获取，则继续获取锁</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AbstractQueuedSynchronizer的acquire方法"><a href="#4、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="4、AbstractQueuedSynchronizer的acquire方法"></a>4、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //尝试获取锁，失败则将线程加入等待队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        //acquireQueued会返回本线程是否中断</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、NonfairSync的tryAcquire方法"><a href="#5、NonfairSync的tryAcquire方法" class="headerlink" title="5、NonfairSync的tryAcquire方法"></a>5、NonfairSync的tryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //尝试获取非公平锁</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Sync的nonfairTryAcquire方法"><a href="#6、Sync的nonfairTryAcquire方法" class="headerlink" title="6、Sync的nonfairTryAcquire方法"></a>6、Sync的nonfairTryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    //获取state值</span><br><span class="line">    int c = getState();</span><br><span class="line">    //锁状态为0，锁空闲</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //更改锁状态，成功则返回true</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        //锁已被本线程获取</span><br><span class="line">        //本线程再次获取锁</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //更新锁状态</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（一、4）Node的addWaiter方法"><a href="#7、接（一、4）Node的addWaiter方法" class="headerlink" title="7、接（一、4）Node的addWaiter方法"></a>7、接（一、4）Node的addWaiter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    //创建新节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    //获取队尾节点</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    //tail节点存在，则CLH队列不为空，则将“当前线程”添加到CLH队列末尾</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        //设置本节点的上个节点为队尾节点</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        //将本节点设置为队尾，成功则返回节点，失败则认为队尾已变更，本次操作失败</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、Node的enq方法"><a href="#8、Node的enq方法" class="headerlink" title="8、Node的enq方法"></a>8、Node的enq方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">        //队尾不存在，说明队列尚未建立</span><br><span class="line">            //创建一个空节点作为头节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                //成功则将尾节点也设置为当前节点</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //队列已建立</span><br><span class="line">            //操作与上个方法相同，成功则返回，不成功则重新循环</span><br><span class="line">            //头节点的前一个节点，是尾节点</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法"><a href="#9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法" class="headerlink" title="9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法"></a>9、接（一、4）AbstractQueuedSynchronizer的acquireQueued方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // interrupted表示在CLH队列的调度中，</span><br><span class="line">        // “当前线程”在休眠时，有没有被中断过。</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取上一个节点。</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //若p为头节点，则尝试获取锁</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                //设置当前节点为头节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程应阻塞，则阻塞当前线程</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //取消本节点</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法"><a href="#10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法" class="headerlink" title="10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法"></a>10、AbstractQueuedSynchronizer的shouldParkAfterFailedAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    // 前继节点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        //前继节点的后继节点，在前继节点释放或取消时，需要唤醒后继节点</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">         // 如果前继节点是前取消状态，则设置当前节点的前继节点为原前继节点的前继节点。</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果前继节点为0或者共享锁状态，则设置前继节点为SIGNAL状态。</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitStatus的状态如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CANCELLED[1]  -- 当前线程已被取消</span><br><span class="line">SIGNAL[-1]    -- “当前线程的后继线程需要被unpark(唤醒)”。</span><br><span class="line">    一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。</span><br><span class="line">CONDITION[-2] -- 当前线程(处在Condition休眠状态)在等待Condition唤醒</span><br><span class="line">PROPAGATE[-3] -- (共享锁)其它线程获取到“共享锁”</span><br><span class="line">[0]           -- 当前线程不属于上面的任何一种状态。</span><br></pre></td></tr></table></figure></p><h4 id="11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法"><a href="#11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法" class="headerlink" title="11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法"></a>11、接（一、9）AbstractQueuedSynchronizer的parkAndCheckInterrupt方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    // 通过LockSupport的park()阻塞“当前线程”。</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    // 返回线程的中断状态。</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法"><a href="#12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法" class="headerlink" title="12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法"></a>12、接（一、9）AbstractQueuedSynchronizer的cancelAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    // Ignore if node doesn&apos;t exist</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    //清空node对应的线程</span><br><span class="line">    node.thread = null;</span><br><span class="line">    //获取前继节点</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    // 如果前继节点是前取消状态，则设置当前节点的前继节点为原前继节点的前继节点。</span><br><span class="line">    while (pred.waitStatus &gt; 0)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    //获取前继节点的后继节点</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    //设置当前节点状态为取消</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        //当前节点为队尾，设置队尾为前继节点</span><br><span class="line">        //设置前继节点的后继节点为null</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        //前继节点不为头节点，设置前继节点状态为SIGNAL</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            //后继节点存在且未取消</span><br><span class="line">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                //设置前继节点的后继节点为当前节点的后继节点</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //唤醒后继节点</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; // help GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、AbstractQueuedSynchronizer的unparkSuccessor方法"><a href="#13、AbstractQueuedSynchronizer的unparkSuccessor方法" class="headerlink" title="13、AbstractQueuedSynchronizer的unparkSuccessor方法"></a>13、AbstractQueuedSynchronizer的unparkSuccessor方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    //获取节点状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果状态&lt;0，则设置状态=0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    // 获取当前节点的有效的后继节点，无效的话，则通过for循环进行获取。</span><br><span class="line">    // 这里的有效，是指后继节点对应的线程状态&lt;=0</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        //从队尾往前查找</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒后继节点对应的线程</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、ReentrantLock的unlock方法"><a href="#14、ReentrantLock的unlock方法" class="headerlink" title="14、ReentrantLock的unlock方法"></a>14、ReentrantLock的unlock方法</h4><p>unlock释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="15、NonfairSync的release方法"><a href="#15、NonfairSync的release方法" class="headerlink" title="15、NonfairSync的release方法"></a>15、NonfairSync的release方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点存在，且有效</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            //唤醒头节点的后继节点</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16、Sync的tryRelease方法"><a href="#16、Sync的tryRelease方法" class="headerlink" title="16、Sync的tryRelease方法"></a>16、Sync的tryRelease方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //释放一层锁</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    //c为零表示完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    //更新锁状态</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、公平锁"><a href="#二、公平锁" class="headerlink" title="二、公平锁"></a>二、公平锁</h3><h4 id="1、实例化ReentrantLock-1"><a href="#1、实例化ReentrantLock-1" class="headerlink" title="1、实例化ReentrantLock"></a>1、实例化ReentrantLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、FairSync的lock方法"><a href="#2、FairSync的lock方法" class="headerlink" title="2、FairSync的lock方法"></a>2、FairSync的lock方法</h4><p>公平锁   – 公平锁的lock()函数，会直接调用acquire(1)。<br>非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、AbstractQueuedSynchronizer的acquire方法"><a href="#3、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquire方法"></a>3、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //尝试获取锁，失败则将线程加入等待队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        //acquireQueued会返回本线程是否中断</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、FairSync的tryAcquire方法"><a href="#4、FairSync的tryAcquire方法" class="headerlink" title="4、FairSync的tryAcquire方法"></a>4、FairSync的tryAcquire方法</h4><p>公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。<br>非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //锁空闲，首先查看等待队列是否有线程等待，无线程等待或队首节点的后继节点是本线程，</span><br><span class="line">        //再去获取锁，否则获取失败</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、Condition条件"><a href="#三、Condition条件" class="headerlink" title="三、Condition条件"></a>三、Condition条件</h3><h4 id="1、ReentrantLock的newCondition方法"><a href="#1、ReentrantLock的newCondition方法" class="headerlink" title="1、ReentrantLock的newCondition方法"></a>1、ReentrantLock的newCondition方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject newCondition() &#123;</span><br><span class="line">    return new ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、ConditionObject的await方法"><a href="#2、ConditionObject的await方法" class="headerlink" title="2、ConditionObject的await方法"></a>2、ConditionObject的await方法</h4><p>线程等待<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //往该条件等待队列队尾，添加一个等待线程节点</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    //完全释放锁</span><br><span class="line">    long savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    //检查该节点是否在CLH队列中，不在则阻塞该线程。条件等待队列和CLH队列是两个不同的队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        //检查线程中断，线程中断时，在条件等待队列中返回（THROW_IE），</span><br><span class="line">        //线程中断时不在条件等待队列中返回REINTERRUPT,线程未中断返回0</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    //node在CLH队列中重新获取锁</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    //该节点的条件等待队列后继节点为空</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        //去除队列里的无效节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        //THROW_IE中断则抛出异常，REINTERRUPT设置本线程中断标记</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ConditionObject的addConditionWaiter方法"><a href="#3、ConditionObject的addConditionWaiter方法" class="headerlink" title="3、ConditionObject的addConditionWaiter方法"></a>3、ConditionObject的addConditionWaiter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    //队尾节点无效</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        //去除队列里的无效节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        //获取队尾节点</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    //本线程新建节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        //队尾节点不存在，说明队列尚不存在，设置队首为本节点</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        //否则设置队尾节点的后继节点为本节点</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    //设置队尾节点为本节点</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ConditionObject的unlinkCancelledWaiters方法"><a href="#4、ConditionObject的unlinkCancelledWaiters方法" class="headerlink" title="4、ConditionObject的unlinkCancelledWaiters方法"></a>4、ConditionObject的unlinkCancelledWaiters方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    //当前处理节点</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    //当前处理节点的前一个节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            //t节点无效</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                //当前节点不存在前继节点</span><br><span class="line">                //设置队首为后继节点</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                //设置前继节点的后继节点为next</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                //next不存在设置trail为队尾</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            //当前节点有效，上一个节点设置为当前节点</span><br><span class="line">            trail = t;</span><br><span class="line">        //设置当前节点为当前节点的后一个节点</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法"><a href="#5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法" class="headerlink" title="5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法"></a>5、接（四、2）AbstractQueuedLongSynchronizer的unlinkCancelledWaiters方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unlinkCancelledWaiters() &#123;</span><br><span class="line">    //当前处理节点</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    //当前处理节点的前一个节点</span><br><span class="line">    Node trail = null;</span><br><span class="line">    while (t != null) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            //t节点无效</span><br><span class="line">            t.nextWaiter = null;</span><br><span class="line">            if (trail == null)</span><br><span class="line">                //当前节点不存在前继节点</span><br><span class="line">                //设置队首为后继节点</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            else</span><br><span class="line">                //设置前继节点的后继节点为next</span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            if (next == null)</span><br><span class="line">                //next不存在设置trail为队尾</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            //当前节点有效，上一个节点设置为当前节点</span><br><span class="line">            trail = t;</span><br><span class="line">        //设置当前节点为当前节点的后一个节点</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、ConditionObject的signal方法"><a href="#6、ConditionObject的signal方法" class="headerlink" title="6、ConditionObject的signal方法"></a>6、ConditionObject的signal方法</h4><p>按顺序唤醒该条件等待的一个线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    //拥有该锁的线程必须是本线程</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        //唤醒队首</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、ConditionObject的doSignal方法"><a href="#7、ConditionObject的doSignal方法" class="headerlink" title="7、ConditionObject的doSignal方法"></a>7、ConditionObject的doSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //firstWaiter的后继节点等于null,设置队首队尾为null</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">        //节点加入CLH队列，失败则处理下一个</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、ConditionObject的transferForSignal方法"><a href="#8、ConditionObject的transferForSignal方法" class="headerlink" title="8、ConditionObject的transferForSignal方法"></a>8、ConditionObject的transferForSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    //设置该节点状态为0</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line">    //将该节点加入CLH队列，返回原队尾</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    //设置该节点前继节点的状态为SIGNAL</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        //设置失败，唤醒该线程</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、ConditionObject的signalAll方法"><a href="#9、ConditionObject的signalAll方法" class="headerlink" title="9、ConditionObject的signalAll方法"></a>9、ConditionObject的signalAll方法</h4><p>唤醒该条件等待的所有线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public final void signalAll() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        //唤醒所有等待的线程</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="10、ConditionObject的doSignal方法"><a href="#10、ConditionObject的doSignal方法" class="headerlink" title="10、ConditionObject的doSignal方法"></a>10、ConditionObject的doSignal方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void doSignalAll(Node first) &#123;</span><br><span class="line">    //清空队列</span><br><span class="line">    lastWaiter = firstWaiter = null;</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">        //依次将节点加入CLH队列</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; while (first != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、读写锁ReentrantReadWriteLock"><a href="#四、读写锁ReentrantReadWriteLock" class="headerlink" title="四、读写锁ReentrantReadWriteLock"></a>四、读写锁ReentrantReadWriteLock</h3><h4 id="1、实例化ReentrantReadWriteLock"><a href="#1、实例化ReentrantReadWriteLock" class="headerlink" title="1、实例化ReentrantReadWriteLock"></a>1、实例化ReentrantReadWriteLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock() &#123;</span><br><span class="line">    this(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">    //默认使用非公平锁</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    //读锁</span><br><span class="line">    readerLock = new ReadLock(this);</span><br><span class="line">    //写锁</span><br><span class="line">    writerLock = new WriteLock(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、ReadLock的lock方法"><a href="#2、ReadLock的lock方法" class="headerlink" title="2、ReadLock的lock方法"></a>2、ReadLock的lock方法</h4><p>获取读锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、AbstractQueuedSynchronizer的acquireShared方法"><a href="#3、AbstractQueuedSynchronizer的acquireShared方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireShared方法"></a>3、AbstractQueuedSynchronizer的acquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    //尝试获取共享锁</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //失败则将线程加入等待队列</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、Sync的tryAcquireShared方法"><a href="#4、Sync的tryAcquireShared方法" class="headerlink" title="4、Sync的tryAcquireShared方法"></a>4、Sync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    //获取锁状态,默认左16位为共享锁（读锁）使用，右16位为独占锁（写锁）使用</span><br><span class="line">    int c = getState();</span><br><span class="line">    //独占锁且拥有者不是当前线程，获取失败，返回-1</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line">    //c右移去除独占锁部分</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    //readerShouldBlock 非公平锁(如果队首存在且为独占锁，则返回true)</span><br><span class="line">    //                  公平锁(如果队首存在且不为当前线程，则返回true)</span><br><span class="line">    //MAX_COUNT 共享锁最大共享线程数</span><br><span class="line">    //compareAndSetState 获取锁</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp; </span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">            //第一次获取共享锁</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123;</span><br><span class="line">            //第一个获取共享锁的线程,但不是第一次获取</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // HoldCounter是用来统计该线程获取“读取锁”的次数。</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            //线程获取锁的次数加一</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Sync的fullTryAcquireShared方法"><a href="#5、Sync的fullTryAcquireShared方法" class="headerlink" title="5、Sync的fullTryAcquireShared方法"></a>5、Sync的fullTryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh = null;</span><br><span class="line">    //不停获取锁，直到成功，或者不能获取</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            //独占锁</span><br><span class="line">            //拥有者不是当前线程，获取失败，返回-1</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            //队首存在且为独占锁，则新线程不可再获取读锁</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //若线程未获取到锁，清除rh</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //新线程不可再获取读锁</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取共享锁线程，超过最大数量限制</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //获取锁，与上个方法相同</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; // cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法"><a href="#6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法" class="headerlink" title="6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法"></a>6、接（四、4）AbstractQueuedSynchronizer的doAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    //创建共享锁节点，并添加到队列中去</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取前继节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //说明本节点为队首</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //再次获取共享锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //获取共享锁成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    //头节点标记为当前节点，清空当前节点，</span><br><span class="line">                    //后继节点为共享锁，则唤醒后继节点,</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        //中断本线程</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前线程应阻塞，则阻塞当前线程，与（一、9）相同</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            //取消本节点，与（一、12）相同</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、WriteLock的lock方法"><a href="#7、WriteLock的lock方法" class="headerlink" title="7、WriteLock的lock方法"></a>7、WriteLock的lock方法</h4><p>获取写锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、AbstractQueuedSynchronizer的acquire方法"><a href="#8、AbstractQueuedSynchronizer的acquire方法" class="headerlink" title="8、AbstractQueuedSynchronizer的acquire方法"></a>8、AbstractQueuedSynchronizer的acquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    //tryAcquire尝试获取独占锁，其余方法与之前相同。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、Sync的tryAcquire方法"><a href="#9、Sync的tryAcquire方法" class="headerlink" title="9、Sync的tryAcquire方法"></a>9、Sync的tryAcquire方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        //获取独占锁状态</span><br><span class="line">        int w = exclusiveCount(c);</span><br><span class="line">        //锁已被获取</span><br><span class="line">        if (c != 0) &#123;</span><br><span class="line">            //共享锁或者获取独占锁的不是本线程，返回失败</span><br><span class="line">            if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">                return false;</span><br><span class="line">            //独占锁获取次数大于最大次数</span><br><span class="line">            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            //更新锁状态</span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //writerShouldBlock永远返回false</span><br><span class="line">        //尝试获取独占锁</span><br><span class="line">        if (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            return false;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="10、ReadLock的unlock方法"><a href="#10、ReadLock的unlock方法" class="headerlink" title="10、ReadLock的unlock方法"></a>10、ReadLock的unlock方法</h4><p>释放共享锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="11、AbstractQueuedSynchronizer的releaseShared方法"><a href="#11、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="11、AbstractQueuedSynchronizer的releaseShared方法"></a>11、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //释放共享锁</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、Sync的tryReleaseShared方法"><a href="#12、Sync的tryReleaseShared方法" class="headerlink" title="12、Sync的tryReleaseShared方法"></a>12、Sync的tryReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123;</span><br><span class="line">        //本线程为获取共享锁的第一个线程</span><br><span class="line">        if (firstReaderHoldCount == 1)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //线程获取锁次数减1，若线程已完全释放锁，清除rh</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        //释放一层锁</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            //共享锁是否完全释放</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、接（四、11）Sync的doReleaseShared方法"><a href="#13、接（四、11）Sync的doReleaseShared方法" class="headerlink" title="13、接（四、11）Sync的doReleaseShared方法"></a>13、接（四、11）Sync的doReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                //SIGNAL说明下个节点需要唤醒</span><br><span class="line">                //设置该节点状态为0，不成功继续循环，</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;    </span><br><span class="line">                //唤醒下个节点的线程</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                //设置该节点状态为共享锁</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        //头结点发生变化，退出循环</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、WriteLock的unlock方法"><a href="#14、WriteLock的unlock方法" class="headerlink" title="14、WriteLock的unlock方法"></a>14、WriteLock的unlock方法</h4><p>写锁释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="15、AbstractQueuedSynchronizer的release方法"><a href="#15、AbstractQueuedSynchronizer的release方法" class="headerlink" title="15、AbstractQueuedSynchronizer的release方法"></a>15、AbstractQueuedSynchronizer的release方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    //释放锁，返回是否完全释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            //唤醒后继节点线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16、AbstractQueuedSynchronizer的tryRelease方法"><a href="#16、AbstractQueuedSynchronizer的tryRelease方法" class="headerlink" title="16、AbstractQueuedSynchronizer的tryRelease方法"></a>16、AbstractQueuedSynchronizer的tryRelease方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //拥有锁的是否是当前线程</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    //释放一层锁</span><br><span class="line">    int nextc = getState() - releases;</span><br><span class="line">    //是否完全释放</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">    if (free)</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、CountDownLatch"><a href="#五、CountDownLatch" class="headerlink" title="五、CountDownLatch"></a>五、CountDownLatch</h3><h4 id="1、实例化CountDownLatch"><a href="#1、实例化CountDownLatch" class="headerlink" title="1、实例化CountDownLatch"></a>1、实例化CountDownLatch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(int count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer的setState方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CountDownLatch重写了tryAcquireShared、tryReleaseShared方法，其余与共享锁相同</p><h4 id="2、CountDownLatch的await方法"><a href="#2、CountDownLatch的await方法" class="headerlink" title="2、CountDownLatch的await方法"></a>2、CountDownLatch的await方法</h4><p>线程加入等待队列，等待CountDownLatch释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"><a href="#3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //查看CountDownLatch是否完全释放，没有则线程加入等待队列</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //线程加入等待队列，与共享锁相同</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、Sync的tryAcquireShared方法-1"><a href="#4、Sync的tryAcquireShared方法-1" class="headerlink" title="4、Sync的tryAcquireShared方法"></a>4、Sync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"><a href="#5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法" class="headerlink" title="5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>5、接（五、3）AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                //判断CountDownLatch是否完全释放</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                //CountDownLatch完全释放，唤醒等待队列中的所有线程</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、CountDownLatch的countDown方法"><a href="#6、CountDownLatch的countDown方法" class="headerlink" title="6、CountDownLatch的countDown方法"></a>6、CountDownLatch的countDown方法</h4><p>CountDownLatch释放一层锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、AbstractQueuedSynchronizer的releaseShared方法"><a href="#7、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="7、AbstractQueuedSynchronizer的releaseShared方法"></a>7、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    //释放一层锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //释放共享锁，唤醒等待线程，与共享锁相同</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、Sync的tryReleaseShared方法"><a href="#8、Sync的tryReleaseShared方法" class="headerlink" title="8、Sync的tryReleaseShared方法"></a>8、Sync的tryReleaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        //释放一层锁</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            //返回CountDownLatch是否完全释放</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、CyclicBarrier"><a href="#六、CyclicBarrier" class="headerlink" title="六、CyclicBarrier"></a>六、CyclicBarrier</h3><h4 id="1、实例化CyclicBarrier"><a href="#1、实例化CyclicBarrier" class="headerlink" title="1、实例化CyclicBarrier"></a>1、实例化CyclicBarrier</h4><p>等待parties个线程到达，才会释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    //回调线程</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、CyclicBarrier的await方法"><a href="#2、CyclicBarrier的await方法" class="headerlink" title="2、CyclicBarrier的await方法"></a>2、CyclicBarrier的await方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); // cannot happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、CyclicBarrier的dowait方法"><a href="#3、CyclicBarrier的dowait方法" class="headerlink" title="3、CyclicBarrier的dowait方法"></a>3、CyclicBarrier的dowait方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    //独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //当前的generation</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        //是否已损坏</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line">        //当前线程已被中断</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            //破坏锁，释放等待线程</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        //count 减一</span><br><span class="line">        int index = --count;</span><br><span class="line">        //到达CyclicBarrier的线程数已达到parties个</span><br><span class="line">        if (index == 0) &#123;  // tripped</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                if (command != null)</span><br><span class="line">                    //执行回调线程</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                //释放等待线程，重置锁</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    //lock锁的条件等待</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、CyclicBarrier的breakBarrier方法"><a href="#4、CyclicBarrier的breakBarrier方法" class="headerlink" title="4、CyclicBarrier的breakBarrier方法"></a>4、CyclicBarrier的breakBarrier方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    //锁被破坏</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    //重置count</span><br><span class="line">    count = parties;</span><br><span class="line">    //释放在等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（六、3）CyclicBarrier的nextGeneration方法"><a href="#5、接（六、3）CyclicBarrier的nextGeneration方法" class="headerlink" title="5、接（六、3）CyclicBarrier的nextGeneration方法"></a>5、接（六、3）CyclicBarrier的nextGeneration方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    //释放等待的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    //重置count</span><br><span class="line">    count = parties;</span><br><span class="line">    //重置Generation</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Semaphore"><a href="#七、Semaphore" class="headerlink" title="七、Semaphore"></a>七、Semaphore</h3><h4 id="1、实例化Semaphore"><a href="#1、实例化Semaphore" class="headerlink" title="1、实例化Semaphore"></a>1、实例化Semaphore</h4><p>最大信号量permits<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、Semaphore的acquire方法"><a href="#2、Semaphore的acquire方法" class="headerlink" title="2、Semaphore的acquire方法"></a>2、Semaphore的acquire方法</h4><p>获取permits的信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void acquire(int permits) throws InterruptedException &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法-1"><a href="#3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法-1" class="headerlink" title="3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法"></a>3、AbstractQueuedSynchronizer的acquireSharedInterruptibly方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    //剩余信号量小于零，则线程加入等待队列</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        //加入等待队列,与共享锁相同  </span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、NonfairSync的tryAcquireShared方法"><a href="#4、NonfairSync的tryAcquireShared方法" class="headerlink" title="4、NonfairSync的tryAcquireShared方法"></a>4、NonfairSync的tryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Semaphore的nonfairTryAcquireShared方法"><a href="#5、Semaphore的nonfairTryAcquireShared方法" class="headerlink" title="5、Semaphore的nonfairTryAcquireShared方法"></a>5、Semaphore的nonfairTryAcquireShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //剩余的信号量</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        //剩余信号量大于零，则尝试获取。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            //剩余信号量小于零，或者获取成功，返回剩余信号量</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Semaphore的release方法"><a href="#6、Semaphore的release方法" class="headerlink" title="6、Semaphore的release方法"></a>6、Semaphore的release方法</h4><p>释放信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void release(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、AbstractQueuedSynchronizer的releaseShared方法-1"><a href="#7、AbstractQueuedSynchronizer的releaseShared方法-1" class="headerlink" title="7、AbstractQueuedSynchronizer的releaseShared方法"></a>7、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        //唤醒等待队列，与共享锁相同</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、AbstractQueuedSynchronizer的releaseShared方法"><a href="#8、AbstractQueuedSynchronizer的releaseShared方法" class="headerlink" title="8、AbstractQueuedSynchronizer的releaseShared方法"></a>8、AbstractQueuedSynchronizer的releaseShared方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        //释放信号量</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、接（七、3）FairSync的tryAcquireShared方法"><a href="#9、接（七、3）FairSync的tryAcquireShared方法" class="headerlink" title="9、接（七、3）FairSync的tryAcquireShared方法"></a>9、接（七、3）FairSync的tryAcquireShared方法</h4><p>公平锁的信号量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //等待队列中，由线程直接返回-1，其余与非公平锁相同</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC线程池(2)ForkJoinPool</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0(2)ForkJoinPool/"/>
      <content type="html"><![CDATA[<h2 id="JUC线程池-2-ForkJoinPool"><a href="#JUC线程池-2-ForkJoinPool" class="headerlink" title="JUC线程池(2)ForkJoinPool"></a>JUC线程池(2)ForkJoinPool</h2><p>###demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();  </span><br><span class="line">              </span><br><span class="line">        /** </span><br><span class="line">         * get()和join()有两个主要的区别： </span><br><span class="line">         * join()方法同步返回,不能被中断。如果你中断调用join()方法的线程，这个方法将抛出InterruptedException异常。 </span><br><span class="line">         * 如果任务抛出任何未受检异常，get()方法异步返回将返回一个ExecutionException异常，而join()方法将返回一个RuntimeException异常。 </span><br><span class="line">         */  </span><br><span class="line">        //同步返回结果  </span><br><span class="line">        //Future&lt;Integer&gt; result = pool.submit(new CountTask(0, 2000));  </span><br><span class="line">        //System.out.println(result.get());  </span><br><span class="line">        //异步返回结果  </span><br><span class="line">        CountTask task = new CountTask(0, 2000);  </span><br><span class="line">        pool.execute(task);  </span><br><span class="line">        pool.shutdown();  </span><br><span class="line">        Integer count = task.join();  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 计算1..n相加总和的简单demo </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">class CountTask extends RecursiveTask&lt;Integer&gt;&#123;  </span><br><span class="line">        </span><br><span class="line">    private static final long serialVersionUID = 1L;  </span><br><span class="line">    //边界值  </span><br><span class="line">    private static final int THRESHOLD = 50;  </span><br><span class="line">    private int start;  </span><br><span class="line">    private int end;  </span><br><span class="line">       </span><br><span class="line">    public CountTask(int start, int end) &#123;  </span><br><span class="line">        this.start = start;  </span><br><span class="line">        this.end = end;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    @Override  </span><br><span class="line">    protected Integer compute() &#123;  </span><br><span class="line">        int sum = 0;  </span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;  </span><br><span class="line">        if (canCompute) &#123;  </span><br><span class="line">            for (int i = start; i &lt;= end; i++)  </span><br><span class="line">                sum += i;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            int mid = (start + end) / 2;  </span><br><span class="line">            CountTask t1 = new CountTask(start, mid);  </span><br><span class="line">            CountTask t2 = new CountTask(mid+1, end);  </span><br><span class="line">            t1.fork();  </span><br><span class="line">            t2.fork();  </span><br><span class="line">            sum = t1.join() + t2.join();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return sum;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一、ForkJoinPool"><a href="#一、ForkJoinPool" class="headerlink" title="一、ForkJoinPool"></a>一、ForkJoinPool</h3><h4 id="1、实例化ForkJoinPool"><a href="#1、实例化ForkJoinPool" class="headerlink" title="1、实例化ForkJoinPool"></a>1、实例化ForkJoinPool</h4><p>创建ForkJoinPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool() &#123;</span><br><span class="line">    this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">         defaultForkJoinWorkerThreadFactory, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool(int parallelism,</span><br><span class="line">                    ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                    UncaughtExceptionHandler handler,</span><br><span class="line">                    boolean asyncMode) &#123;</span><br><span class="line">    this(checkParallelism(parallelism),</span><br><span class="line">         checkFactory(factory),</span><br><span class="line">         handler,</span><br><span class="line">         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">         &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinPool(int parallelism,</span><br><span class="line">                     ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                     UncaughtExceptionHandler handler,</span><br><span class="line">                     int mode,</span><br><span class="line">                     String workerNamePrefix) &#123;</span><br><span class="line">    //线程名前缀</span><br><span class="line">    this.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    //线程工厂，默认DefaultForkJoinWorkerThreadFactory</span><br><span class="line">    this.factory = factory;</span><br><span class="line">    //</span><br><span class="line">    this.ueh = handler;</span><br><span class="line">    //前16位保存队列模式，后16位保存最大线程数量</span><br><span class="line">    this.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    //</span><br><span class="line">    long np = (long)(-parallelism); // offset ctl counts</span><br><span class="line">    //线程锁，前16位保存活跃的工作线程数量，第二个16位保存总线程数量,最后32位保存等待线程在数组中的位置</span><br><span class="line">    this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池运行状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final int  RSLOCK     = 1;</span><br><span class="line">private static final int  RSIGNAL    = 1 &lt;&lt; 1;</span><br><span class="line">private static final int  STARTED    = 1 &lt;&lt; 2;</span><br><span class="line">private static final int  STOP       = 1 &lt;&lt; 29;</span><br><span class="line">private static final int  TERMINATED = 1 &lt;&lt; 30;</span><br><span class="line">private static final int  SHUTDOWN   = 1 &lt;&lt; 31;</span><br></pre></td></tr></table></figure></p><h4 id="2、ForkJoinPool的execute"><a href="#2、ForkJoinPool的execute" class="headerlink" title="2、ForkJoinPool的execute"></a>2、ForkJoinPool的execute</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、ForkJoinPool的externalPush"><a href="#3、ForkJoinPool的externalPush" class="headerlink" title="3、ForkJoinPool的externalPush"></a>3、ForkJoinPool的externalPush</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final void externalPush(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; int m;</span><br><span class="line">    //随机数</span><br><span class="line">    int r = ThreadLocalRandom.getProbe();</span><br><span class="line">    int rs = runState;</span><br><span class="line">    //如果数组存在，获取数组中的workQueue队列，将任务加入队列</span><br><span class="line">    if ((ws = workQueues) != null &amp;&amp; (m = (ws.length - 1)) &gt;= 0 &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp; r != 0 &amp;&amp; rs &gt; 0 &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; int am, n, s;</span><br><span class="line">        if ((a = q.array) != null &amp;&amp;</span><br><span class="line">            (am = a.length - 1) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            int j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            U.putOrderedInt(q, QTOP, s + 1);</span><br><span class="line">            U.putIntVolatile(q, QLOCK, 0);</span><br><span class="line">            //尝试创建一个活跃的工作线程</span><br><span class="line">            if (n &lt;= 1)</span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, 1, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //任务加入线程池</span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ForkJoinPool的externalSubmit"><a href="#4、ForkJoinPool的externalSubmit" class="headerlink" title="4、ForkJoinPool的externalSubmit"></a>4、ForkJoinPool的externalSubmit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private void externalSubmit(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    int r;                                    // initialize caller&apos;s probe</span><br><span class="line">    //获取随机数</span><br><span class="line">    if ((r = ThreadLocalRandom.getProbe()) == 0) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; int rs, m, k;</span><br><span class="line">        boolean move = false;</span><br><span class="line">        //线程池已关闭，抛出异常</span><br><span class="line">        if ((rs = runState) &lt; 0) &#123;</span><br><span class="line">            tryTerminate(false, false);     // help terminate</span><br><span class="line">            throw new RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化数组workQueues</span><br><span class="line">        else if ((rs &amp; STARTED) == 0 ||     // initialize</span><br><span class="line">                 ((ws = workQueues) == null || (m = ws.length - 1) &lt; 0)) &#123;</span><br><span class="line">            int ns = 0;</span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((rs &amp; STARTED) == 0) &#123;</span><br><span class="line">                    U.compareAndSwapObject(this, STEALCOUNTER, null,</span><br><span class="line">                                           new AtomicLong());</span><br><span class="line">                    // create workQueues array with size a power of two</span><br><span class="line">                    int p = config &amp; SMASK; // ensure at least 2 slots</span><br><span class="line">                    int n = (p &gt; 1) ? p - 1 : 1;</span><br><span class="line">                    n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2;  n |= n &gt;&gt;&gt; 4;</span><br><span class="line">                    n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n = (n + 1) &lt;&lt; 1;</span><br><span class="line">                    workQueues = new WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //任务加入队列</span><br><span class="line">        else if ((q = ws[k = r &amp; m &amp; SQMASK]) != null) &#123;</span><br><span class="line">            if (q.qlock == 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                int s = q.top;</span><br><span class="line">                boolean submitted = false; // initial submission or resizing</span><br><span class="line">                try &#123;                      // locked version of push</span><br><span class="line">                    if ((a != null &amp;&amp; a.length &gt; s + 1 - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != null) &#123;</span><br><span class="line">                        int j = (((a.length - 1) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + 1);</span><br><span class="line">                        submitted = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, 1, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                if (submitted) &#123;</span><br><span class="line">                    //创建工作线程</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = true;                   // move on failure</span><br><span class="line">        &#125;</span><br><span class="line">        //队列不存在，创建队列</span><br><span class="line">        else if (((rs = runState) &amp; RSLOCK) == 0) &#123; // create new queue</span><br><span class="line">            q = new WorkQueue(this, null);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            //队列中不存在工作线程</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           // publish index</span><br><span class="line">            if (rs &gt; 0 &amp;&amp;  (ws = workQueues) != null &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == null)</span><br><span class="line">                ws[k] = q;                 // else terminated</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            move = true;                   // move if busy</span><br><span class="line">        //添加失败,换个数组下标</span><br><span class="line">        if (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、ForkJoinPool的signalWork"><a href="#5、ForkJoinPool的signalWork" class="headerlink" title="5、ForkJoinPool的signalWork"></a>5、ForkJoinPool的signalWork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">final void signalWork(WorkQueue[] ws, WorkQueue q) &#123;</span><br><span class="line">    long c; int sp, i; WorkQueue v; Thread p;</span><br><span class="line">    //ctl小于零，说明活跃工作线程数量未达到上限</span><br><span class="line">    while ((c = ctl) &lt; 0L) &#123;                       // too few active</span><br><span class="line">        //没有等待线程</span><br><span class="line">        if ((sp = (int)c) == 0) &#123;                  // no idle workers</span><br><span class="line">            //总线程数未达到上限</span><br><span class="line">            if ((c &amp; ADD_WORKER) != 0L)            // too few workers</span><br><span class="line">                //创建新工作线程</span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ws == null)                            // unstarted/terminated</span><br><span class="line">            break;</span><br><span class="line">        if (ws.length &lt;= (i = sp &amp; SMASK))         // terminated</span><br><span class="line">            break;</span><br><span class="line">        if ((v = ws[i]) == null)                   // terminating</span><br><span class="line">            break;</span><br><span class="line">        int vs = (sp + SS_SEQ) &amp; ~INACTIVE;        // next scanState</span><br><span class="line">        int d = sp - v.scanState;                  // screen CAS</span><br><span class="line">        //活跃线程加1，唤醒一个正在等待的线程，stackPred保存的前一个等待线程的位置信息</span><br><span class="line">        long nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        if (d == 0 &amp;&amp; U.compareAndSwapLong(this, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      // activate v</span><br><span class="line">            if ((p = v.parker) != null)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (q != null &amp;&amp; q.base == q.top)          // no more work</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、ForkJoinPool的tryAddWorker"><a href="#6、ForkJoinPool的tryAddWorker" class="headerlink" title="6、ForkJoinPool的tryAddWorker"></a>6、ForkJoinPool的tryAddWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void tryAddWorker(long c) &#123;</span><br><span class="line">    boolean add = false;</span><br><span class="line">    do &#123;</span><br><span class="line">        //活跃线程，总线程数量分别加1</span><br><span class="line">        long nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        if (ctl == c) &#123;</span><br><span class="line">            int rs, stop;                 // check if terminating</span><br><span class="line">            if ((stop = (rs = lockRunState()) &amp; STOP) == 0)</span><br><span class="line">                add = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            if (stop != 0)</span><br><span class="line">                break;</span><br><span class="line">            if (add) &#123;</span><br><span class="line">                //创建工作线程</span><br><span class="line">                createWorker();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (((c = ctl) &amp; ADD_WORKER) != 0L &amp;&amp; (int)c == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、ForkJoinPool的createWorker"><a href="#7、ForkJoinPool的createWorker" class="headerlink" title="7、ForkJoinPool的createWorker"></a>7、ForkJoinPool的createWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private boolean createWorker() &#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = null;</span><br><span class="line">    ForkJoinWorkerThread wt = null;</span><br><span class="line">    //创建工作线程，并启动</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fac != null &amp;&amp; (wt = fac.newThread(this)) != null) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、实例化ForkJoinWorkerThread"><a href="#8、实例化ForkJoinWorkerThread" class="headerlink" title="8、实例化ForkJoinWorkerThread"></a>8、实例化ForkJoinWorkerThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected ForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">    // Use a placeholder until a useful name can be set in registerWorker</span><br><span class="line">    super(&quot;aForkJoinWorkerThread&quot;);</span><br><span class="line">    this.pool = pool;</span><br><span class="line">    this.workQueue = pool.registerWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、ForkJoinPool的registerWorker"><a href="#9、ForkJoinPool的registerWorker" class="headerlink" title="9、ForkJoinPool的registerWorker"></a>9、ForkJoinPool的registerWorker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final WorkQueue registerWorker(ForkJoinWorkerThread wt) &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(true);                           // configure thread</span><br><span class="line">    if ((handler = ueh) != null)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    //创建该工作线程的队列</span><br><span class="line">    WorkQueue w = new WorkQueue(this, wt);</span><br><span class="line">    int i = 0;                                    // assign a pool index</span><br><span class="line">    int mode = config &amp; MODE_MASK;</span><br><span class="line">    int rs = lockRunState();</span><br><span class="line">    try &#123;</span><br><span class="line">        WorkQueue[] ws; int n;                    // skip if no array</span><br><span class="line">        if ((ws = workQueues) != null &amp;&amp; (n = ws.length) &gt; 0) &#123;</span><br><span class="line">            //随机数的种子</span><br><span class="line">            int s = indexSeed += SEED_INCREMENT;  // unlikely to collide</span><br><span class="line">            int m = n - 1;</span><br><span class="line">            //奇数</span><br><span class="line">            i = ((s &lt;&lt; 1) | 1) &amp; m;               // odd-numbered indices</span><br><span class="line">            if (ws[i] != null) &#123;                  // collision</span><br><span class="line">                int probes = 0;                   // step by approx half n</span><br><span class="line">                //偶数</span><br><span class="line">                int step = (n &lt;= 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2;</span><br><span class="line">                while (ws[i = (i + step) &amp; m] != null) &#123;</span><br><span class="line">                    if (++probes &gt;= n) &#123;</span><br><span class="line">                        //数组扩容</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= 1);</span><br><span class="line">                        m = n - 1;</span><br><span class="line">                        probes = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           // use as random seed</span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            //队列中存在工作线程，数组中的下标</span><br><span class="line">            w.scanState = i;                      // publication fence</span><br><span class="line">            //队列放入数组的奇数位</span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; 1)));</span><br><span class="line">    return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、接（一、8）ForkJoinWorkerThread的run方法"><a href="#10、接（一、8）ForkJoinWorkerThread的run方法" class="headerlink" title="10、接（一、8）ForkJoinWorkerThread的run方法"></a>10、接（一、8）ForkJoinWorkerThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (workQueue.array == null) &#123; // only run once</span><br><span class="line">        Throwable exception = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //空函数,待覆盖</span><br><span class="line">            onStart();</span><br><span class="line">            //处理任务</span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                if (exception == null)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                pool.deregisterWorker(this, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、ForkJoinPool的runWorker方法"><a href="#11、ForkJoinPool的runWorker方法" class="headerlink" title="11、ForkJoinPool的runWorker方法"></a>11、ForkJoinPool的runWorker方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(WorkQueue w) &#123;</span><br><span class="line">    //数组扩容</span><br><span class="line">    w.growArray();                   // allocate queue</span><br><span class="line">    int seed = w.hint;               // initially holds randomization hint</span><br><span class="line">    int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift</span><br><span class="line">    for (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        //偷取任务</span><br><span class="line">        if ((t = scan(w, r)) != null)</span><br><span class="line">            //执行任务</span><br><span class="line">            w.runTask(t);</span><br><span class="line">        //无任务,线程等待</span><br><span class="line">        else if (!awaitWork(w, r))</span><br><span class="line">            break;</span><br><span class="line">        //下一个随机数</span><br><span class="line">        r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // xorshift</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、ForkJoinPool的scan方法"><a href="#12、ForkJoinPool的scan方法" class="headerlink" title="12、ForkJoinPool的scan方法"></a>12、ForkJoinPool的scan方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinTask&lt;?&gt; scan(WorkQueue w, int r) &#123;</span><br><span class="line">    WorkQueue[] ws; int m;</span><br><span class="line">    if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt; 0 &amp;&amp; w != null) &#123;</span><br><span class="line">        int ss = w.scanState;                     // initially non-negative</span><br><span class="line">        for (int origin = r &amp; m, k = origin, oldSum = 0, checkSum = 0;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            int b, n; long c;</span><br><span class="line">            //从随机下标k，获取队列</span><br><span class="line">            if ((q = ws[k]) != null) &#123;</span><br><span class="line">                if ((n = (b = q.base) - q.top) &lt; 0 &amp;&amp;</span><br><span class="line">                    (a = q.array) != null) &#123;      // non-empty</span><br><span class="line">                    //从下往上获取任务</span><br><span class="line">                    long i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    if ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != null &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        //工作线程活跃状态</span><br><span class="line">                        if (ss &gt;= 0) &#123;</span><br><span class="line">                            //获取并返回任务</span><br><span class="line">                            if (U.compareAndSwapObject(a, i, t, null)) &#123;</span><br><span class="line">                                q.base = b + 1;</span><br><span class="line">                                //任务较多，创建一个工作线程</span><br><span class="line">                                if (n &lt; -1)       // signal others</span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                return t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //工作线程非活跃状态</span><br><span class="line">                        else if (oldSum == 0 &amp;&amp;   // try to activate</span><br><span class="line">                                 w.scanState &lt; 0)</span><br><span class="line">                            //释放一个等待线程</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (ss &lt; 0)                   // refresh</span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    //获取失败,随机换一个数组下标</span><br><span class="line">                    r ^= r &lt;&lt; 1; r ^= r &gt;&gt;&gt; 3; r ^= r &lt;&lt; 10;</span><br><span class="line">                    origin = k = r &amp; m;           // move and rescan</span><br><span class="line">                    oldSum = checkSum = 0;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            //查找了一圈未找到可偷窃的任务</span><br><span class="line">            if ((k = (k + 1) &amp; m) == origin) &#123;    // continue until stable</span><br><span class="line">                if ((ss &gt;= 0 || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    if (ss &lt; 0 || w.qlock &lt; 0)    // already inactive</span><br><span class="line">                        break;</span><br><span class="line">                    //工作线程转为非活跃状态</span><br><span class="line">                    int ns = ss | INACTIVE;       // try to inactivate</span><br><span class="line">                    //活跃线程数减1</span><br><span class="line">                    long nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    //上一个转非活跃线程的数组下标</span><br><span class="line">                    w.stackPred = (int)c;         // hold prev stack top</span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    if (U.compareAndSwapLong(this, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    else</span><br><span class="line">                        w.scanState = ss;         // back out</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、接（一、11）ForkJoinWorkerThread的runTask方法"><a href="#13、接（一、11）ForkJoinWorkerThread的runTask方法" class="headerlink" title="13、接（一、11）ForkJoinWorkerThread的runTask方法"></a>13、接（一、11）ForkJoinWorkerThread的runTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final void runTask(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    if (task != null) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; // mark as busy</span><br><span class="line">        //执行任务，currentSteal为工作线程当前正在执行的任务</span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(this, QCURRENTSTEAL, null); // release for GC</span><br><span class="line">        //执行本线程队列的任务</span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        if (++nsteals &lt; 0)      // collect on overflow</span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        if (thread != null)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、ForkJoinTask的doExec方法"><a href="#14、ForkJoinTask的doExec方法" class="headerlink" title="14、ForkJoinTask的doExec方法"></a>14、ForkJoinTask的doExec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final int doExec() &#123;</span><br><span class="line">    int s; boolean completed;</span><br><span class="line">    if ((s = status) &gt;= 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行任务</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; catch (Throwable rex) &#123;</span><br><span class="line">            return setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (completed)</span><br><span class="line">            //更新任务状态，唤醒等待任务结果的线程</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、ForkJoinTask的exec方法"><a href="#15、ForkJoinTask的exec方法" class="headerlink" title="15、ForkJoinTask的exec方法"></a>15、ForkJoinTask的exec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean exec() &#123;</span><br><span class="line">    //执行任务</span><br><span class="line">    result = compute();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16、接（一、11）ForkJoinPool的awaitWork方法"><a href="#16、接（一、11）ForkJoinPool的awaitWork方法" class="headerlink" title="16、接（一、11）ForkJoinPool的awaitWork方法"></a>16、接（一、11）ForkJoinPool的awaitWork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private boolean awaitWork(WorkQueue w, int r) &#123;</span><br><span class="line">    if (w == null || w.qlock &lt; 0)                 // w is terminating</span><br><span class="line">        return false;</span><br><span class="line">    for (int pred = w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        //已激活</span><br><span class="line">        if ((ss = w.scanState) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        else if (spins &gt; 0) &#123;</span><br><span class="line">            r ^= r &lt;&lt; 6; r ^= r &gt;&gt;&gt; 21; r ^= r &lt;&lt; 7;</span><br><span class="line">            if (r &gt;= 0 &amp;&amp; --spins == 0) &#123;         // randomize spins</span><br><span class="line">                WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc;</span><br><span class="line">                if (pred != 0 &amp;&amp; (ws = workQueues) != null &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != null &amp;&amp;        // see if pred parking</span><br><span class="line">                    (v.parker == null || v.scanState &gt;= 0))</span><br><span class="line">                    spins = SPINS;                // continue spinning</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (w.qlock &lt; 0)                     // recheck after spins</span><br><span class="line">            return false;</span><br><span class="line">        else if (!Thread.interrupted()) &#123;</span><br><span class="line">            long c, prevctl, parkTime, deadline;</span><br><span class="line">            int ac = (int)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            if ((ac &lt;= 0 &amp;&amp; tryTerminate(false, false)) ||</span><br><span class="line">                (runState &amp; STOP) != 0)           // pool terminating</span><br><span class="line">                return false;</span><br><span class="line">            if (ac &lt;= 0 &amp;&amp; ss == (int)c) &#123;        // is last waiter</span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                int t = (short)(c &gt;&gt;&gt; TC_SHIFT);  // shrink excess spares</span><br><span class="line">                if (t &gt; 2 &amp;&amp; U.compareAndSwapLong(this, CTL, c, prevctl))</span><br><span class="line">                    return false;                 // else use timed wait</span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= 0) ? 1 : 1 - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                prevctl = parkTime = deadline = 0L;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport</span><br><span class="line">            w.parker = wt;</span><br><span class="line">            //阻塞当前线程</span><br><span class="line">            if (w.scanState &lt; 0 &amp;&amp; ctl == c)      // recheck before park</span><br><span class="line">                U.park(false, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, null);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, null);</span><br><span class="line">            if (w.scanState &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            if (parkTime != 0L &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= 0L &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(this, CTL, c, prevctl))</span><br><span class="line">                return false;                     // shrink pool</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、ForkJoinTask的fork方法"><a href="#17、ForkJoinTask的fork方法" class="headerlink" title="17、ForkJoinTask的fork方法"></a>17、ForkJoinTask的fork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final ForkJoinTask&lt;V&gt; fork() &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)</span><br><span class="line">        //任务加入该线程的任务池</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(this);</span><br><span class="line">    else</span><br><span class="line">        //加入公共任务池</span><br><span class="line">        ForkJoinPool.common.externalPush(this);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、ForkJoinTask的join方法"><a href="#18、ForkJoinTask的join方法" class="headerlink" title="18、ForkJoinTask的join方法"></a>18、ForkJoinTask的join方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final V join() &#123;</span><br><span class="line">    int s;</span><br><span class="line">    if ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    //返回结果</span><br><span class="line">    return getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19、ForkJoinTask的doJoin方法"><a href="#19、ForkJoinTask的doJoin方法" class="headerlink" title="19、ForkJoinTask的doJoin方法"></a>19、ForkJoinTask的doJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int doJoin() &#123;</span><br><span class="line">    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    //线程池线程则参与任务处理，非线程池线程则等待任务结束</span><br><span class="line">    return (s = status) &lt; 0 ? s :</span><br><span class="line">        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, this, 0L) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20、ForkJoinTask的doJoin方法"><a href="#20、ForkJoinTask的doJoin方法" class="headerlink" title="20、ForkJoinTask的doJoin方法"></a>20、ForkJoinTask的doJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int doJoin() &#123;</span><br><span class="line">    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    //线程池线程则执行awaitJoin，非线程池线程则执行externalAwaitDone</span><br><span class="line">    return (s = status) &lt; 0 ? s :</span><br><span class="line">        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, this, 0L) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21、ForkJoinPool的awaitJoin方法"><a href="#21、ForkJoinPool的awaitJoin方法" class="headerlink" title="21、ForkJoinPool的awaitJoin方法"></a>21、ForkJoinPool的awaitJoin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final int awaitJoin(WorkQueue w, ForkJoinTask&lt;?&gt; task, long deadline) &#123;</span><br><span class="line">    int s = 0;</span><br><span class="line">    if (task != null &amp;&amp; w != null) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task instanceof CountedCompleter) ?</span><br><span class="line">            (CountedCompleter&lt;?&gt;)task : null;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if ((s = task.status) &lt; 0)</span><br><span class="line">                break;</span><br><span class="line">            if (cc != null)</span><br><span class="line">                helpComplete(w, cc, 0);</span><br><span class="line">            //尝试获取并处理本任务，若任务已被其他线程执行，且本线程队列无任务，则帮助其他线程处理任务</span><br><span class="line">            else if (w.base == w.top || w.tryRemoveAndExec(task))</span><br><span class="line">                //帮助其他线程处理任务</span><br><span class="line">                helpStealer(w, task);</span><br><span class="line">            if ((s = task.status) &lt; 0)</span><br><span class="line">                break;</span><br><span class="line">            long ms, ns;</span><br><span class="line">            if (deadline == 0L)</span><br><span class="line">                ms = 0L;</span><br><span class="line">            else if ((ns = deadline - System.nanoTime()) &lt;= 0L)</span><br><span class="line">                break;</span><br><span class="line">            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= 0L)</span><br><span class="line">                ms = 1L;</span><br><span class="line">            //等待的任务未完成，且本线程队列有任务，作一定的补偿</span><br><span class="line">            if (tryCompensate(w)) &#123;</span><br><span class="line">                //任务未完成则线程等待，否则唤醒等待该任务的线程</span><br><span class="line">                task.internalWait(ms);</span><br><span class="line">                U.getAndAddLong(this, CTL, AC_UNIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22、WorkQueue的tryRemoveAndExec方法"><a href="#22、WorkQueue的tryRemoveAndExec方法" class="headerlink" title="22、WorkQueue的tryRemoveAndExec方法"></a>22、WorkQueue的tryRemoveAndExec方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">final boolean tryRemoveAndExec(ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; int m, s, b, n;</span><br><span class="line">    if ((a = array) != null &amp;&amp; (m = a.length - 1) &gt;= 0 &amp;&amp;</span><br><span class="line">        task != null) &#123;</span><br><span class="line">        while ((n = (s = top) - (b = base)) &gt; 0) &#123;</span><br><span class="line">            for (ForkJoinTask&lt;?&gt; t;;) &#123;      // traverse from s to b</span><br><span class="line">                //从上往下，查找任务</span><br><span class="line">                long j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                if ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == null)</span><br><span class="line">                    //任务已被其他线程处理，队列已无任务返回true，有任务返回false</span><br><span class="line">                    return s + 1 == top;     // shorter than expected</span><br><span class="line">                else if (t == task) &#123;</span><br><span class="line">                    boolean removed = false;</span><br><span class="line">                    //task刚好在top位置，pop出来执行</span><br><span class="line">                    if (s + 1 == top) &#123;      // pop</span><br><span class="line">                        if (U.compareAndSwapObject(a, j, task, null)) &#123;</span><br><span class="line">                            U.putOrderedInt(this, QTOP, s);</span><br><span class="line">                            removed = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //task在队列中间,则使用EmptyTask来占位,将任务取出来执行</span><br><span class="line">                    else if (base == b)      // replace with proxy</span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                            a, j, task, new EmptyTask());</span><br><span class="line">                    if (removed)</span><br><span class="line">                        task.doExec();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //任务已被取消</span><br><span class="line">                else if (t.status &lt; 0 &amp;&amp; s + 1 == top) &#123;</span><br><span class="line">                    if (U.compareAndSwapObject(a, j, t, null))</span><br><span class="line">                        U.putOrderedInt(this, QTOP, s);</span><br><span class="line">                    break;                  // was cancelled</span><br><span class="line">                &#125;</span><br><span class="line">                if (--n == 0)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //任务已执行完</span><br><span class="line">            if (task.status &lt; 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23、ForkJoinPool的helpStealer方法"><a href="#23、ForkJoinPool的helpStealer方法" class="headerlink" title="23、ForkJoinPool的helpStealer方法"></a>23、ForkJoinPool的helpStealer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">private void helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task) &#123;</span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    int oldSum = 0, checkSum, m;</span><br><span class="line">    if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp; w != null &amp;&amp;</span><br><span class="line">        task != null) &#123;</span><br><span class="line">        do &#123;                                       // restart point</span><br><span class="line">            checkSum = 0;                          // for stability check</span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            WorkQueue j = w, v;                    // v is subtask stealer</span><br><span class="line">            descent: for (subtask = task; subtask.status &gt;= 0; ) &#123;</span><br><span class="line">                for (int h = j.hint | 1, k = 0, i; ; k += 2) &#123;</span><br><span class="line">                    if (k &gt; m)                     // can&apos;t find stealer</span><br><span class="line">                        break descent;</span><br><span class="line">                    //查找正在执行本任务的线程队列</span><br><span class="line">                    if ((v = ws[i = (h + k) &amp; m]) != null) &#123;</span><br><span class="line">                        if (v.currentSteal == subtask) &#123;</span><br><span class="line">                            j.hint = i;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (;;) &#123;                         // help v or descend</span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a; int b;</span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;</span><br><span class="line">                    if (subtask.status &lt; 0 || j.currentJoin != subtask ||</span><br><span class="line">                        v.currentSteal != subtask) // stale</span><br><span class="line">                        break descent;</span><br><span class="line">                    //帮助线程的任务队列为空，则去帮助“该线程等待任务”的执行线程</span><br><span class="line">                    if (b - v.top &gt;= 0 || (a = v.array) == null) &#123;</span><br><span class="line">                        if ((subtask = next) == null)</span><br><span class="line">                            break descent;</span><br><span class="line">                        j = v;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //从下往上获取并执行任务</span><br><span class="line">                    int i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                         U.getObjectVolatile(a, i));</span><br><span class="line">                    if (v.base == b) &#123;</span><br><span class="line">                        if (t == null)             // stale</span><br><span class="line">                            break descent;</span><br><span class="line">                        if (U.compareAndSwapObject(a, i, t, null)) &#123;</span><br><span class="line">                            v.base = b + 1;</span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;</span><br><span class="line">                            int top = w.top;</span><br><span class="line">                            do &#123;</span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                t.doExec();        // clear local tasks too</span><br><span class="line">                            &#125; while (task.status &gt;= 0 &amp;&amp;</span><br><span class="line">                                     w.top != top &amp;&amp;</span><br><span class="line">                                     (t = w.pop()) != null);</span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);</span><br><span class="line">                            if (w.base != w.top)</span><br><span class="line">                                return;            // can&apos;t further help</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (task.status &gt;= 0 &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24、接（一、21）ForkJoinPool的tryCompensate方法"><a href="#24、接（一、21）ForkJoinPool的tryCompensate方法" class="headerlink" title="24、接（一、21）ForkJoinPool的tryCompensate方法"></a>24、接（一、21）ForkJoinPool的tryCompensate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private boolean tryCompensate(WorkQueue w) &#123;</span><br><span class="line">    boolean canBlock;</span><br><span class="line">    WorkQueue[] ws; long c; int m, pc, sp;</span><br><span class="line">    if (w == null || w.qlock &lt; 0 ||           // caller terminating</span><br><span class="line">        (ws = workQueues) == null || (m = ws.length - 1) &lt;= 0 ||</span><br><span class="line">        (pc = config &amp; SMASK) == 0)           // parallelism disabled</span><br><span class="line">        canBlock = false;</span><br><span class="line">    //唤醒一个阻塞线程，补偿该线程</span><br><span class="line">    else if ((sp = (int)(c = ctl)) != 0)      // release idle worker</span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], 0L);</span><br><span class="line">    else &#123;</span><br><span class="line">        int ac = (int)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        int tc = (short)(c &gt;&gt; TC_SHIFT) + pc;</span><br><span class="line">        int nbusy = 0;                        // validate saturation</span><br><span class="line">        for (int i = 0; i &lt;= m; ++i) &#123;        // two passes of odd indices</span><br><span class="line">            WorkQueue v;</span><br><span class="line">            if ((v = ws[((i &lt;&lt; 1) | 1) &amp; m]) != null) &#123;</span><br><span class="line">                if ((v.scanState &amp; SCANNING) != 0)</span><br><span class="line">                    break;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nbusy != (tc &lt;&lt; 1) || ctl != c)</span><br><span class="line">            canBlock = false;                 // unstable or stale</span><br><span class="line">        //直接阻塞，无需补偿</span><br><span class="line">        else if (tc &gt;= pc &amp;&amp; ac &gt; 1 &amp;&amp; w.isEmpty()) &#123;</span><br><span class="line">            long nc = ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                       (~AC_MASK &amp; c));       // uncompensated</span><br><span class="line">            canBlock = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (tc &gt;= MAX_CAP ||</span><br><span class="line">                 (this == common &amp;&amp; tc &gt;= pc + commonMaxSpares))</span><br><span class="line">            throw new RejectedExecutionException(</span><br><span class="line">                &quot;Thread limit exceeded replacing blocked worker&quot;);</span><br><span class="line">        else &#123;                                // similar to tryAddWorker</span><br><span class="line">            boolean add = false; int rs;      // CAS within lock</span><br><span class="line">            long nc = ((AC_MASK &amp; c) |</span><br><span class="line">                       (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">            if (((rs = lockRunState()) &amp; STOP) == 0)</span><br><span class="line">                add = U.compareAndSwapLong(this, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            //创建新线程，补偿该线程</span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); // throws on exception</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="25、ForkJoinPool的shutdown方法"><a href="#25、ForkJoinPool的shutdown方法" class="headerlink" title="25、ForkJoinPool的shutdown方法"></a>25、ForkJoinPool的shutdown方法</h4><p>关闭线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    //关闭线程池</span><br><span class="line">    tryTerminate(false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="25、ForkJoinPool的tryTerminate方法"><a href="#25、ForkJoinPool的tryTerminate方法" class="headerlink" title="25、ForkJoinPool的tryTerminate方法"></a>25、ForkJoinPool的tryTerminate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private boolean tryTerminate(boolean now, boolean enable) &#123;</span><br><span class="line">    int rs;</span><br><span class="line">    //公共池不能关闭</span><br><span class="line">    if (this == common)                       // cannot shut down</span><br><span class="line">        return false;</span><br><span class="line">    if ((rs = runState) &gt;= 0) &#123;</span><br><span class="line">        if (!enable)</span><br><span class="line">            return false;</span><br><span class="line">        rs = lockRunState();                  // enter SHUTDOWN phase</span><br><span class="line">        //进入关闭阶段</span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | SHUTDOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((rs &amp; STOP) == 0) &#123;</span><br><span class="line">        if (!now) &#123;                           // check quiescence</span><br><span class="line">            for (long oldSum = 0L;;) &#123;        // repeat until stable</span><br><span class="line">                WorkQueue[] ws; WorkQueue w; int m, b; long c;</span><br><span class="line">                long checkSum = ctl;</span><br><span class="line">                if ((int)(checkSum &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &gt; 0)</span><br><span class="line">                    return false;             // still active workers</span><br><span class="line">                if ((ws = workQueues) == null || (m = ws.length - 1) &lt;= 0)</span><br><span class="line">                    break;                    // check queues</span><br><span class="line">                //释放阻塞的队列</span><br><span class="line">                for (int i = 0; i &lt;= m; ++i) &#123;</span><br><span class="line">                    if ((w = ws[i]) != null) &#123;</span><br><span class="line">                        if ((b = w.base) != w.top || w.scanState &gt;= 0 ||</span><br><span class="line">                            w.currentSteal != null) &#123;</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT);</span><br><span class="line">                            return false;     // arrange for recheck</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += b;</span><br><span class="line">                        if ((i &amp; 1) == 0)</span><br><span class="line">                            w.qlock = -1;     // try to disable external</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (oldSum == (oldSum = checkSum))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((runState &amp; STOP) == 0) &#123;</span><br><span class="line">            rs = lockRunState();              // enter STOP phase</span><br><span class="line">            //进入stop阶段</span><br><span class="line">            unlockRunState(rs, (rs &amp; ~RSLOCK) | STOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pass = 0;                             // 3 passes to help terminate</span><br><span class="line">    for (long oldSum = 0L;;) &#123;                // or until done or stable</span><br><span class="line">        WorkQueue[] ws; WorkQueue w; ForkJoinWorkerThread wt; int m;</span><br><span class="line">        long checkSum = ctl;</span><br><span class="line">        if ((short)(checkSum &gt;&gt;&gt; TC_SHIFT) + (config &amp; SMASK) &lt;= 0 ||</span><br><span class="line">            (ws = workQueues) == null || (m = ws.length - 1) &lt;= 0) &#123;</span><br><span class="line">            if ((runState &amp; TERMINATED) == 0) &#123;</span><br><span class="line">                rs = lockRunState();          // done</span><br><span class="line">                //进入TERMINATED阶段</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | TERMINATED);</span><br><span class="line">                synchronized (this) &#123; notifyAll(); &#125; // for awaitTermination</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //取消未完成任务，中断工作线程</span><br><span class="line">        for (int i = 0; i &lt;= m; ++i) &#123;</span><br><span class="line">            if ((w = ws[i]) != null) &#123;</span><br><span class="line">                checkSum += w.base;</span><br><span class="line">                w.qlock = -1;                 // try to disable</span><br><span class="line">                if (pass &gt; 0) &#123;</span><br><span class="line">                    w.cancelAll();            // clear queue</span><br><span class="line">                    if (pass &gt; 1 &amp;&amp; (wt = w.owner) != null) &#123;</span><br><span class="line">                        if (!wt.isInterrupted()) &#123;</span><br><span class="line">                            try &#123;             // unblock join</span><br><span class="line">                                wt.interrupt();</span><br><span class="line">                            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (w.scanState &lt; 0)</span><br><span class="line">                            U.unpark(wt);     // wake up</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkSum != oldSum) &#123;             // unstable</span><br><span class="line">            oldSum = checkSum;</span><br><span class="line">            pass = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pass &gt; 3 &amp;&amp; pass &gt; m)        // can&apos;t further help</span><br><span class="line">            break;</span><br><span class="line">        else if (++pass &gt; 1) &#123;                // try to dequeue</span><br><span class="line">            long c; int j = 0, sp;            // bound attempts</span><br><span class="line">            while (j++ &lt;= m &amp;&amp; (sp = (int)(c = ctl)) != 0)</span><br><span class="line">                tryRelease(c, ws[sp &amp; m], AC_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC线程池(1)ThreadPoolExecutor</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0(1)ThreadPoolExecutor/"/>
      <content type="html"><![CDATA[<h2 id="JUC线程池-1-ThreadPoolExecutor"><a href="#JUC线程池-1-ThreadPoolExecutor" class="headerlink" title="JUC线程池(1)ThreadPoolExecutor"></a>JUC线程池(1)ThreadPoolExecutor</h2><p>###线程池demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolDemo1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">// 创建一个可重用固定线程数的线程池</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(2);</span><br><span class="line">// 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span><br><span class="line">Thread ta = new MyThread();</span><br><span class="line">Thread tb = new MyThread();</span><br><span class="line">Thread tc = new MyThread();</span><br><span class="line">Thread td = new MyThread();</span><br><span class="line">Thread te = new MyThread();</span><br><span class="line">// 将线程放入池中进行执行</span><br><span class="line">pool.execute(ta);</span><br><span class="line">pool.execute(tb);</span><br><span class="line">pool.execute(tc);</span><br><span class="line">pool.execute(td);</span><br><span class="line">pool.execute(te);</span><br><span class="line">// 关闭线程池</span><br><span class="line">pool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一、ThreadPoolExecutor"><a href="#一、ThreadPoolExecutor" class="headerlink" title="一、ThreadPoolExecutor"></a>一、ThreadPoolExecutor</h3><h4 id="1、Executors的newFixedThreadPool方法"><a href="#1、Executors的newFixedThreadPool方法" class="headerlink" title="1、Executors的newFixedThreadPool方法"></a>1、Executors的newFixedThreadPool方法</h4><p>创建线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程池状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RUNNING    -- 对应的高3位值是111</span><br><span class="line">            线程池的初始化状态是RUNNING，</span><br><span class="line">            线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理</span><br><span class="line">SHUTDOWN   -- 对应的高3位值是000</span><br><span class="line">            调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN</span><br><span class="line">            线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</span><br><span class="line">STOP       -- 对应的高3位值是001</span><br><span class="line">            调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP</span><br><span class="line">            线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</span><br><span class="line">TIDYING    -- 对应的高3位值是010，</span><br><span class="line">            当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING</span><br><span class="line">            当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING</span><br><span class="line">            当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的</span><br><span class="line">TERMINATED -- 对应的高3位值是011</span><br><span class="line">            线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</span><br><span class="line">            线程池彻底终止，就变成TERMINATED状态</span><br></pre></td></tr></table></figure></p><h4 id="2、实例化ThreadPoolExecutor"><a href="#2、实例化ThreadPoolExecutor" class="headerlink" title="2、实例化ThreadPoolExecutor"></a>2、实例化ThreadPoolExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    // 核心池大小</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    // 最大池大小</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    // 线程池的等待队列</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    // 线程工厂对象，默认DefaultThreadFactory</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    // 拒绝策略，默认AbortPolicy 抛出异常</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、ThreadPoolExecutor的execute方法"><a href="#3、ThreadPoolExecutor的execute方法" class="headerlink" title="3、ThreadPoolExecutor的execute方法"></a>3、ThreadPoolExecutor的execute方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    // 如果任务为null，则抛出异常。</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 获取ctl对应的int值。c保存了后29位保存线程池中任务的数量，前3位保存线程池状态信息</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 当线程池中的任务数量 &lt; 核心池大小时，即线程池中少于corePoolSize个任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 则通过addWorker(command, true)新建一个线程，</span><br><span class="line">        // 并添加到该线程中；然后，启动该线程从而执行任务。</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 当线程池中的任务数量 &gt;= 核心池大小时，则尝试将任务添加到阻塞队列中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 若线程池异常终止了，则删除任务；然后通过reject()执行相应的拒绝策略的内容</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        // 如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线程</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、ThreadPoolExecutor的addWorker方法"><a href="#4、ThreadPoolExecutor的addWorker方法" class="headerlink" title="4、ThreadPoolExecutor的addWorker方法"></a>4、ThreadPoolExecutor的addWorker方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    // 更新线程池状态和计数，即更新ctl</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 获取ctl对应的int值</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        // 获取线程池状态</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // 必要时，坚持等待队列是否为空</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 获取线程池中任务的数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 如果线程池中任务的数量超过限制，则返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            // 通过CAS函数将c的值+1。操作成功的话，则退出循环</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            // 检查线程池状态，如果与之前的状态不同，则从retry重新开始</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    // 添加任务到线程池，并启动任务所在的线程</span><br><span class="line">    try &#123;</span><br><span class="line">        // 新建Worker，并且指定firstTask为Worker的第一个任务</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        // 获取Worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            // 获取锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 确认线程池状态</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    // 将Worker对象(w)添加到线程池的Worker集合(workers)中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    // 更新largestPoolSize</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果成功将任务添加到线程池中，则启动任务所在的线程</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回任务是否启动</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、Worker的run方法"><a href="#4、Worker的run方法" class="headerlink" title="4、Worker的run方法"></a>4、Worker的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Worker的runWorker方法"><a href="#5、Worker的runWorker方法" class="headerlink" title="5、Worker的runWorker方法"></a>5、Worker的runWorker方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取任务</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            //检查线程池状态</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //执行任务</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭worker</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Worker的getTask方法"><a href="#6、Worker的getTask方法" class="headerlink" title="6、Worker的getTask方法"></a>6、Worker的getTask方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        //检查线程池状态</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        // worker是否要关闭</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //获取任务</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（一、5）Worker的processWorkerExit方法"><a href="#7、接（一、5）Worker的processWorkerExit方法" class="headerlink" title="7、接（一、5）Worker的processWorkerExit方法"></a>7、接（一、5）Worker的processWorkerExit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    //减少worker数量</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        //删除该worker</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //尝试彻底关闭线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        //线程池未停止，尝试增加一个worker</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、ThreadPoolExecutor的tryTerminate方法"><a href="#8、ThreadPoolExecutor的tryTerminate方法" class="headerlink" title="8、ThreadPoolExecutor的tryTerminate方法"></a>8、ThreadPoolExecutor的tryTerminate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //将线程池状态转换为TIDYING</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //钩子函数，在ThreadPoolExecutor中没有任何动作</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //彻底关闭线程池</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、ThreadPoolExecutor的shutdown方法"><a href="#9、ThreadPoolExecutor的shutdown方法" class="headerlink" title="9、ThreadPoolExecutor的shutdown方法"></a>9、ThreadPoolExecutor的shutdown方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 检查终止线程池的线程是否有权限</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        // 设置线程池的状态为关闭状态</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        // 中断线程池中空闲的线程</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        // 钩子函数，在ThreadPoolExecutor中没有任何动作</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、ThreadPoolExecutor的advanceRunState方法"><a href="#10、ThreadPoolExecutor的advanceRunState方法" class="headerlink" title="10、ThreadPoolExecutor的advanceRunState方法"></a>10、ThreadPoolExecutor的advanceRunState方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void advanceRunState(int targetState) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //尚未关闭，则尝试关闭</span><br><span class="line">        if (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、ThreadPoolExecutor的interruptIdleWorkers方法"><a href="#11、ThreadPoolExecutor的interruptIdleWorkers方法" class="headerlink" title="11、ThreadPoolExecutor的interruptIdleWorkers方法"></a>11、ThreadPoolExecutor的interruptIdleWorkers方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">    interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、ThreadPoolExecutor的interruptIdleWorkers方法"><a href="#12、ThreadPoolExecutor的interruptIdleWorkers方法" class="headerlink" title="12、ThreadPoolExecutor的interruptIdleWorkers方法"></a>12、ThreadPoolExecutor的interruptIdleWorkers方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //中断工作线程</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Callable和Future"><a href="#二、Callable和Future" class="headerlink" title="二、Callable和Future"></a>二、Callable和Future</h3><p>####demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MyCallable implements Callable &#123;</span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        int sum    = 0;</span><br><span class="line">       // 执行任务</span><br><span class="line">       for (int i=0; i&lt;100; i++)</span><br><span class="line">           sum += i;</span><br><span class="line">       //return sum; </span><br><span class="line">       return Integer.valueOf(sum);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableTest1 &#123;</span><br><span class="line">    public static void main(String[] args) </span><br><span class="line">        throws ExecutionException, InterruptedException&#123;</span><br><span class="line">        //创建一个线程池</span><br><span class="line">       ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">       //创建有返回值的任务</span><br><span class="line">       Callable c1 = new MyCallable();</span><br><span class="line">       //执行任务并获取Future对象 </span><br><span class="line">       Future f1 = pool.submit(c1);</span><br><span class="line">       // 输出结果</span><br><span class="line">       System.out.println(f1.get()); </span><br><span class="line">       //关闭线程池 </span><br><span class="line">       pool.shutdown(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1、AbstractExecutorService的submit方法"><a href="#1、AbstractExecutorService的submit方法" class="headerlink" title="1、AbstractExecutorService的submit方法"></a>1、AbstractExecutorService的submit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    //Callable包装成FutureTask</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    //包装后的FutureTask加入线程池</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实例化FutureTask"><a href="#2、实例化FutureTask" class="headerlink" title="2、实例化FutureTask"></a>2、实例化FutureTask</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = FutureTask.class;</span><br><span class="line">        //任务状态</span><br><span class="line">        stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        //执行任务的线程</span><br><span class="line">        runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;runner&quot;));</span><br><span class="line">        ///等待获取任务的线程队列</span><br><span class="line">        waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;waiters&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、FutureTask的run方法"><a href="#3、FutureTask的run方法" class="headerlink" title="3、FutureTask的run方法"></a>3、FutureTask的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                //执行callable</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                //更新结果</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、FutureTask的set方法"><a href="#3、FutureTask的set方法" class="headerlink" title="3、FutureTask的set方法"></a>3、FutureTask的set方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    //更新任务状态</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        //更新任务状态</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        //任务完成，唤醒等待获取结果的线程</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、FutureTask的finishCompletion方法"><a href="#4、FutureTask的finishCompletion方法" class="headerlink" title="4、FutureTask的finishCompletion方法"></a>4、FutureTask的finishCompletion方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    // assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    q.thread = null;</span><br><span class="line">                    //唤醒线程</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next = null; // unlink to help gc</span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = null;        // to reduce footprint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、FutureTask的get方法"><a href="#5、FutureTask的get方法" class="headerlink" title="5、FutureTask的get方法"></a>5、FutureTask的get方法</h4><p>获取任务结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    //任务尚未执行完成，线程进入等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    //返回结果</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、FutureTask的awaitDone方法"><a href="#6、FutureTask的awaitDone方法" class="headerlink" title="6、FutureTask的awaitDone方法"></a>6、FutureTask的awaitDone方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private int awaitDone(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //线程终止，清除本线程节点</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        //任务已完成</span><br><span class="line">        if (s &gt; COMPLETING) &#123;</span><br><span class="line">            if (q != null)</span><br><span class="line">                q.thread = null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        //正在完成</span><br><span class="line">        else if (s == COMPLETING) // cannot time out yet</span><br><span class="line">            Thread.yield();</span><br><span class="line">        //创建节点</span><br><span class="line">        else if (q == null)</span><br><span class="line">            q = new WaitNode();</span><br><span class="line">        //节点加入队列</span><br><span class="line">        else if (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        //阻塞该线程</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（二、5）FutureTask的report方法"><a href="#7、接（二、5）FutureTask的report方法" class="headerlink" title="7、接（二、5）FutureTask的report方法"></a>7、接（二、5）FutureTask的report方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        //返回任务结果</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC原子类</title>
      <link href="/2018/05/06/JUC%E6%BA%90%E7%A0%81/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%20/"/>
      <content type="html"><![CDATA[<h2 id="JUC原子类"><a href="#JUC原子类" class="headerlink" title="JUC原子类"></a>JUC原子类</h2><h3 id="一、AtomicLong源码"><a href="#一、AtomicLong源码" class="headerlink" title="一、AtomicLong源码"></a>一、AtomicLong源码</h3><h4 id="1、实例化AtomicLong"><a href="#1、实例化AtomicLong" class="headerlink" title="1、实例化AtomicLong"></a>1、实例化AtomicLong</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取AtomicLong类的value字段，在AtomicLong对象中的地址偏移量</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(AtomicLong.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public AtomicLong() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、AtomicLong的incrementAndGet方法"><a href="#2、AtomicLong的incrementAndGet方法" class="headerlink" title="2、AtomicLong的incrementAndGet方法"></a>2、AtomicLong的incrementAndGet方法</h4><p>以incrementAndGet为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final long incrementAndGet() &#123;</span><br><span class="line">    //AtomicLong对象的valueOffset位置的值加一，并返回原来的值加一</span><br><span class="line">    return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、Unsafe的getAndAddLong方法"><a href="#3、Unsafe的getAndAddLong方法" class="headerlink" title="3、Unsafe的getAndAddLong方法"></a>3、Unsafe的getAndAddLong方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndAddLong(Object arg0, long arg1, long arg3) &#123;</span><br><span class="line">    long arg5;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取arg0对象arg1位置的值</span><br><span class="line">        arg5 = this.getLongVolatile(arg0, arg1);</span><br><span class="line">        //将arg0对象arg1位置的值，由arg5改为arg5 + arg3，成功返回true，失败返回false</span><br><span class="line">    &#125; while (!this.compareAndSwapLong(arg0, arg1, arg5, arg5 + arg3));</span><br><span class="line">    return arg5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、AtomicLongArray源码"><a href="#二、AtomicLongArray源码" class="headerlink" title="二、AtomicLongArray源码"></a>二、AtomicLongArray源码</h3><h4 id="1、实例化AtomicLongArray"><a href="#1、实例化AtomicLongArray" class="headerlink" title="1、实例化AtomicLongArray"></a>1、实例化AtomicLongArray</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    //获取数组中一个元素的大小(get size of an element in the array) </span><br><span class="line">    int scale = unsafe.arrayIndexScale(long[].class);</span><br><span class="line">    if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">        throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">    //scale为2的shift次方</span><br><span class="line">    shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public AtomicLongArray(int length) &#123;</span><br><span class="line">    array = new long[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Integer的numberOfLeadingZeros方法"><a href="#2、Integer的numberOfLeadingZeros方法" class="headerlink" title="2、Integer的numberOfLeadingZeros方法"></a>2、Integer的numberOfLeadingZeros方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int numberOfLeadingZeros(int i) &#123;</span><br><span class="line">    // HD, Figure 5-6</span><br><span class="line">    if (i == 0)</span><br><span class="line">        return 32;</span><br><span class="line">    int n = 1;</span><br><span class="line">    //判断i的左16位是否为零</span><br><span class="line">    if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125;</span><br><span class="line">    //判断不为零的那半部分，左八位是否为零</span><br><span class="line">    if (i &gt;&gt;&gt; 24 == 0) &#123; n +=  8; i &lt;&lt;=  8; &#125;</span><br><span class="line">    if (i &gt;&gt;&gt; 28 == 0) &#123; n +=  4; i &lt;&lt;=  4; &#125;</span><br><span class="line">    if (i &gt;&gt;&gt; 30 == 0) &#123; n +=  2; i &lt;&lt;=  2; &#125;</span><br><span class="line">    n -= i &gt;&gt;&gt; 31;</span><br><span class="line">    //返回i，首部0的个数</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、AtomicLongArray的incrementAndGet方法"><a href="#3、AtomicLongArray的incrementAndGet方法" class="headerlink" title="3、AtomicLongArray的incrementAndGet方法"></a>3、AtomicLongArray的incrementAndGet方法</h4><p>以incrementAndGet为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final long incrementAndGet(int i) &#123;</span><br><span class="line">    return getAndAdd(i, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、AtomicLongArray的getAndAdd方法"><a href="#4、AtomicLongArray的getAndAdd方法" class="headerlink" title="4、AtomicLongArray的getAndAdd方法"></a>4、AtomicLongArray的getAndAdd方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndAdd(int i, long delta) &#123;</span><br><span class="line">    return unsafe.getAndAddLong(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、AtomicLongArray的checkedByteOffset方法"><a href="#5、AtomicLongArray的checkedByteOffset方法" class="headerlink" title="5、AtomicLongArray的checkedByteOffset方法"></a>5、AtomicLongArray的checkedByteOffset方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private long checkedByteOffset(int i) &#123;</span><br><span class="line">    if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line">    return byteOffset(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、AtomicLongArray的byteOffset方法"><a href="#6、AtomicLongArray的byteOffset方法" class="headerlink" title="6、AtomicLongArray的byteOffset方法"></a>6、AtomicLongArray的byteOffset方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static long byteOffset(int i) &#123;</span><br><span class="line">    //数组第i的元素的地址偏移</span><br><span class="line">    return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base为数组在AtomicLongArray中的地址偏移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int base = unsafe.arrayBaseOffset(long[].class);</span><br></pre></td></tr></table></figure></p><h4 id="7、接（二、4）Unsafe的getAndAddLong方法"><a href="#7、接（二、4）Unsafe的getAndAddLong方法" class="headerlink" title="7、接（二、4）Unsafe的getAndAddLong方法"></a>7、接（二、4）Unsafe的getAndAddLong方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndAddLong(Object arg0, long arg1, long arg3) &#123;</span><br><span class="line">    long arg5;</span><br><span class="line">    do &#123;</span><br><span class="line">        arg5 = this.getLongVolatile(arg0, arg1);</span><br><span class="line">    &#125; while (!this.compareAndSwapLong(arg0, arg1, arg5, arg5 + arg3));</span><br><span class="line"></span><br><span class="line">    return arg5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、AtomicReference源码"><a href="#三、AtomicReference源码" class="headerlink" title="三、AtomicReference源码"></a>三、AtomicReference源码</h3><h4 id="1、实例化AtomicReference"><a href="#1、实例化AtomicReference" class="headerlink" title="1、实例化AtomicReference"></a>1、实例化AtomicReference</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取value对象在AtomicReference对象中的地址偏移</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public AtomicReference() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、AtomicReference的getAndSet方法"><a href="#2、AtomicReference的getAndSet方法" class="headerlink" title="2、AtomicReference的getAndSet方法"></a>2、AtomicReference的getAndSet方法</h4><p>以getAndSet为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public final V getAndSet(V newValue) &#123;</span><br><span class="line">    return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、Unsafe的getAndSetObject方法"><a href="#3、Unsafe的getAndSetObject方法" class="headerlink" title="3、Unsafe的getAndSetObject方法"></a>3、Unsafe的getAndSetObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final Object getAndSetObject(Object arg0, long arg1, Object arg3) &#123;</span><br><span class="line">    Object arg4;</span><br><span class="line">    do &#123;</span><br><span class="line">        //获取arg0对象arg1位置的对象</span><br><span class="line">        arg4 = this.getObjectVolatile(arg0, arg1);</span><br><span class="line">    &#125; while (!this.compareAndSwapObject(arg0, arg1, arg4, arg3));</span><br><span class="line">    return arg4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、AtomicLongFieldUpdater源码"><a href="#三、AtomicLongFieldUpdater源码" class="headerlink" title="三、AtomicLongFieldUpdater源码"></a>三、AtomicLongFieldUpdater源码</h3><h4 id="1、实例化AtomicLongFieldUpdater"><a href="#1、实例化AtomicLongFieldUpdater" class="headerlink" title="1、实例化AtomicLongFieldUpdater"></a>1、实例化AtomicLongFieldUpdater</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass,</span><br><span class="line">                                                       String fieldName) &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    if (AtomicLong.VM_SUPPORTS_LONG_CAS)</span><br><span class="line">        //JVM支持long类型的CAS函数</span><br><span class="line">        return new CASUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">    else</span><br><span class="line">        //JVM不支持long类型的CAS函数</span><br><span class="line">        return new LockedUpdater&lt;U&gt;(tclass, fieldName, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CASUpdater(final Class&lt;T&gt; tclass, final String fieldName,</span><br><span class="line">               final Class&lt;?&gt; caller) &#123;</span><br><span class="line">    final Field field;</span><br><span class="line">    final int modifiers;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取tclass的fieldName字段</span><br><span class="line">        field = AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                    return tclass.getDeclaredField(fieldName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        //该字段的修饰</span><br><span class="line">        modifiers = field.getModifiers();</span><br><span class="line">        sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">            caller, tclass, null, modifiers);</span><br><span class="line">        ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">        ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">        if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">            ((cl == null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">        throw new RuntimeException(pae.getException());</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                   tclass.isAssignableFrom(caller) &amp;&amp;</span><br><span class="line">                   !isSamePackage(tclass, caller))</span><br><span class="line">                  ? caller : tclass;</span><br><span class="line">    this.tclass = tclass;</span><br><span class="line">    //获取字段的地址偏移</span><br><span class="line">    this.offset = U.objectFieldOffset(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LockedUpdater(final Class&lt;T&gt; tclass, final String fieldName,</span><br><span class="line">                      final Class&lt;?&gt; caller) &#123;</span><br><span class="line">            Field field = null;</span><br><span class="line">            int modifiers = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                            return tclass.getDeclaredField(fieldName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, null, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw new RuntimeException(pae.getException());</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           tclass.isAssignableFrom(caller) &amp;&amp;</span><br><span class="line">                           !isSamePackage(tclass, caller))</span><br><span class="line">                          ? caller : tclass;</span><br><span class="line">            this.tclass = tclass;</span><br><span class="line">            this.offset = U.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2、CASUpdater的compareAndSet方法"><a href="#2、CASUpdater的compareAndSet方法" class="headerlink" title="2、CASUpdater的compareAndSet方法"></a>2、CASUpdater的compareAndSet方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(T obj, long expect, long update) &#123;</span><br><span class="line">    //检查该对象是不是tclass的实例</span><br><span class="line">    accessCheck(obj);</span><br><span class="line">    //将obj对象的offset地址的expect值替换为update，成功返回true，失败返回fasle</span><br><span class="line">    return U.compareAndSwapLong(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LockedUpdater的compareAndSet方法"><a href="#2、LockedUpdater的compareAndSet方法" class="headerlink" title="2、LockedUpdater的compareAndSet方法"></a>2、LockedUpdater的compareAndSet方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public final boolean compareAndSet(T obj, long expect, long update) &#123;</span><br><span class="line">    accessCheck(obj);</span><br><span class="line">    //获取LockedUpdater的对象锁</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //获取obj的offset地址的值</span><br><span class="line">        long v = U.getLong(obj, offset);</span><br><span class="line">        //验证获取的值是否等于expect</span><br><span class="line">        if (v != expect)</span><br><span class="line">            return false;</span><br><span class="line">        //设置obj的offset地址的为update</span><br><span class="line">        U.putLong(obj, offset, update);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java.util.concurrent </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mybatis源码配置文件加载过程</title>
      <link href="/2018/04/20/mybatis3%E6%BA%90%E7%A0%81/mybatis%E6%BA%90%E7%A0%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h2 id="mybatis源码配置文件加载过程"><a href="#mybatis源码配置文件加载过程" class="headerlink" title="mybatis源码配置文件加载过程"></a>mybatis源码配置文件加载过程</h2><h3 id="mybatis-Demo"><a href="#mybatis-Demo" class="headerlink" title="mybatis Demo"></a>mybatis Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //io加载配置文件</span><br><span class="line">       InputStream in=Main.class.getResourceAsStream(&quot;resource/mybatis-cfg.xml&quot;);</span><br><span class="line">       //根据inputstream构建session工厂</span><br><span class="line">       SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">       //创建session</span><br><span class="line">       SqlSession session=factory.openSession();</span><br><span class="line">       //取得mapper对象 调用mapper方法</span><br><span class="line">       DemoMapper mapper=session.getMapper(DemoMapper.class);</span><br><span class="line">       Demo demo=new Demo();</span><br><span class="line">       demo.setId(20);</span><br><span class="line">       demo.setName(&quot;demo&quot;);</span><br><span class="line">       mapper.insertStudent(demo);</span><br><span class="line">       demo=mapper.selectOneById(2);</span><br><span class="line">       List&lt;Demo&gt; demoList=mapper.selectAllDemo();</span><br><span class="line">       //提交，insert需要提交</span><br><span class="line">       session.commit();</span><br><span class="line">       //关闭资源</span><br><span class="line">       session.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="一、属性和别名加载过程"><a href="#一、属性和别名加载过程" class="headerlink" title="一、属性和别名加载过程"></a>一、属性和别名加载过程</h3><h4 id="1、SqlSessionFactoryBuilder的build方法"><a href="#1、SqlSessionFactoryBuilder的build方法" class="headerlink" title="1、SqlSessionFactoryBuilder的build方法"></a>1、SqlSessionFactoryBuilder的build方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        //XMLConfigBuilder.parse(),解析配置文件，返回了一个Configuration对象 </span><br><span class="line">        return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // Intentionally ignore. Prefer previous error.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、XMLConfigBuilder的parse方法"><a href="#2、XMLConfigBuilder的parse方法" class="headerlink" title="2、XMLConfigBuilder的parse方法"></a>2、XMLConfigBuilder的parse方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public Configuration parse() &#123;</span><br><span class="line">     if (parsed) &#123;</span><br><span class="line">         throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     parsed = true;</span><br><span class="line">     //解析配置文件configuration节点，加载到Configuration对象中</span><br><span class="line">     parseConfiguration(parser.evalNode(&quot;/configuration&quot;));</span><br><span class="line">     return configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、XMLConfigBuilder的parseConfiguration方法"><a href="#3、XMLConfigBuilder的parseConfiguration方法" class="headerlink" title="3、XMLConfigBuilder的parseConfiguration方法"></a>3、XMLConfigBuilder的parseConfiguration方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //加载properties节点,一般是定义一些变量</span><br><span class="line">        propertiesElement(root.evalNode(&quot;properties&quot;)); </span><br><span class="line">        //加载别名</span><br><span class="line">        typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">        //拦截器</span><br><span class="line">        pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line">        objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">        objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">        settingsElement(root.evalNode(&quot;settings&quot;));</span><br><span class="line">        //环境</span><br><span class="line">        environmentsElement(root.evalNode(&quot;environments&quot;)); </span><br><span class="line">        databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">        typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">        //加载Mapper的配置文件，最主要的有两个：一个是sql的定义，一个是resultMap</span><br><span class="line">        mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、XMLConfigBuilder的propertiesElement方法"><a href="#4、XMLConfigBuilder的propertiesElement方法" class="headerlink" title="4、XMLConfigBuilder的propertiesElement方法"></a>4、XMLConfigBuilder的propertiesElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void propertiesElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        //先加载property子节点下的属性</span><br><span class="line">        Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">        String resource = context.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">        String url = context.getStringAttribute(&quot;url&quot;)</span><br><span class="line">        //不能同时设置resource属性和url属性</span><br><span class="line">        if (resource != null &amp;&amp; url != null) &#123;</span><br><span class="line">            throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resource != null) &#123;</span><br><span class="line">            //会覆盖子节点的配置</span><br><span class="line">            defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">        &#125; else if (url != null) &#123;</span><br><span class="line">            //会覆盖子节点的配置</span><br><span class="line">            defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">        &#125;</span><br><span class="line">        Properties vars = configuration.getVariables();</span><br><span class="line">        if (vars != null) &#123;</span><br><span class="line">            defaults.putAll(vars);</span><br><span class="line">        &#125;</span><br><span class="line">        parser.setVariables(defaults);</span><br><span class="line">        //加载到configuration中</span><br><span class="line">        configuration.setVariables(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>properties配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource=&quot;resource/config.properties&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;dev&quot;/&gt;  </span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;12345&quot;/&gt;  </span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p><h4 id="5、接（一、3）XMLConfigBuilder的typeAliasesElement方法"><a href="#5、接（一、3）XMLConfigBuilder的typeAliasesElement方法" class="headerlink" title="5、接（一、3）XMLConfigBuilder的typeAliasesElement方法"></a>5、接（一、3）XMLConfigBuilder的typeAliasesElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void typeAliasesElement(XNode parent) &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                //package的方式，将包下所有类的注解别名(若无则用类名作为别名)，注册到TypeAliasRegistry的TYPE_ALIASES中</span><br><span class="line">                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //获取别名</span><br><span class="line">                String alias = child.getStringAttribute(&quot;alias&quot;);</span><br><span class="line">                //获取类全名</span><br><span class="line">                String type = child.getStringAttribute(&quot;type&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //获取类</span><br><span class="line">                    Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">                    if (alias == null) &#123;</span><br><span class="line">                        //以类名作为别名注册</span><br><span class="line">                        typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //注册别名</span><br><span class="line">                        typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    throw new BuilderException(&quot;Error registering typeAlias for &apos;&quot; + alias + &quot;&apos;. Cause: &quot; + e, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeAliases配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;!-- 单个别名定义 --&gt;</span><br><span class="line">    &lt;typeAlias alias=&quot;demo&quot; type=&quot;com.mhr.dto.Demo&quot;/&gt;</span><br><span class="line">    &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">    &lt;package name=&quot;com.mhr.dto&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></p><h4 id="6、实例化TypeAliasRegistry"><a href="#6、实例化TypeAliasRegistry" class="headerlink" title="6、实例化TypeAliasRegistry"></a>6、实例化TypeAliasRegistry</h4><p>//默认别名配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public TypeAliasRegistry() &#123;</span><br><span class="line">    registerAlias(&quot;string&quot;, String.class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;byte&quot;, Byte.class);</span><br><span class="line">    registerAlias(&quot;long&quot;, Long.class);</span><br><span class="line">    registerAlias(&quot;short&quot;, Short.class);</span><br><span class="line">    registerAlias(&quot;int&quot;, Integer.class);</span><br><span class="line">    registerAlias(&quot;integer&quot;, Integer.class);</span><br><span class="line">    registerAlias(&quot;double&quot;, Double.class);</span><br><span class="line">    registerAlias(&quot;float&quot;, Float.class);</span><br><span class="line">    registerAlias(&quot;boolean&quot;, Boolean.class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;byte[]&quot;, Byte[].class);</span><br><span class="line">    registerAlias(&quot;long[]&quot;, Long[].class);</span><br><span class="line">    registerAlias(&quot;short[]&quot;, Short[].class);</span><br><span class="line">    registerAlias(&quot;int[]&quot;, Integer[].class);</span><br><span class="line">    registerAlias(&quot;integer[]&quot;, Integer[].class);</span><br><span class="line">    registerAlias(&quot;double[]&quot;, Double[].class);</span><br><span class="line">    registerAlias(&quot;float[]&quot;, Float[].class);</span><br><span class="line">    registerAlias(&quot;boolean[]&quot;, Boolean[].class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;_byte&quot;, byte.class);</span><br><span class="line">    registerAlias(&quot;_long&quot;, long.class);</span><br><span class="line">    registerAlias(&quot;_short&quot;, short.class);</span><br><span class="line">    registerAlias(&quot;_int&quot;, int.class);</span><br><span class="line">    registerAlias(&quot;_integer&quot;, int.class);</span><br><span class="line">    registerAlias(&quot;_double&quot;, double.class);</span><br><span class="line">    registerAlias(&quot;_float&quot;, float.class);</span><br><span class="line">    registerAlias(&quot;_boolean&quot;, boolean.class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;_byte[]&quot;, byte[].class);</span><br><span class="line">    registerAlias(&quot;_long[]&quot;, long[].class);</span><br><span class="line">    registerAlias(&quot;_short[]&quot;, short[].class);</span><br><span class="line">    registerAlias(&quot;_int[]&quot;, int[].class);</span><br><span class="line">    registerAlias(&quot;_integer[]&quot;, int[].class);</span><br><span class="line">    registerAlias(&quot;_double[]&quot;, double[].class);</span><br><span class="line">    registerAlias(&quot;_float[]&quot;, float[].class);</span><br><span class="line">    registerAlias(&quot;_boolean[]&quot;, boolean[].class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;date&quot;, Date.class);</span><br><span class="line">    registerAlias(&quot;decimal&quot;, BigDecimal.class);</span><br><span class="line">    registerAlias(&quot;bigdecimal&quot;, BigDecimal.class);</span><br><span class="line">    registerAlias(&quot;biginteger&quot;, BigInteger.class);</span><br><span class="line">    registerAlias(&quot;object&quot;, Object.class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;date[]&quot;, Date[].class);</span><br><span class="line">    registerAlias(&quot;decimal[]&quot;, BigDecimal[].class);</span><br><span class="line">    registerAlias(&quot;bigdecimal[]&quot;, BigDecimal[].class);</span><br><span class="line">    registerAlias(&quot;biginteger[]&quot;, BigInteger[].class);</span><br><span class="line">    registerAlias(&quot;object[]&quot;, Object[].class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;map&quot;, Map.class);</span><br><span class="line">    registerAlias(&quot;hashmap&quot;, HashMap.class);</span><br><span class="line">    registerAlias(&quot;list&quot;, List.class);</span><br><span class="line">    registerAlias(&quot;arraylist&quot;, ArrayList.class);</span><br><span class="line">    registerAlias(&quot;collection&quot;, Collection.class);</span><br><span class="line">    registerAlias(&quot;iterator&quot;, Iterator.class);</span><br><span class="line"></span><br><span class="line">    registerAlias(&quot;ResultSet&quot;, ResultSet.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、接（一、3）XMLConfigBuilder的environmentsElement方法"><a href="#7、接（一、3）XMLConfigBuilder的environmentsElement方法" class="headerlink" title="7、接（一、3）XMLConfigBuilder的environmentsElement方法"></a>7、接（一、3）XMLConfigBuilder的environmentsElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        if (environment == null) &#123;</span><br><span class="line">            //获取默认环境</span><br><span class="line">            environment = context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (XNode child : context.getChildren()) &#123;</span><br><span class="line">            String id = child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">            //判断id是否等于默认</span><br><span class="line">            if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">                //创建事务工厂，JdbcTransactionFactory</span><br><span class="line">                TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                //创建数据源工厂，PooledDataSourceFactory</span><br><span class="line">                DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                //获取数据源,PooledDataSource</span><br><span class="line">                DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">                Environment.Builder environmentBuilder = new Environment.Builder(id)</span><br><span class="line">                      .transactionFactory(txFactory)</span><br><span class="line">                      .dataSource(dataSource);</span><br><span class="line">                //将环境加载到configuration中</span><br><span class="line">                configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>environment配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;  </span><br><span class="line">     &lt;environment id=&quot;development&quot;&gt;  </span><br><span class="line">         &lt;transactionManager type=&quot;JDBC&quot; /&gt;  </span><br><span class="line">         &lt;!-- 配置数据库连接信息 --&gt;  </span><br><span class="line">         &lt;dataSource type=&quot;POOLED&quot;&gt;  </span><br><span class="line">             &lt;!-- value属性值引用db.properties配置文件中配置的值 --&gt;  </span><br><span class="line">             &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;  </span><br><span class="line">             &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;  </span><br><span class="line">             &lt;property name=&quot;username&quot; value=&quot;$&#123;name&#125;&quot; /&gt;  </span><br><span class="line">             &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;  </span><br><span class="line">         &lt;/dataSource&gt;  </span><br><span class="line">     &lt;/environment&gt;  </span><br><span class="line"> &lt;/environments&gt;</span><br></pre></td></tr></table></figure></p><h3 id="二、mapper文件加载过程"><a href="#二、mapper文件加载过程" class="headerlink" title="二、mapper文件加载过程"></a>二、mapper文件加载过程</h3><h4 id="1、接（一、3）XMLConfigBuilder的mapperElement方法"><a href="#1、接（一、3）XMLConfigBuilder的mapperElement方法" class="headerlink" title="1、接（一、3）XMLConfigBuilder的mapperElement方法"></a>1、接（一、3）XMLConfigBuilder的mapperElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void mapperElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                String mapperPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String resource = child.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">                String url = child.getStringAttribute(&quot;url&quot;);</span><br><span class="line">                String mapperClass = child.getStringAttribute(&quot;class&quot;);</span><br><span class="line">                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    //由XMLMapperBuilder对象解析加载 </span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    //由XMLMapperBuilder对象解析加载</span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mappers配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;       </span><br><span class="line">    //class 级别的指定,非注解模式的话xml配置文件必须和这个类在同一级目录，且与Mapper类同名  </span><br><span class="line">    &lt;mapper class=&quot;com.mhr.mapper.DemoMapper&quot;/&gt;  </span><br><span class="line">    //非注解模式的话xml配置文件必须也处于同一级 package 下，且与Mapper类同名</span><br><span class="line">    &lt;package name=&quot;com.mhr.mapper&quot;/&gt; </span><br><span class="line">    //使用这个方案，可以单独指定Mapper的位置 </span><br><span class="line">    &lt;mapper resource=&quot;mybatis/mappings/DemoMapper.xml&quot;/&gt;  </span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、XMLMapperBuilder的parse方法"><a href="#2、XMLMapperBuilder的parse方法" class="headerlink" title="2、XMLMapperBuilder的parse方法"></a>2、XMLMapperBuilder的parse方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  public void parse() &#123;</span><br><span class="line">      if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">          //真正解析</span><br><span class="line">          configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line"></span><br><span class="line">          configuration.addLoadedResource(resource);</span><br><span class="line">          bindMapperForNamespace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      parsePendingResultMaps();</span><br><span class="line">      parsePendingChacheRefs();</span><br><span class="line">      parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、XMLMapperBuilder的configurationElement方法"><a href="#3、XMLMapperBuilder的configurationElement方法" class="headerlink" title="3、XMLMapperBuilder的configurationElement方法"></a>3、XMLMapperBuilder的configurationElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //命名空间</span><br><span class="line">        String namespace = context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">        if (namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Mapper&apos;s namespace cannot be empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        //引用其他命名空间中的缓存</span><br><span class="line">        cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">        //为当前的命名空间配置缓存</span><br><span class="line">        cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line">        //解析parameterMap节点，Mybatis3中官方已经不推荐使用parameterMap配置</span><br><span class="line">        parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));</span><br><span class="line">        //解析resultMap</span><br><span class="line">        resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));</span><br><span class="line">        //解析sql片段</span><br><span class="line">        sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));</span><br><span class="line">        //解析sql</span><br><span class="line">        buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、XMLMapperBuilder的configurationElement方法"><a href="#4、XMLMapperBuilder的configurationElement方法" class="headerlink" title="4、XMLMapperBuilder的configurationElement方法"></a>4、XMLMapperBuilder的configurationElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void cacheRefElement(XNode context) &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        //向cacheRefMap中添加命名空间的缓存策略的映射</span><br><span class="line">        configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            //将引用命名空间的缓存策略，设置到当前命名空间</span><br><span class="line">            cacheRefResolver.resolveCacheRef();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache-ref配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace=&quot;com.mhr.mapper.DemoMapper&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="5、接（二、3）XMLMapperBuilder的cacheElement方法"><a href="#5、接（二、3）XMLMapperBuilder的cacheElement方法" class="headerlink" title="5、接（二、3）XMLMapperBuilder的cacheElement方法"></a>5、接（二、3）XMLMapperBuilder的cacheElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void cacheElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        //缓存类型，默认为PERPETUAL,为永久的</span><br><span class="line">        String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">        //回收策略，LRU,最少使用的被回收 </span><br><span class="line">        String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">        //刷新缓存间隔</span><br><span class="line">        Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">        //缓存大小</span><br><span class="line">        Integer size = context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">        boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line">        //构建一个Cache对象，并加入Configuration</span><br><span class="line">        builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache  </span><br><span class="line">    eviction=&quot;FIFO&quot;  </span><br><span class="line">    flushInterval=&quot;60000&quot;  </span><br><span class="line">    size=&quot;512&quot;  </span><br><span class="line">    readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="6、MapperBuilderAssistant的useNewCache方法"><a href="#6、MapperBuilderAssistant的useNewCache方法" class="headerlink" title="6、MapperBuilderAssistant的useNewCache方法"></a>6、MapperBuilderAssistant的useNewCache方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass,</span><br><span class="line">      Long flushInterval,</span><br><span class="line">      Integer size,</span><br><span class="line">      boolean readWrite,</span><br><span class="line">      Properties props) &#123;</span><br><span class="line">    typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span><br><span class="line">    evictionClass = valueOrDefault(evictionClass, LruCache.class);</span><br><span class="line">    //交由Builder处理,命名空间作为cache的id</span><br><span class="line">    Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(typeClass)</span><br><span class="line">        .addDecorator(evictionClass)</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line">    //将cache加入configuration中</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    //设置当前命名空间的缓存，在之后的解析select/update/insert/delete节点设置缓存里使用currentCache</span><br><span class="line">    currentCache = cache;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、CacheBuilder的build方法"><a href="#7、CacheBuilder的build方法" class="headerlink" title="7、CacheBuilder的build方法"></a>7、CacheBuilder的build方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  public Cache build() &#123;</span><br><span class="line">      setDefaultImplementations();</span><br><span class="line">      //生成基本的Cache实现,默认PerpetualCache</span><br><span class="line">      Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">      // issue #352, do not apply decorators to custom caches</span><br><span class="line">      if (cache.getClass().getName().startsWith(&quot;org.apache.ibatis&quot;)) &#123;</span><br><span class="line">          //LruCache封装cache</span><br><span class="line">          for (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">              cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">              setCacheProperties(cache);</span><br><span class="line">          &#125;</span><br><span class="line">          //为cache加上一些指定的额外的服务，如、日志及线程安全</span><br><span class="line">          cache = setStandardDecorators(cache);</span><br><span class="line">      &#125;</span><br><span class="line">  return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、CacheBuilder的setStandardDecorators方法"><a href="#8、CacheBuilder的setStandardDecorators方法" class="headerlink" title="8、CacheBuilder的setStandardDecorators方法"></a>8、CacheBuilder的setStandardDecorators方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Cache setStandardDecorators(Cache cache) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        if (size != null &amp;&amp; metaCache.hasSetter(&quot;size&quot;)) &#123;</span><br><span class="line">            metaCache.setValue(&quot;size&quot;, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (clearInterval != null) &#123;</span><br><span class="line">            //ScheduledCache封装cache</span><br><span class="line">            cache = new ScheduledCache(cache);</span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        if (readWrite) &#123;</span><br><span class="line">            //SerializedCache封装cache</span><br><span class="line">            cache = new SerializedCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        //LoggingCache封装cache</span><br><span class="line">        cache = new LoggingCache(cache);</span><br><span class="line">        //SynchronizedCache封装cache</span><br><span class="line">        cache = new SynchronizedCache(cache);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new CacheException(&quot;Error building standard cache decorators.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、接（二、3）XMLMapperBuilder的resultMapElements方法"><a href="#9、接（二、3）XMLMapperBuilder的resultMapElements方法" class="headerlink" title="9、接（二、3）XMLMapperBuilder的resultMapElements方法"></a>9、接（二、3）XMLMapperBuilder的resultMapElements方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void resultMapElements(List&lt;XNode&gt; list) throws Exception &#123;</span><br><span class="line">    for (XNode resultMapNode : list) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //依次解析mapper节点</span><br><span class="line">            resultMapElement(resultMapNode);</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            // ignore, it will be retried</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、XMLMapperBuilder的resultMapElement方法"><a href="#10、XMLMapperBuilder的resultMapElement方法" class="headerlink" title="10、XMLMapperBuilder的resultMapElement方法"></a>10、XMLMapperBuilder的resultMapElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    //id,对应ResultMap.id,内映射没有ID,用resultMapNode.getValueBasedIdentifier()方法生成一个</span><br><span class="line">    String id = resultMapNode.getStringAttribute(&quot;id&quot;,</span><br><span class="line">        resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    //type,对应ResultMap.Type,这里可以看到这个type可以通过很多个属性进行配置</span><br><span class="line">    String type = resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">    String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    //是否自动映射 </span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line">    //将type解析成class,可以是别名，也可以是全限定名</span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    Discriminator discriminator = null;</span><br><span class="line">    //这个resultMappings将对应ResultMap.resultMappings</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    //解析子节点</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">        if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            //解析constructor节点</span><br><span class="line">            processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            //解析disriminator节点</span><br><span class="line">            discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ArrayList&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">            if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            //解析其他节点,主要有result、association及collection  </span><br><span class="line">            //在这里可以说明一个result、association及collection都会被解析成一个resultMapping对象，即使他们有很多子元素  </span><br><span class="line">            resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, </span><br><span class="line">        autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">        //得到resultMappings后，生成ResultMap并加入到Configuration中</span><br><span class="line">        return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException  e) &#123;</span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resultMap配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;Employee&quot; type=&quot;Demo&quot;&gt;  </span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;  </span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></p><h4 id="11、XMLMapperBuilder的processConstructorElement方法"><a href="#11、XMLMapperBuilder的processConstructorElement方法" class="headerlink" title="11、XMLMapperBuilder的processConstructorElement方法"></a>11、XMLMapperBuilder的processConstructorElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void processConstructorElement(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">    //遍历子节点 </span><br><span class="line">    for (XNode argChild : argChildren) &#123;</span><br><span class="line">        ArrayList&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">        //标识为ResultFlag.CONSTRUCTOR </span><br><span class="line">        flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">        if (&quot;idArg&quot;.equals(argChild.getName())) &#123;</span><br><span class="line">            //标识为一个ID属性 </span><br><span class="line">            flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个ResultMapping对象，并加入resultMappings  </span><br><span class="line">        //这里说明了，constructor下有多个几子节点，就会产生多少个resultMapping对象</span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、XMLMapperBuilder的buildResultMappingFromContext方法"><a href="#12、XMLMapperBuilder的buildResultMappingFromContext方法" class="headerlink" title="12、XMLMapperBuilder的buildResultMappingFromContext方法"></a>12、XMLMapperBuilder的buildResultMappingFromContext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, ArrayList&lt;ResultFlag&gt; flags) throws Exception &#123;</span><br><span class="line">    String property = context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    String column = context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType = context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    //这里需要特殊说明，一个resultMapping可以对应一个resultMap对应，我们称之为内部映射 </span><br><span class="line">    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;,</span><br><span class="line">        processNestedResultMappings(context, Collections.&lt;ResultMapping&gt; emptyList()));</span><br><span class="line">    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resulSet = context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">    //这里的ResultMapping生成的方法跟ResultMap生成的过程大同小异</span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap,    </span><br><span class="line">        notNullColumn, columnPrefix, typeHandlerClass, flags, resulSet, foreignColumn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、XMLMapperBuilder的processNestedResultMappings方法"><a href="#13、XMLMapperBuilder的processNestedResultMappings方法" class="headerlink" title="13、XMLMapperBuilder的processNestedResultMappings方法"></a>13、XMLMapperBuilder的processNestedResultMappings方法</h4><p>生成一个内部的ReulstMapp对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private String processNestedResultMappings(XNode context, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    //只有association, collection, case节点才会生成内部映射，其他不生成，返回null</span><br><span class="line">    if (&quot;association&quot;.equals(context.getName())</span><br><span class="line">          || &quot;collection&quot;.equals(context.getName())</span><br><span class="line">          || &quot;case&quot;.equals(context.getName())) &#123;</span><br><span class="line">        if (context.getStringAttribute(&quot;select&quot;) == null) &#123;</span><br><span class="line">            //这里类似一个递归调用，需要注意内部映射的ID是Mybatis自动生成的，不是在配置文件里读取的</span><br><span class="line">            ResultMap resultMap = resultMapElement(context, resultMappings);</span><br><span class="line">            return resultMap.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="14、接（二、10）ResultMapResolver的resolve方法"><a href="#14、接（二、10）ResultMapResolver的resolve方法" class="headerlink" title="14、接（二、10）ResultMapResolver的resolve方法"></a>14、接（二、10）ResultMapResolver的resolve方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ResultMap resolve() &#123;</span><br><span class="line">    return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、MapperBuilderAssistant的addResultMap方法"><a href="#15、MapperBuilderAssistant的addResultMap方法" class="headerlink" title="15、MapperBuilderAssistant的addResultMap方法"></a>15、MapperBuilderAssistant的addResultMap方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> public ResultMap addResultMap(</span><br><span class="line">       String id,</span><br><span class="line">       Class&lt;?&gt; type,</span><br><span class="line">       String extend,</span><br><span class="line">       Discriminator discriminator,</span><br><span class="line">       List&lt;ResultMapping&gt; resultMappings,</span><br><span class="line">       Boolean autoMapping) &#123;</span><br><span class="line">//没有命名空间，则添加当前命名空间，false时检查命名空间是否是当前命名空间</span><br><span class="line">         id = applyCurrentNamespace(id, false);</span><br><span class="line">//没有命名空间，则添加当前命名空间</span><br><span class="line">         extend = applyCurrentNamespace(extend, true);</span><br><span class="line">         //交由ResultMap.Builder来创建ResultMap对象，ResultMap.Builder.build()方法前面已经介绍过</span><br><span class="line">         ResultMap.Builder resultMapBuilder = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping);</span><br><span class="line">     if (extend != null) &#123;</span><br><span class="line">         //对继承了其他resultMap的处理</span><br><span class="line">         if (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">             throw new IncompleteElementException(&quot;Could not find a parent resultmap with id &apos;&quot; + extend + &quot;&apos;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">         List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span><br><span class="line">         extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">         // Remove parent constructor if this resultMap declares a constructor.</span><br><span class="line">         boolean declaresConstructor = false;</span><br><span class="line">         for (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">             if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                 declaresConstructor = true;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         if (declaresConstructor) &#123;</span><br><span class="line">             Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">             while (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">                 if (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                     extendedResultMappingsIter.remove();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         resultMappings.addAll(extendedResultMappings);</span><br><span class="line">     &#125;</span><br><span class="line">     resultMapBuilder.discriminator(discriminator);</span><br><span class="line">     //生成ResultMap对象</span><br><span class="line">     ResultMap resultMap = resultMapBuilder.build();</span><br><span class="line">     //另到Configuration中</span><br><span class="line">     configuration.addResultMap(resultMap);</span><br><span class="line">     return resultMap;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="16、接（二、3）XMLMapperBuilder的sqlElement方法"><a href="#16、接（二、3）XMLMapperBuilder的sqlElement方法" class="headerlink" title="16、接（二、3）XMLMapperBuilder的sqlElement方法"></a>16、接（二、3）XMLMapperBuilder的sqlElement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) throws Exception &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">        //没有命名空间，则添加命名空间，false时检查命名空间是否是当前命名空间</span><br><span class="line">        id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) </span><br><span class="line">            //sql片段加入sqlFragments</span><br><span class="line">            sqlFragments.put(id, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sql配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;sql_select&quot;&gt; </span><br><span class="line">    SELECT * FROM BLOG </span><br><span class="line">    WHERE 1=1 </span><br><span class="line">    &lt;if test=&quot;id!= null and title!=null&quot;&gt;</span><br><span class="line">        AND id=#&#123;id&#125; and title=#&#123;title&#125;</span><br><span class="line">    &lt;/if&gt; </span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure></p><h3 id="三、sql加载过程"><a href="#三、sql加载过程" class="headerlink" title="三、sql加载过程"></a>三、sql加载过程</h3><h4 id="1、接（二、3）XMLMapperBuilder的buildStatementFromContext方法"><a href="#1、接（二、3）XMLMapperBuilder的buildStatementFromContext方法" class="headerlink" title="1、接（二、3）XMLMapperBuilder的buildStatementFromContext方法"></a>1、接（二、3）XMLMapperBuilder的buildStatementFromContext方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        //一个select/update/insert/delete元素创建一个XMLStatementBuilder对象 </span><br><span class="line">        final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, </span><br><span class="line">              requiredDatabaseId);</span><br><span class="line">        try &#123;</span><br><span class="line">            //将元素解析成MappedStatemenet对象，并加入到Configuration中去</span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、XMLStatementBuilder的parseStatementNode方法"><a href="#2、XMLStatementBuilder的parseStatementNode方法" class="headerlink" title="2、XMLStatementBuilder的parseStatementNode方法"></a>2、XMLStatementBuilder的parseStatementNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void parseStatementNode() &#123;</span><br><span class="line">    String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line"></span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) return;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout = context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">    //参数类</span><br><span class="line">    String parameterType = context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    //返回结果映射</span><br><span class="line">    String resultMap = context.getStringAttribute(&quot;resultMap&quot;);</span><br><span class="line">    //返回结果类</span><br><span class="line">    String resultType = context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    String lang = context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    //Statement的类型，对应jdbc里的三个类型:Statement、PreparedStatement、CallableStatement，默认使用PreparedStatement</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    //这个也是跟jdbc里相对应的，一般采用默认即可</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    //Sql的类型，select/update/insert/delete</span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    //是否刷新缓存</span><br><span class="line">    boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">    //是否使用缓存</span><br><span class="line">    boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">    boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    // Include Fragments before parsing</span><br><span class="line">    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    //包含sql片段，把sql片段替换进来</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    //selectKey生成id</span><br><span class="line">    //Parse selectKey after includes,in case if IncompleteElementException (issue #291)</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line"></span><br><span class="line">    //XMLLanguageDriver创建sqlSource</span><br><span class="line">    // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line">    String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    //自动生成key</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    //没有命名空间，则添加当前命名空间</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        //获取刚刚创建的id生成器</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //没有selectKey，配置了useGeneratedKeys且为insert，则用Jdbc3KeyGenerator生成器</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">              configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">              ? new Jdbc3KeyGenerator() : new NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    //生成MappedStatement对象，并加到Configuration中  </span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">          fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">          resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">          keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、XMLIncludeTransformer的applyIncludes方法"><a href="#3、XMLIncludeTransformer的applyIncludes方法" class="headerlink" title="3、XMLIncludeTransformer的applyIncludes方法"></a>3、XMLIncludeTransformer的applyIncludes方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void applyIncludes(Node source) &#123;</span><br><span class="line">    //source为sql片段</span><br><span class="line">    if (source.getNodeName().equals(&quot;include&quot;)) &#123;</span><br><span class="line">        //由refid获取sql片段</span><br><span class="line">        Node toInclude = findSqlFragment(getStringAttribute(source, &quot;refid&quot;));</span><br><span class="line">        //若sql片段中包含sql片段，继续解析</span><br><span class="line">        applyIncludes(toInclude);</span><br><span class="line">        if (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">            toInclude = source.getOwnerDocument().importNode(toInclude, true);</span><br><span class="line">        &#125;</span><br><span class="line">        //用获取的sql片段替换本节点</span><br><span class="line">        source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">        while (toInclude.hasChildNodes()) &#123;</span><br><span class="line">            toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">        &#125;</span><br><span class="line">        toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">    &#125; else if (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">        //source为节点列表</span><br><span class="line">        NodeList children = source.getChildNodes();</span><br><span class="line">        for (int i=0; i&lt;children.getLength(); i++) &#123;</span><br><span class="line">            applyIncludes(children.item(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、XMLIncludeTransformer的findSqlFragment方法"><a href="#4、XMLIncludeTransformer的findSqlFragment方法" class="headerlink" title="4、XMLIncludeTransformer的findSqlFragment方法"></a>4、XMLIncludeTransformer的findSqlFragment方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   private Node findSqlFragment(String refid) &#123;</span><br><span class="line">refid = PropertyParser.parse(refid, configuration.getVariables());</span><br><span class="line">//没有命名空间，则添加当前命名空间</span><br><span class="line">refid = builderAssistant.applyCurrentNamespace(refid, true);</span><br><span class="line">try &#123;</span><br><span class="line">  //获取sql片段，必须是在同一个命名空间下</span><br><span class="line">  XNode nodeToInclude = configuration.getSqlFragments().get(refid);</span><br><span class="line">  Node result = nodeToInclude.getNode().cloneNode(true);</span><br><span class="line">  return result;</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">  throw new IncompleteElementException(&quot;Could not find SQL statement to include with refid &apos;&quot; + refid + &quot;&apos;&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（三、2）XMLStatementBuilder的parseSelectKeyNodes方法"><a href="#5、接（三、2）XMLStatementBuilder的parseSelectKeyNodes方法" class="headerlink" title="5、接（三、2）XMLStatementBuilder的parseSelectKeyNodes方法"></a>5、接（三、2）XMLStatementBuilder的parseSelectKeyNodes方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void parseSelectKeyNodes(String parentId, List&lt;XNode&gt; list, Class&lt;?&gt; parameterTypeClass, LanguageDriver </span><br><span class="line">      langDriver, String skRequiredDatabaseId) &#123;</span><br><span class="line">    for (XNode nodeToHandle : list) &#123;</span><br><span class="line">        String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">        String databaseId = nodeToHandle.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, skRequiredDatabaseId)) &#123;</span><br><span class="line">            parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>selectKey配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insert&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;_databaseId == &apos;oracle&apos;&quot;&gt;</span><br><span class="line">            select seq_users.nextval from dual</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;_databaseId == &apos;db2&apos;&quot;&gt;</span><br><span class="line">            select nextval for seq_users from sysibm.sysdummy1&quot;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure></p><h4 id="6、XMLStatementBuilder的parseSelectKeyNodes方法"><a href="#6、XMLStatementBuilder的parseSelectKeyNodes方法" class="headerlink" title="6、XMLStatementBuilder的parseSelectKeyNodes方法"></a>6、XMLStatementBuilder的parseSelectKeyNodes方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void parseSelectKeyNode(String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver, </span><br><span class="line">      String databaseId) &#123;</span><br><span class="line">    //返回类型</span><br><span class="line">    String resultType = nodeToHandle.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    //Statement的类型，对应jdbc里的三个类型:Statement、PreparedStatement、CallableStatement，默认使用PreparedStatement </span><br><span class="line">    StatementType statementType = StatementType.valueOf(nodeToHandle.getStringAttribute(&quot;statementType&quot;, </span><br><span class="line">          StatementType.PREPARED.toString()));</span><br><span class="line">    //属性名</span><br><span class="line">    String keyProperty = nodeToHandle.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    boolean executeBefore = &quot;BEFORE&quot;.equals(nodeToHandle.getStringAttribute(&quot;order&quot;, &quot;AFTER&quot;));</span><br><span class="line"></span><br><span class="line">    //defaults</span><br><span class="line">    boolean useCache = false;</span><br><span class="line">    boolean resultOrdered = false;</span><br><span class="line">    //主键生成器</span><br><span class="line">    KeyGenerator keyGenerator = new NoKeyGenerator();</span><br><span class="line">    Integer fetchSize = null;</span><br><span class="line">    Integer timeout = null;</span><br><span class="line">    boolean flushCache = false;</span><br><span class="line">    String parameterMap = null;</span><br><span class="line">    String resultMap = null;</span><br><span class="line">    ResultSetType resultSetTypeEnum = null;</span><br><span class="line">    //XMLLanguageDriver创建sqlSource</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    //生成MappedStatement对象，并加到Configuration中</span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">          fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">          resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">          keyGenerator, keyProperty, null, databaseId, langDriver, null);</span><br><span class="line">    //没有命名空间，则添加当前命名空间，false时检查命名空间是否是当前命名空间</span><br><span class="line">    id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">    //获取刚刚保存得，该selectKey的MappedStatement</span><br><span class="line">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span><br><span class="line">    //创建id生成器，加入configuration中</span><br><span class="line">    configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));</span><br><span class="line">    //处理完，删掉本节点</span><br><span class="line">    nodeToHandle.getParent().getNode().removeChild(nodeToHandle.getNode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、XMLLanguageDriver的createSqlSource方法"><a href="#7、XMLLanguageDriver的createSqlSource方法" class="headerlink" title="7、XMLLanguageDriver的createSqlSource方法"></a>7、XMLLanguageDriver的createSqlSource方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123;</span><br><span class="line">    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script);</span><br><span class="line">    return builder.parseScriptNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、XMLScriptBuilder的parseScriptNode方法"><a href="#8、XMLScriptBuilder的parseScriptNode方法" class="headerlink" title="8、XMLScriptBuilder的parseScriptNode方法"></a>8、XMLScriptBuilder的parseScriptNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  public SqlSource parseScriptNode() &#123;</span><br><span class="line">      //解析sql</span><br><span class="line">      List&lt;SqlNode&gt; contents = parseDynamicTags(context);</span><br><span class="line">      //混合sql节点</span><br><span class="line">      MixedSqlNode rootSqlNode = new MixedSqlNode(contents);</span><br><span class="line">//默认动态sql</span><br><span class="line">      SqlSource sqlSource = new DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">      return sqlSource;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="9、XMLScriptBuilder的parseDynamicTags方法"><a href="#9、XMLScriptBuilder的parseDynamicTags方法" class="headerlink" title="9、XMLScriptBuilder的parseDynamicTags方法"></a>9、XMLScriptBuilder的parseDynamicTags方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SqlNode&gt; parseDynamicTags(XNode node) &#123;</span><br><span class="line">    //一个sql会被解析成多个SqlNode</span><br><span class="line">    List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;();</span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        XNode child = node.newXNode(children.item(i));</span><br><span class="line">        String nodeName = child.getNode().getNodeName();</span><br><span class="line">        if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE</span><br><span class="line">              || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">            //如果这个Node只包含文本  </span><br><span class="line">            String data = child.getStringBody(&quot;&quot;);</span><br><span class="line">            //生成一个TextSqlNode </span><br><span class="line">            contents.add(new TextSqlNode(data));</span><br><span class="line">        &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE &amp;&amp; !&quot;selectKey&quot;.equals(nodeName)) &#123; </span><br><span class="line">            //如果是有xml标签的Node,交由Handler处理，同时被认为是动态的</span><br><span class="line">            NodeHandler handler = nodeHandlers.get(nodeName);</span><br><span class="line">            if (handler == null) &#123;</span><br><span class="line">                throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理该标签</span><br><span class="line">            handler.handleNode(child, contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、If标签处理器"><a href="#10、If标签处理器" class="headerlink" title="10、If标签处理器"></a>10、If标签处理器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    //Mybatis3动态sql都支持那些配置，这里就很清楚啦  </span><br><span class="line">    put(&quot;trim&quot;, new TrimHandler());  </span><br><span class="line">    put(&quot;where&quot;, new WhereHandler());  </span><br><span class="line">    put(&quot;set&quot;, new SetHandler());  </span><br><span class="line">    put(&quot;foreach&quot;, new ForEachHandler());  </span><br><span class="line">    put(&quot;if&quot;, new IfHandler());  </span><br><span class="line">    put(&quot;choose&quot;, new ChooseHandler());  </span><br><span class="line">    put(&quot;when&quot;, new IfHandler());  </span><br><span class="line">    put(&quot;otherwise&quot;, new OtherwiseHandler());  </span><br><span class="line">    put(&quot;bind&quot;, new BindHandler());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private class IfHandler implements NodeHandler &#123;</span><br><span class="line">    public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123;</span><br><span class="line">        //解析if标签下的节点</span><br><span class="line">        List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle);</span><br><span class="line">        //创建组合节点</span><br><span class="line">        MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);</span><br><span class="line">        String test = nodeToHandle.getStringAttribute(&quot;test&quot;);</span><br><span class="line">        //创建if节点</span><br><span class="line">        IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test);</span><br><span class="line">        targetContents.add(ifSqlNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis3的配置文件加载到此就结束了</p>]]></content>
      
      <categories>
          
          <category> mybatis3 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mybatis源码sql执行过程（2）</title>
      <link href="/2018/04/20/mybatis3%E6%BA%90%E7%A0%81/mybatis%E6%BA%90%E7%A0%81sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="mybatis源码sql执行过程（2）"><a href="#mybatis源码sql执行过程（2）" class="headerlink" title="mybatis源码sql执行过程（2）"></a>mybatis源码sql执行过程（2）</h2><h3 id="一、insert执行过程"><a href="#一、insert执行过程" class="headerlink" title="一、insert执行过程"></a>一、insert执行过程</h3><h4 id="1、DefaultSqlSession的insert方法"><a href="#1、DefaultSqlSession的insert方法" class="headerlink" title="1、DefaultSqlSession的insert方法"></a>1、DefaultSqlSession的insert方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int insert(String statement) &#123;</span><br><span class="line">    return insert(statement, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int insert(String statement, Object parameter) &#123;</span><br><span class="line">    return update(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、DefaultSqlSession的update方法"><a href="#2、DefaultSqlSession的update方法" class="headerlink" title="2、DefaultSqlSession的update方法"></a>2、DefaultSqlSession的update方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int update(String statement, Object parameter) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        dirty = true;</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        //执行</span><br><span class="line">        return executor.update(ms, wrapCollection(parameter));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error updating database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、BaseExecutor的update方法"><a href="#3、BaseExecutor的update方法" class="headerlink" title="3、BaseExecutor的update方法"></a>3、BaseExecutor的update方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</span><br><span class="line">    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    //清空一级缓存</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    return doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、SimpleExecutor的doUpdate方法"><a href="#4、SimpleExecutor的doUpdate方法" class="headerlink" title="4、SimpleExecutor的doUpdate方法"></a>4、SimpleExecutor的doUpdate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);</span><br><span class="line">        //预处理</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        //执行sql</span><br><span class="line">        return handler.update(stmt);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、RoutingStatementHandler的update方法"><a href="#5、RoutingStatementHandler的update方法" class="headerlink" title="5、RoutingStatementHandler的update方法"></a>5、RoutingStatementHandler的update方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int update(Statement statement) throws SQLException &#123;</span><br><span class="line">    return delegate.update(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、实例化PreparedStatementHandler"><a href="#6、实例化PreparedStatementHandler" class="headerlink" title="6、实例化PreparedStatementHandler"></a>6、实例化PreparedStatementHandler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PreparedStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler </span><br><span class="line">      resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    super(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, </span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    this.executor = executor;</span><br><span class="line">    this.mappedStatement = mappedStatement;</span><br><span class="line">    this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">        generateKeys(parameterObject);</span><br><span class="line">        boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">    this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、BaseStatementHandler的generateKeys"><a href="#7、BaseStatementHandler的generateKeys" class="headerlink" title="7、BaseStatementHandler的generateKeys"></a>7、BaseStatementHandler的generateKeys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected void generateKeys(Object parameter) &#123;</span><br><span class="line">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">    ErrorContext.instance().store();</span><br><span class="line">    keyGenerator.processBefore(executor, mappedStatement, null, parameter);</span><br><span class="line">    ErrorContext.instance().recall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、SelectKeyGenerator的processBefore"><a href="#8、SelectKeyGenerator的processBefore" class="headerlink" title="8、SelectKeyGenerator的processBefore"></a>8、SelectKeyGenerator的processBefore</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void processBefore(Executor executor, MappedStatement ms, Statement stmt, Object parameter) &#123;</span><br><span class="line">    if (executeBefore) &#123;</span><br><span class="line">        processGeneratedKeys(executor, ms, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、SelectKeyGenerator的processGeneratedKeys"><a href="#9、SelectKeyGenerator的processGeneratedKeys" class="headerlink" title="9、SelectKeyGenerator的processGeneratedKeys"></a>9、SelectKeyGenerator的processGeneratedKeys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void processGeneratedKeys(Executor executor, MappedStatement ms, Object parameter) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (parameter != null &amp;&amp; keyStatement != null &amp;&amp; keyStatement.getKeyProperties() != null) &#123;</span><br><span class="line">            //主键的属性名</span><br><span class="line">            String keyProperty = keyStatement.getKeyProperties()[0]; // just one key property is supported</span><br><span class="line">            final Configuration configuration = ms.getConfiguration();</span><br><span class="line">            final MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">            if (keyProperty != null &amp;&amp; metaParam.hasSetter(keyProperty)) &#123;</span><br><span class="line">                // Do not close keyExecutor.</span><br><span class="line">                // The transaction will be closed by parent executor.</span><br><span class="line">                //获取执行器</span><br><span class="line">                Executor keyExecutor = configuration.newExecutor(executor.getTransaction(), ExecutorType.SIMPLE);</span><br><span class="line">                //执行查询sql，获取主键</span><br><span class="line">                List&lt;Object&gt; values = keyExecutor.query(keyStatement, parameter, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);</span><br><span class="line">                if (values.size() == 0) &#123;</span><br><span class="line">                    throw new ExecutorException(&quot;SelectKey returned no data.&quot;);            </span><br><span class="line">                &#125; else if (values.size() &gt; 1) &#123;</span><br><span class="line">                    throw new ExecutorException(&quot;SelectKey returned more than one value.&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //将获取的主键值设置到参数中</span><br><span class="line">                    metaParam.setValue(keyProperty, values.get(0));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ExecutorException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new ExecutorException(&quot;Error selecting key or setting result to parameter object. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、接（一、6）PreparedStatementHandler的update方法"><a href="#10、接（一、6）PreparedStatementHandler的update方法" class="headerlink" title="10、接（一、6）PreparedStatementHandler的update方法"></a>10、接（一、6）PreparedStatementHandler的update方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int update(Statement statement) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    //执行条数</span><br><span class="line">    int rows = ps.getUpdateCount();</span><br><span class="line">    Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">    //executeBefore为true，processAfter不会执行</span><br><span class="line">    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">    return rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、二级缓存"><a href="#二、二级缓存" class="headerlink" title="二、二级缓存"></a>二、二级缓存</h3><h4 id="1、CachingExecutor的query方法"><a href="#1、CachingExecutor的query方法" class="headerlink" title="1、CachingExecutor的query方法"></a>1、CachingExecutor的query方法</h4><p>配置二级缓存,会用CachingExecutor封装SimpleExecutor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) </span><br><span class="line">      throws   SQLException &#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    //创建缓存key，与一级缓存一样</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, </span><br><span class="line">      BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    //从MappedStatement获取一个Cache，如果对象的命名空间没有配置cache或cache-ref节点,cache将为空，表示不使用缓存，</span><br><span class="line">    //缓存创建过程见配置加载过程（二、8）</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        //如果需要刷新缓存的话就刷新：flushCache=&quot;true&quot;</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        //useCache=&quot;true&quot;</span><br><span class="line">        if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</span><br><span class="line">            //检查是否是带ParameterMode.OUT输出参数的存储过程</span><br><span class="line">            ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">            //如果缓存数据可继续使用</span><br><span class="line">            if (!dirty) &#123;</span><br><span class="line">                //获取读锁</span><br><span class="line">                cache.getReadWriteLock().readLock().lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //从缓存中获取数据</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    List&lt;E&gt; cachedList = (List&lt;E&gt;) cache.getObject(key);</span><br><span class="line">                    //如果存在，返回缓存数据</span><br><span class="line">                    if (cachedList != null) return cachedList;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //释放读锁</span><br><span class="line">                    cache.getReadWriteLock().readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果缓存中没有，执行查询</span><br><span class="line">            List&lt;E&gt; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">            //数据添加进缓存</span><br><span class="line">            tcm.putObject(cache, key, list); // issue #578. Query must be not synchronized to prevent deadlocks</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //没有二级缓存，直接查询</span><br><span class="line">    return delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、CachingExecutor的flushCacheIfRequired方法"><a href="#2、CachingExecutor的flushCacheIfRequired方法" class="headerlink" title="2、CachingExecutor的flushCacheIfRequired方法"></a>2、CachingExecutor的flushCacheIfRequired方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void flushCacheIfRequired(MappedStatement ms) &#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    //执行该sql，缓存需刷新</span><br><span class="line">    if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        //表示缓存数据不可继续使用</span><br><span class="line">        dirty = true; // issue #524. Disable using cached data for this session</span><br><span class="line">        //清空缓存</span><br><span class="line">        tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、TransactionalCacheManager的clear方法"><a href="#3、TransactionalCacheManager的clear方法" class="headerlink" title="3、TransactionalCacheManager的clear方法"></a>3、TransactionalCacheManager的clear方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void clear(Cache cache) &#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、TransactionalCacheManager的getTransactionalCache方法"><a href="#4、TransactionalCacheManager的getTransactionalCache方法" class="headerlink" title="4、TransactionalCacheManager的getTransactionalCache方法"></a>4、TransactionalCacheManager的getTransactionalCache方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">    //由cache做key获取TransactionalCache</span><br><span class="line">    TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    if (txCache == null) &#123;</span><br><span class="line">        //没有则封装一个</span><br><span class="line">        txCache = new TransactionalCache(cache);</span><br><span class="line">        //存入该Map</span><br><span class="line">        transactionalCaches.put(cache, txCache);</span><br><span class="line">    &#125;</span><br><span class="line">    return txCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（二、3）TransactionalCache的clear方法"><a href="#5、接（二、3）TransactionalCache的clear方法" class="headerlink" title="5、接（二、3）TransactionalCache的clear方法"></a>5、接（二、3）TransactionalCache的clear方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    //清空临时数据</span><br><span class="line">    reset();</span><br><span class="line">    //commit时先清空缓存，在执行后续操作</span><br><span class="line">    clearOnCommit = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、TransactionalCache的reset方法"><a href="#6、TransactionalCache的reset方法" class="headerlink" title="6、TransactionalCache的reset方法"></a>6、TransactionalCache的reset方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void reset() &#123;</span><br><span class="line">    clearOnCommit = false;</span><br><span class="line">    //清空临时数据队列</span><br><span class="line">    entriesToRemoveOnCommit.clear();</span><br><span class="line">    entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（二、1）SynchronizedCache的getObject方法"><a href="#7、接（二、1）SynchronizedCache的getObject方法" class="headerlink" title="7、接（二、1）SynchronizedCache的getObject方法"></a>7、接（二、1）SynchronizedCache的getObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    //获取读锁</span><br><span class="line">    acquireReadLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //继续从下级获取</span><br><span class="line">        return delegate.getObject(key);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放读锁</span><br><span class="line">        releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoggingCache的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    //请求次数加一</span><br><span class="line">    requests++;</span><br><span class="line">    //继续从下级获取</span><br><span class="line">    final Object value = delegate.getObject(key);</span><br><span class="line">    if (value != null) &#123;</span><br><span class="line">        //获取成功，命中次数加一</span><br><span class="line">        hits++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;Cache Hit Ratio [&quot; + getId() + &quot;]: &quot; + getHitRatio());</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>SerializedCache的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    //继续从下级获取</span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    //反序列化</span><br><span class="line">    return object == null ? null : deserialize((byte[]) object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledCache的getObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    if (clearWhenStale()) &#123;</span><br><span class="line">        //当上次清空时间与当前时间差，大于最大缓存清空间隔时间</span><br><span class="line">        //清空缓存，返回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //继续从下级获取</span><br><span class="line">        return delegate.getObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LruCache的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  public Object getObject(Object key) &#123;</span><br><span class="line">      //将key对应的Node移至队尾</span><br><span class="line">      keyMap.get(key); //touch</span><br><span class="line">      //继续从下级获取</span><br><span class="line">      return delegate.getObject(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PerpetualCache的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(Object key) &#123;</span><br><span class="line">    //从Map中获取缓存数据</span><br><span class="line">    return cache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、接（二、1）TransactionalCacheManager的putObject方法"><a href="#8、接（二、1）TransactionalCacheManager的putObject方法" class="headerlink" title="8、接（二、1）TransactionalCacheManager的putObject方法"></a>8、接（二、1）TransactionalCacheManager的putObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Cache cache, CacheKey key, Object value) &#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、TransactionalCache的putObject方法"><a href="#9、TransactionalCache的putObject方法" class="headerlink" title="9、TransactionalCache的putObject方法"></a>9、TransactionalCache的putObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object object) &#123;</span><br><span class="line">    //commit时从缓存中删除</span><br><span class="line">    entriesToRemoveOnCommit.remove(key);</span><br><span class="line">    //commit时添加进缓存</span><br><span class="line">    entriesToAddOnCommit.put(key, new AddEntry(delegate, key, object));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、CachingExecutor的close方法"><a href="#10、CachingExecutor的close方法" class="headerlink" title="10、CachingExecutor的close方法"></a>10、CachingExecutor的close方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void close(boolean forceRollback) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //issue #499. Unresolved session handling</span><br><span class="line">        //issue #573. Autocommit sessions should commit</span><br><span class="line">        if (dirty &amp;&amp; !autoCommit) &#123;</span><br><span class="line">            //缓存失效（说明执行的是update之类方法），并且不是自动提交的</span><br><span class="line">            //回滚未提交的缓存 </span><br><span class="line">            tcm.rollback();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //提交缓存</span><br><span class="line">            tcm.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        delegate.close(forceRollback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、TransactionalCacheManager的rollback方法"><a href="#11、TransactionalCacheManager的rollback方法" class="headerlink" title="11、TransactionalCacheManager的rollback方法"></a>11、TransactionalCacheManager的rollback方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void rollback() &#123;</span><br><span class="line">    for (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">        //回滚缓存数据</span><br><span class="line">        txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、TransactionalCache的rollback方法"><a href="#12、TransactionalCache的rollback方法" class="headerlink" title="12、TransactionalCache的rollback方法"></a>12、TransactionalCache的rollback方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void rollback() &#123;</span><br><span class="line">    //临时数据区域</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、接（二、10）TransactionalCacheManager的commit方法"><a href="#11、接（二、10）TransactionalCacheManager的commit方法" class="headerlink" title="11、接（二、10）TransactionalCacheManager的commit方法"></a>11、接（二、10）TransactionalCacheManager的commit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    //获取写锁</span><br><span class="line">    delegate.getReadWriteLock().writeLock().lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (clearOnCommit) &#123;</span><br><span class="line">            //清空缓存</span><br><span class="line">            delegate.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (RemoveEntry entry : entriesToRemoveOnCommit.values()) &#123;</span><br><span class="line">                //删除该key对应的缓存数据</span><br><span class="line">                entry.commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (AddEntry entry : entriesToAddOnCommit.values()) &#123;</span><br><span class="line">            //添加该key对应的缓存数据</span><br><span class="line">            entry.commit();</span><br><span class="line">        &#125;</span><br><span class="line">        //清空队列</span><br><span class="line">        reset();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放写锁</span><br><span class="line">        delegate.getReadWriteLock().writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、SynchronizedCache的clear方法"><a href="#12、SynchronizedCache的clear方法" class="headerlink" title="12、SynchronizedCache的clear方法"></a>12、SynchronizedCache的clear方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    //一层一层，最后获取的是PerpetualCache中的readWriteLock锁，获取写锁</span><br><span class="line">    acquireWriteLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放写锁</span><br><span class="line">        releaseWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear方法一层一层调用，LoggingCache（记录缓存命中率）、SerializedCache（流）、ScheduledCache（定时清空Cache）、LruCache（默认的淘汰包装器），<br>直到LruCache的clear方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    //下一层clear</span><br><span class="line">    delegate.clear();</span><br><span class="line">    // 清空keyMap</span><br><span class="line">    keyMap.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>keyMap为LinkedHashMap先看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void setSize(final int size) &#123;</span><br><span class="line">    //size默认1024</span><br><span class="line">    //为Map加锁synchronized</span><br><span class="line">    keyMap = Collections.synchronizedMap(new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123;</span><br><span class="line">        private static final long serialVersionUID = 4267176411845948333L;</span><br><span class="line">        //实现该方法，将队首节点设置为待删除节点，立即删除keyMap中该节点</span><br><span class="line">        protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123;</span><br><span class="line">            //当前保存数据数量是否大于size</span><br><span class="line">            boolean tooBig = size() &gt; size;</span><br><span class="line">            if (tooBig) &#123;</span><br><span class="line">                //更新最久未使用的缓存数据</span><br><span class="line">                eldestKey = eldest.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            return tooBig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PerpetualCache的clear方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    //清空该Map</span><br><span class="line">    cache.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="12、接（二、11）RemoveEntry的commit方法"><a href="#12、接（二、11）RemoveEntry的commit方法" class="headerlink" title="12、接（二、11）RemoveEntry的commit方法"></a>12、接（二、11）RemoveEntry的commit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    cache.removeObject(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、SynchronizedCache的removeObject方法"><a href="#13、SynchronizedCache的removeObject方法" class="headerlink" title="13、SynchronizedCache的removeObject方法"></a>13、SynchronizedCache的removeObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object removeObject(Object key) &#123;</span><br><span class="line">    //获取写锁</span><br><span class="line">    acquireWriteLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //依次调用下级缓存删除该节点数据</span><br><span class="line">        return delegate.removeObject(key);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放写锁</span><br><span class="line">        releaseWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、接（二、11）AddEntry的commit方法"><a href="#14、接（二、11）AddEntry的commit方法" class="headerlink" title="14、接（二、11）AddEntry的commit方法"></a>14、接（二、11）AddEntry的commit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void commit() &#123;</span><br><span class="line">    cache.putObject(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、SynchronizedCache的putObject方法"><a href="#15、SynchronizedCache的putObject方法" class="headerlink" title="15、SynchronizedCache的putObject方法"></a>15、SynchronizedCache的putObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object object) &#123;</span><br><span class="line">    //获取写锁</span><br><span class="line">    acquireWriteLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //数据添加进下级缓存</span><br><span class="line">        delegate.putObject(key, object);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放写锁</span><br><span class="line">        releaseWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SerializedCache的putObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object object) &#123;</span><br><span class="line">    if (object == null || object instanceof Serializable) &#123;</span><br><span class="line">        //数据序列化后，添加进下级缓存</span><br><span class="line">        delegate.putObject(key, serialize((Serializable) object));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new CacheException(&quot;SharedCache failed to make a copy of a non-serializable object: &quot; + object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ScheduledCache的putObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object object) &#123;</span><br><span class="line">    //超时则清空缓存</span><br><span class="line">    clearWhenStale();</span><br><span class="line">    //数据添加进下级缓存</span><br><span class="line">    delegate.putObject(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LruCache的putObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object value) &#123;</span><br><span class="line">    //数据添加进下级缓存</span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">    //key加入keyMap中，并移至队尾，并检查是否有待删除节点</span><br><span class="line">    cycleKeyList(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PerpetualCache的putObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void putObject(Object key, Object value) &#123;</span><br><span class="line">    //数据存入缓存</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="16、LruCache的cycleKeyList方法"><a href="#16、LruCache的cycleKeyList方法" class="headerlink" title="16、LruCache的cycleKeyList方法"></a>16、LruCache的cycleKeyList方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void cycleKeyList(Object key) &#123;</span><br><span class="line">    //key加入keyMap中，并移至队尾</span><br><span class="line">    keyMap.put(key, key);</span><br><span class="line">    //有待删除节点</span><br><span class="line">    if (eldestKey != null) &#123;</span><br><span class="line">        //下级缓存，删除待删除节点</span><br><span class="line">        delegate.removeObject(eldestKey);</span><br><span class="line">        eldestKey = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、PerpetualCache的removeObject方法"><a href="#17、PerpetualCache的removeObject方法" class="headerlink" title="17、PerpetualCache的removeObject方法"></a>17、PerpetualCache的removeObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object removeObject(Object key) &#123;</span><br><span class="line">    //删除该节点</span><br><span class="line">    return cache.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、分页插件"><a href="#三、分页插件" class="headerlink" title="三、分页插件"></a>三、分页插件</h3><h4 id="1、XMLConfigBuilder的pluginElement方法"><a href="#1、XMLConfigBuilder的pluginElement方法" class="headerlink" title="1、XMLConfigBuilder的pluginElement方法"></a>1、XMLConfigBuilder的pluginElement方法</h4><p>xml加载时，加载插件配置的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            //插件全类名</span><br><span class="line">            String interceptor = child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">            //属性</span><br><span class="line">            Properties properties = child.getChildrenAsProperties();</span><br><span class="line">            //实例化插件</span><br><span class="line">            Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">            //设置插件属性</span><br><span class="line">            interceptorInstance.setProperties(properties);</span><br><span class="line">            //插件加载入configuration的interceptorChain中</span><br><span class="line">            configuration.addInterceptor(interceptorInstance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分页插件配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">        &lt;!-- 该参数默认为false --&gt;</span><br><span class="line">        &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;</span><br><span class="line">        &lt;!-- 和startPage中的pageNum效果一样--&gt;</span><br><span class="line">        &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;!-- 该参数默认为false --&gt;</span><br><span class="line">        &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;</span><br><span class="line">        &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;</span><br><span class="line">        &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt;</span><br><span class="line">        &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;</span><br><span class="line">        &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;</span><br><span class="line">        &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;</span><br><span class="line">        &lt;property name=&quot;reasonable&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;</span><br><span class="line">        &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;</span><br><span class="line">        &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;</span><br><span class="line">        &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt;</span><br><span class="line">        &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;&quot;/&gt;</span><br><span class="line">        &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt;</span><br><span class="line">        &lt;property name=&quot;returnPageInfo&quot; value=&quot;check&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、InterceptorChain的pluginAll方法"><a href="#2、InterceptorChain的pluginAll方法" class="headerlink" title="2、InterceptorChain的pluginAll方法"></a>2、InterceptorChain的pluginAll方法</h4><p>上一篇中，Configuration的方法中newExecutor方法中调用了InterceptorChain的interceptorChain.pluginAll(executor)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object pluginAll(Object target) &#123;</span><br><span class="line">    for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">        target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、PageHelper的plugin方法"><a href="#3、PageHelper的plugin方法" class="headerlink" title="3、PageHelper的plugin方法"></a>3、PageHelper的plugin方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object plugin(Object target) &#123;</span><br><span class="line">    //传入对象是Executor，则用Plugin包装，否则返回原对象</span><br><span class="line">    if (target instanceof Executor) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、Plugin的wrap方法"><a href="#4、Plugin的wrap方法" class="headerlink" title="4、Plugin的wrap方法"></a>4、Plugin的wrap方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    //过去，注解指定类及注解指定的类方法的Map</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    //Executor的类</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">        //创建Executor的代理对象</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          //拦截器</span><br><span class="line">          new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Plugin的getSignatureMap方法"><a href="#5、Plugin的getSignatureMap方法" class="headerlink" title="5、Plugin的getSignatureMap方法"></a>5、Plugin的getSignatureMap方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    //获取该类上的Intercepts注解</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    if (interceptsAnnotation == null) &#123; // issue #251</span><br><span class="line">        throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    //获取该注解值</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    for (Signature sig : sigs) &#123;</span><br><span class="line">        //由注解指定的类，获取该类的被注解指定的方法</span><br><span class="line">        Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">        if (methods == null) &#123;</span><br><span class="line">            methods = new HashSet&lt;Method&gt;();</span><br><span class="line">            //不存在，则添加进signatureMap</span><br><span class="line">            signatureMap.put(sig.type(), methods);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取注解指定类中的被注解指定方法</span><br><span class="line">            Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">            //添加进集合</span><br><span class="line">            methods.add(method);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、接（三、4）Plugin的invoke方法"><a href="#6、接（三、4）Plugin的invoke方法" class="headerlink" title="6、接（三、4）Plugin的invoke方法"></a>6、接（三、4）Plugin的invoke方法</h4><p>返回的代理对象为Plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取注解指定的方法</span><br><span class="line">        Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">        if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">            //拦截注解指定的方法</span><br><span class="line">            return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        //调用原对象的该方法</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、PageHelper的intercept方法"><a href="#7、PageHelper的intercept方法" class="headerlink" title="7、PageHelper的intercept方法"></a>7、PageHelper的intercept方法</h4><p>Executor的query方法会被PageHelper拦截<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    //自动获取dialect，</span><br><span class="line">    if (autoDialect) &#123;</span><br><span class="line">        //初始化sqlUtil</span><br><span class="line">        initSqlUtil(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    return sqlUtil.processPage(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="8、SqlUtil的processPage方法"><a href="#8、SqlUtil的processPage方法" class="headerlink" title="8、SqlUtil的processPage方法"></a>8、SqlUtil的processPage方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object processPage(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object result = _processPage(invocation);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        clearLocalPage();</span><br><span class="line">        OrderByHelper.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、SqlUtil的-processPage方法"><a href="#9、SqlUtil的-processPage方法" class="headerlink" title="9、SqlUtil的_processPage方法"></a>9、SqlUtil的_processPage方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private Object _processPage(Invocation invocation) throws Throwable &#123;</span><br><span class="line">    //获取参数</span><br><span class="line">    final Object[] args = invocation.getArgs();</span><br><span class="line">    //query方法的第三个参数是RowBounds</span><br><span class="line">    RowBounds rowBounds = (RowBounds) args[2];</span><br><span class="line">    if (SqlUtil.getLocalPage() == null &amp;&amp; rowBounds == RowBounds.DEFAULT) &#123;</span><br><span class="line">        //未设置查询数量限制，直接执行</span><br><span class="line">        //设置了排序</span><br><span class="line">        if (OrderByHelper.getOrderBy() != null) &#123;</span><br><span class="line">            //封装排序，返回OrderByDynamicSqlSource对象</span><br><span class="line">            OrderByHelper.processIntercept(invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        //执行查询</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //获取原始的ms</span><br><span class="line">        MappedStatement ms = (MappedStatement) args[0];</span><br><span class="line">        //判断并处理为PageSqlSource</span><br><span class="line">        if (!isPageSqlSource(ms)) &#123;</span><br><span class="line">            processMappedStatement(ms, parser);</span><br><span class="line">        &#125;</span><br><span class="line">        //忽略RowBounds-否则会进行Mybatis自带的内存分页</span><br><span class="line">        args[2] = RowBounds.DEFAULT;</span><br><span class="line">        //获取分页信息</span><br><span class="line">        Page page = getPage(rowBounds);</span><br><span class="line">        //pageSizeZero的判断</span><br><span class="line">        if ((page.getPageSizeZero() != null &amp;&amp; page.getPageSizeZero()) &amp;&amp; page.getPageSize() == 0) &#123;</span><br><span class="line">            COUNT.set(null);</span><br><span class="line">            //执行正常（不分页）查询</span><br><span class="line">            Object result = invocation.proceed();</span><br><span class="line">            //得到处理结果</span><br><span class="line">            page.addAll((List) result);</span><br><span class="line">            //相当于查询第一页</span><br><span class="line">            page.setPageNum(1);</span><br><span class="line">            //这种情况相当于pageSize=total</span><br><span class="line">            page.setPageSize(page.size());</span><br><span class="line">            //仍然要设置total</span><br><span class="line">            page.setTotal(page.size());</span><br><span class="line">            //返回结果仍然为Page类型 - 便于后面对接收类型的统一处理</span><br><span class="line">            return page;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //简单的通过total的值来判断是否进行count查询，total默认等于1</span><br><span class="line">        if (page.isCount()) &#123;</span><br><span class="line">            COUNT.set(Boolean.TRUE);</span><br><span class="line">            //替换MS</span><br><span class="line">            args[0] = msCountMap.get(ms.getId());</span><br><span class="line">            //查询总数</span><br><span class="line">            Object result = invocation.proceed();</span><br><span class="line">            //还原ms</span><br><span class="line">            args[0] = ms;</span><br><span class="line">            //设置总数</span><br><span class="line">            page.setTotal((Integer) ((List) result).get(0));</span><br><span class="line">            if (page.getTotal() == 0) &#123;</span><br><span class="line">                return page;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //pageSize&gt;0的时候执行分页查询，pageSize&lt;=0的时候不执行相当于可能只返回了一个count</span><br><span class="line">        if (page.getPageSize() &gt; 0 &amp;&amp;</span><br><span class="line">                ((rowBounds == RowBounds.DEFAULT &amp;&amp; page.getPageNum() &gt; 0)</span><br><span class="line">                        || rowBounds != RowBounds.DEFAULT)) &#123;</span><br><span class="line">            //将参数中的MappedStatement替换为新的qs</span><br><span class="line">            COUNT.set(null);</span><br><span class="line">            BoundSql boundSql = ms.getBoundSql(args[1]);</span><br><span class="line">            args[1] = parser.setPageParameter(ms, args[1], boundSql, page);</span><br><span class="line">            COUNT.set(Boolean.FALSE);</span><br><span class="line">            //执行分页查询</span><br><span class="line">            Object result = invocation.proceed();</span><br><span class="line">            //得到处理结果</span><br><span class="line">            page.addAll((List) result);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        return page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、SqlUtil的processMappedStatement方法"><a href="#10、SqlUtil的processMappedStatement方法" class="headerlink" title="10、SqlUtil的processMappedStatement方法"></a>10、SqlUtil的processMappedStatement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void processMappedStatement(MappedStatement ms, Parser parser) throws Throwable &#123;</span><br><span class="line">    SqlSource sqlSource = ms.getSqlSource();</span><br><span class="line">    MetaObject msObject = SystemMetaObject.forObject(ms);</span><br><span class="line">    SqlSource tempSqlSource = sqlSource;</span><br><span class="line">    if (sqlSource instanceof OrderBySqlSource) &#123;</span><br><span class="line">        tempSqlSource = ((OrderBySqlSource) tempSqlSource).getOriginal();</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSource pageSqlSource;</span><br><span class="line">    if (tempSqlSource instanceof StaticSqlSource) &#123;</span><br><span class="line">        pageSqlSource = new PageStaticSqlSource((StaticSqlSource) tempSqlSource, parser);</span><br><span class="line">    &#125; else if (tempSqlSource instanceof RawSqlSource) &#123;</span><br><span class="line">        pageSqlSource = new PageRawSqlSource((RawSqlSource) tempSqlSource, parser);</span><br><span class="line">    &#125; else if (tempSqlSource instanceof ProviderSqlSource) &#123;</span><br><span class="line">        pageSqlSource = new PageProviderSqlSource((ProviderSqlSource) tempSqlSource, parser);</span><br><span class="line">    &#125; else if (tempSqlSource instanceof DynamicSqlSource) &#123;</span><br><span class="line">        //默认DynamicSqlSource</span><br><span class="line">        pageSqlSource = new PageDynamicSqlSource((DynamicSqlSource) tempSqlSource, parser);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(&quot;无法处理该类型[&quot; + sqlSource.getClass() + &quot;]的SqlSource&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //替换原来的sqlSource</span><br><span class="line">    msObject.setValue(&quot;sqlSource&quot;, pageSqlSource);</span><br><span class="line">    //由于count查询需要修改返回值，因此这里要创建一个Count查询的MS</span><br><span class="line">    msCountMap.put(ms.getId(), MSUtils.newCountMappedStatement(ms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、接（三、9）SqlUtil的getPage方法"><a href="#11、接（三、9）SqlUtil的getPage方法" class="headerlink" title="11、接（三、9）SqlUtil的getPage方法"></a>11、接（三、9）SqlUtil的getPage方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Page getPage(Object params) &#123;</span><br><span class="line">    //获取本线程对应的page</span><br><span class="line">    Page page = getLocalPage();</span><br><span class="line">    //未设置page尝试从查询方法参数RowBounds中获取分页信息</span><br><span class="line">    if (page == null) &#123;</span><br><span class="line">        if (params instanceof RowBounds) &#123;</span><br><span class="line">            RowBounds rowBounds = (RowBounds) params;</span><br><span class="line">            if (offsetAsPageNum) &#123;</span><br><span class="line">                page = new Page(rowBounds.getOffset(), rowBounds.getLimit(), rowBoundsWithCount);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                page = new Page(rowBounds, rowBoundsWithCount);</span><br><span class="line">                //offsetAsPageNum=false的时候，由于PageNum问题，不能使用reasonable，这里会强制为false</span><br><span class="line">                page.setReasonable(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            page = getPageFromObject(params);</span><br><span class="line">        &#125;</span><br><span class="line">        setLocalPage(page);</span><br><span class="line">    &#125;</span><br><span class="line">    //分页合理化</span><br><span class="line">    if (page.getReasonable() == null) &#123;</span><br><span class="line">        page.setReasonable(reasonable);</span><br><span class="line">    &#125;</span><br><span class="line">    //当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页，返回全部结果</span><br><span class="line">    if (page.getPageSizeZero() == null) &#123;</span><br><span class="line">        page.setPageSizeZero(pageSizeZero);</span><br><span class="line">    &#125;</span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、接（三、9）MysqlParser的setPageParameter方法"><a href="#12、接（三、9）MysqlParser的setPageParameter方法" class="headerlink" title="12、接（三、9）MysqlParser的setPageParameter方法"></a>12、接（三、9）MysqlParser的setPageParameter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Map setPageParameter(MappedStatement ms, Object parameterObject, BoundSql boundSql, Page page) &#123;</span><br><span class="line">    Map paramMap = super.setPageParameter(ms, parameterObject, boundSql, page);</span><br><span class="line">    paramMap.put(PAGEPARAMETER_FIRST, page.getStartRow());</span><br><span class="line">    paramMap.put(PAGEPARAMETER_SECOND, page.getPageSize());</span><br><span class="line">    return paramMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MysqlParser父类AbstractParser的setPageParameter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Map setPageParameter(MappedStatement ms, Object parameterObject, BoundSql boundSql, Page page) &#123;</span><br><span class="line">    return processParameter(ms, parameterObject, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="13、MysqlParser的processParameter方法"><a href="#13、MysqlParser的processParameter方法" class="headerlink" title="13、MysqlParser的processParameter方法"></a>13、MysqlParser的processParameter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, Object&gt; processParameter(MappedStatement ms, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    Map paramMap = null;</span><br><span class="line">    if (parameterObject == null) &#123;</span><br><span class="line">        paramMap = new HashMap();</span><br><span class="line">    &#125; else if (parameterObject instanceof Map) &#123;</span><br><span class="line">        //解决不可变Map的情况</span><br><span class="line">        paramMap = new HashMap();</span><br><span class="line">        paramMap.putAll((Map) parameterObject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        paramMap = new HashMap();</span><br><span class="line">        //动态sql时的判断条件不会出现在ParameterMapping中，但是必须有，所以这里需要收集所有的getter属性</span><br><span class="line">        //TypeHandlerRegistry可以直接处理的会作为一个直接使用的对象进行处理</span><br><span class="line">        boolean hasTypeHandler = ms.getConfiguration().getTypeHandlerRegistry().hasTypeHandler(parameterObject.getClass());</span><br><span class="line">        MetaObject metaObject = SystemMetaObject.forObject(parameterObject);</span><br><span class="line">        //需要针对注解形式的MyProviderSqlSource保存原值</span><br><span class="line">        if (ms.getSqlSource() instanceof PageProviderSqlSource) &#123;</span><br><span class="line">            paramMap.put(PROVIDER_OBJECT, parameterObject);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!hasTypeHandler) &#123;</span><br><span class="line">            for (String name : metaObject.getGetterNames()) &#123;</span><br><span class="line">                paramMap.put(name, metaObject.getValue(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //下面这段方法，主要解决一个常见类型的参数时的问题</span><br><span class="line">        if (boundSql.getParameterMappings() != null &amp;&amp; boundSql.getParameterMappings().size() &gt; 0) &#123;</span><br><span class="line">            for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) &#123;</span><br><span class="line">                String name = parameterMapping.getProperty();</span><br><span class="line">                if (!name.equals(PAGEPARAMETER_FIRST)</span><br><span class="line">                        &amp;&amp; !name.equals(PAGEPARAMETER_SECOND)</span><br><span class="line">                        &amp;&amp; paramMap.get(name) == null) &#123;</span><br><span class="line">                    if (hasTypeHandler</span><br><span class="line">                            || parameterMapping.getJavaType().equals(parameterObject.getClass())) &#123;</span><br><span class="line">                        paramMap.put(name, parameterObject);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //备份原始参数对象</span><br><span class="line">    paramMap.put(ORIGINAL_PARAMETER_OBJECT, parameterObject);</span><br><span class="line">    return paramMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、PageSqlSource的getBoundSql方法"><a href="#14、PageSqlSource的getBoundSql方法" class="headerlink" title="14、PageSqlSource的getBoundSql方法"></a>14、PageSqlSource的getBoundSql方法</h4><p>Invocation的proceed方法，实际是调用了被代理对象的query方法，与之前相同的方法略过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">    Boolean count = getCount();</span><br><span class="line">    if(count == null)&#123;</span><br><span class="line">        //原始的sql</span><br><span class="line">        return getDefaultBoundSql(parameterObject);</span><br><span class="line">    &#125; else if(count)&#123;</span><br><span class="line">        //统计sql</span><br><span class="line">        return getCountBoundSql(parameterObject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //分页sql</span><br><span class="line">        return getPageBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="15、PageDynamicSqlSource的getCountBoundSql方法"><a href="#15、PageDynamicSqlSource的getCountBoundSql方法" class="headerlink" title="15、PageDynamicSqlSource的getCountBoundSql方法"></a>15、PageDynamicSqlSource的getCountBoundSql方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected BoundSql getCountBoundSql(Object parameterObject) &#123;</span><br><span class="line">    DynamicContext context = new DynamicContext(configuration, parameterObject);</span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();</span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    //sql修改为查询总量sql，AbstractParser.getCountSql方法</span><br><span class="line">    sqlSource = new StaticSqlSource(configuration, parser.getCountSql(boundSql.getSql()), boundSql.getParameterMappings());</span><br><span class="line">    boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    //设置条件参数</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">        boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16、接（三、14）PageDynamicSqlSource的getPageBoundSql方法"><a href="#16、接（三、14）PageDynamicSqlSource的getPageBoundSql方法" class="headerlink" title="16、接（三、14）PageDynamicSqlSource的getPageBoundSql方法"></a>16、接（三、14）PageDynamicSqlSource的getPageBoundSql方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected BoundSql getPageBoundSql(Object parameterObject) &#123;</span><br><span class="line">    DynamicContext context;</span><br><span class="line">    //由于增加分页参数后会修改parameterObject的值，因此在前面处理时备份该值</span><br><span class="line">    //如果发现参数是Map并且包含该KEY，就使用备份的该值</span><br><span class="line">    //解决bug#25:http://git.oschina.net/free/Mybatis_PageHelper/issues/25</span><br><span class="line">    if (parameterObject != null</span><br><span class="line">            &amp;&amp; parameterObject instanceof Map</span><br><span class="line">            &amp;&amp; ((Map) parameterObject).containsKey(ORIGINAL_PARAMETER_OBJECT)) &#123;</span><br><span class="line">        context = new DynamicContext(configuration, ((Map) parameterObject).get(ORIGINAL_PARAMETER_OBJECT));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        context = new DynamicContext(configuration, parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();</span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">    sqlSource = new OrderByStaticSqlSource((StaticSqlSource) sqlSource);</span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    //sql修改为查询总量sql，AbstractParser.getPageSql方法</span><br><span class="line">    sqlSource = new StaticSqlSource(configuration, parser.getPageSql(boundSql.getSql()), parser.getPageParameterMapping(configuration, boundSql));</span><br><span class="line">    boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    //设置条件参数</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">        boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、PageHelper的startPage方法"><a href="#17、PageHelper的startPage方法" class="headerlink" title="17、PageHelper的startPage方法"></a>17、PageHelper的startPage方法</h4><p>PageHelper的startPage方法设置本线程下次查询的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Page startPage(int pageNum, int pageSize) &#123;</span><br><span class="line">    return startPage(pageNum, pageSize, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Page startPage(int pageNum, int pageSize, boolean count) &#123;</span><br><span class="line">    return startPage(pageNum, pageSize, count, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Page startPage(int pageNum, int pageSize, boolean count, Boolean reasonable) &#123;</span><br><span class="line">    return startPage(pageNum, pageSize, count, reasonable, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Page startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) &#123;</span><br><span class="line">    Page page = new Page(pageNum, pageSize, count);</span><br><span class="line">    page.setReasonable(reasonable);</span><br><span class="line">    page.setPageSizeZero(pageSizeZero);</span><br><span class="line">    SqlUtil.setLocalPage(page);</span><br><span class="line">    return page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、SqlUtil的setLocalPage方法"><a href="#18、SqlUtil的setLocalPage方法" class="headerlink" title="18、SqlUtil的setLocalPage方法"></a>18、SqlUtil的setLocalPage方法</h4><p>LOCAL_PAGE是一个线程局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal&lt;Page&gt;();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void setLocalPage(Page page) &#123;</span><br><span class="line">    //将page添加进线程局部变量</span><br><span class="line">    LOCAL_PAGE.set(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、元对象MetaObject"><a href="#四、元对象MetaObject" class="headerlink" title="四、元对象MetaObject"></a>四、元对象MetaObject</h3><h4 id="1、Configuration的newMetaObject方法"><a href="#1、Configuration的newMetaObject方法" class="headerlink" title="1、Configuration的newMetaObject方法"></a>1、Configuration的newMetaObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public MetaObject newMetaObject(Object object) &#123;</span><br><span class="line">    return MetaObject.forObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、MetaObject的forObject方法"><a href="#2、MetaObject的forObject方法" class="headerlink" title="2、MetaObject的forObject方法"></a>2、MetaObject的forObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static MetaObject forObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory) &#123;</span><br><span class="line">    if (object == null) &#123;</span><br><span class="line">        return SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return new MetaObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、实例化MetaObject"><a href="#3、实例化MetaObject" class="headerlink" title="3、实例化MetaObject"></a>3、实例化MetaObject</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory) &#123;</span><br><span class="line">    this.originalObject = object;</span><br><span class="line">    this.objectFactory = objectFactory;</span><br><span class="line">    this.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line"></span><br><span class="line">    if (object instanceof ObjectWrapper) &#123;</span><br><span class="line">        this.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; else if (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">        this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);</span><br><span class="line">    &#125; else if (object instanceof Map) &#123;</span><br><span class="line">        this.objectWrapper = new MapWrapper(this, (Map) object);</span><br><span class="line">    &#125; else if (object instanceof Collection) &#123;</span><br><span class="line">        this.objectWrapper = new CollectionWrapper(this, (Collection) object);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //本例以object为bean</span><br><span class="line">        this.objectWrapper = new BeanWrapper(this, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、实例化BeanWrapper"><a href="#3、实例化BeanWrapper" class="headerlink" title="3、实例化BeanWrapper"></a>3、实例化BeanWrapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public BeanWrapper(MetaObject metaObject, Object object) &#123;</span><br><span class="line">    super(metaObject);</span><br><span class="line">    this.object = object;</span><br><span class="line">    this.metaClass = MetaClass.forClass(object.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、MetaObject的hasSetter方法"><a href="#4、MetaObject的hasSetter方法" class="headerlink" title="4、MetaObject的hasSetter方法"></a>4、MetaObject的hasSetter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasSetter(String name) &#123;</span><br><span class="line">    return objectWrapper.hasSetter(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、BeanWrapper的hasSetter方法"><a href="#5、BeanWrapper的hasSetter方法" class="headerlink" title="5、BeanWrapper的hasSetter方法"></a>5、BeanWrapper的hasSetter方法</h4><p>name为bean的属性，通常为name或user.name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasSetter(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = new PropertyTokenizer(name);</span><br><span class="line">    if (prop.hasNext()) &#123;</span><br><span class="line">        //name包含小数点，说明bean A的属性为另一个bean B</span><br><span class="line">        //检验bean A是否有bean B的set方法</span><br><span class="line">        if (metaClass.hasSetter(prop.getIndexedName())) &#123;</span><br><span class="line">            //获取bean B的MetaObject封装对象</span><br><span class="line">            MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">            if (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">                return metaClass.hasSetter(name);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //检查bean B是否有该属性的set方法</span><br><span class="line">                return metaValue.hasSetter(prop.getChildren());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return metaClass.hasSetter(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、MetaObject的metaObjectForProperty方法"><a href="#6、MetaObject的metaObjectForProperty方法" class="headerlink" title="6、MetaObject的metaObjectForProperty方法"></a>6、MetaObject的metaObjectForProperty方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public MetaObject metaObjectForProperty(String name) &#123;</span><br><span class="line">    //获取name对象</span><br><span class="line">    Object value = getValue(name);</span><br><span class="line">    //MetaObject封装该对象</span><br><span class="line">    return MetaObject.forObject(value, objectFactory, objectWrapperFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、MetaObject的getValue方法"><a href="#7、MetaObject的getValue方法" class="headerlink" title="7、MetaObject的getValue方法"></a>7、MetaObject的getValue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue(String name) &#123;</span><br><span class="line">    PropertyTokenizer prop = new PropertyTokenizer(name);</span><br><span class="line">    //判断是否有第三层，有则递归调用</span><br><span class="line">    if (prop.hasNext()) &#123;</span><br><span class="line">            MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        if (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return metaValue.getValue(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //获取该对象</span><br><span class="line">        return objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> mybatis3 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mybatis源码sql执行过程（1）</title>
      <link href="/2018/04/20/mybatis3%E6%BA%90%E7%A0%81/mybatis%E6%BA%90%E7%A0%81sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="mybatis源码select执行过程"><a href="#mybatis源码select执行过程" class="headerlink" title="mybatis源码select执行过程"></a>mybatis源码select执行过程</h2><h3 id="一、获取SqlSession过程"><a href="#一、获取SqlSession过程" class="headerlink" title="一、获取SqlSession过程"></a>一、获取SqlSession过程</h3><h4 id="1、DefaultSqlSessionFactory的openSession方法"><a href="#1、DefaultSqlSessionFactory的openSession方法" class="headerlink" title="1、DefaultSqlSessionFactory的openSession方法"></a>1、DefaultSqlSessionFactory的openSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSession openSession() &#123;</span><br><span class="line">    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、DefaultSqlSessionFactory的openSession方法"><a href="#2、DefaultSqlSessionFactory的openSession方法" class="headerlink" title="2、DefaultSqlSessionFactory的openSession方法"></a>2、DefaultSqlSessionFactory的openSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SqlSession openSession() &#123;</span><br><span class="line">    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、DefaultSqlSessionFactory的openSessionFromDataSource方法"><a href="#3、DefaultSqlSessionFactory的openSessionFromDataSource方法" class="headerlink" title="3、DefaultSqlSessionFactory的openSessionFromDataSource方法"></a>3、DefaultSqlSessionFactory的openSessionFromDataSource方法</h4><p>这个是最终创建SqlSession对象的方法，需要三个参数。<br>execType,这个示例使用的是configuration.getDefaultExecutorType(),默认ExecutorType.SIMPLE。<br>事务隔离等级，我们对数据库操作里一般都不会带这个属性，这个属性由数据库分配即可。<br>autoCommit:这个一般都是false，不然事务将没有意义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final Environment environment = configuration.getEnvironment();</span><br><span class="line">        //获取一个事务工厂,配置文件中配置,默认ManagedTransactionFactory</span><br><span class="line">        final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        //通过事务工厂获取一个事务，默认ManagedTransaction 这个配置从来都不提交和回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务的上下文）。</span><br><span class="line">        //默认情况下他会关闭连接，closeConnection属性设置为false来阻止它默认的关闭行为</span><br><span class="line">        //JdbcTransactionFactory,这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        //根据execType获取一个Executor，默认SimpleExecutor</span><br><span class="line">        final Executor executor = configuration.newExecutor(tx, execType, autoCommit);</span><br><span class="line">        return new DefaultSqlSession(configuration, executor);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); // may have fetched a connection so lets call close()</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、Configuration的newExecutor方法"><a href="#4、Configuration的newExecutor方法" class="headerlink" title="4、Configuration的newExecutor方法"></a>4、Configuration的newExecutor方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //默认</span><br><span class="line">        executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">         executor = new CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Configuration的newExecutor方法"><a href="#5、Configuration的newExecutor方法" class="headerlink" title="5、Configuration的newExecutor方法"></a>5、Configuration的newExecutor方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">        //批量执行器</span><br><span class="line">        executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">        executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //默认执行器</span><br><span class="line">        executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">        //使用二级缓存，则用该执行器封装一层</span><br><span class="line">        executor = new CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    //拦截器</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###二、创建Mapper代理对象过程</p><h4 id="1、DefaultSqlSession的getMapper方法"><a href="#1、DefaultSqlSession的getMapper方法" class="headerlink" title="1、DefaultSqlSession的getMapper方法"></a>1、DefaultSqlSession的getMapper方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.&lt;T&gt;getMapper(type, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Configuration的getMapper方法"><a href="#2、Configuration的getMapper方法" class="headerlink" title="2、Configuration的getMapper方法"></a>2、Configuration的getMapper方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.&lt;T&gt;getMapper(type, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、mapperRegistry的getMapper方法"><a href="#3、mapperRegistry的getMapper方法" class="headerlink" title="3、mapperRegistry的getMapper方法"></a>3、mapperRegistry的getMapper方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    //代理工厂</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory == null)</span><br><span class="line">        //说明这个Mapper接口没有注册 </span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        //生成一个MapperProxy对象</span><br><span class="line">        return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、MapperProxyFactory的newInstance方法"><a href="#4、MapperProxyFactory的newInstance方法" class="headerlink" title="4、MapperProxyFactory的newInstance方法"></a>4、MapperProxyFactory的newInstance方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    //JDK动态代理InvocationHandler的实现类，在该类methodCache管理了被代理的方法，methodCache在整个应用中是共享的</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    //创建Mapper接口子类的代理类</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、DemoMapper的selectOneById方法"><a href="#5、DemoMapper的selectOneById方法" class="headerlink" title="5、DemoMapper的selectOneById方法"></a>5、DemoMapper的selectOneById方法</h4><p>自动创建的代理类，执行MapperProxy的invoke方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        //如果是Object中定义的方法，直接执行。如toString(),hashCode()等。  </span><br><span class="line">        return method.invoke(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    //其他Mapper接口定义的方法交由mapperMethod来执行</span><br><span class="line">    final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、MapperMethod的execute方法"><a href="#6、MapperMethod的execute方法" class="headerlink" title="6、MapperMethod的execute方法"></a>6、MapperMethod的execute方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    //判断这个方法被注解里的Sql类型</span><br><span class="line">    if (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">        //增</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">    &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">        //改</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">    &#125; else if (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">        //删</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">    &#125; else if (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">        //查</span><br><span class="line">        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">            //没有返回值，并且有ResultHandler的情况</span><br><span class="line">            executeWithResultHandler(sqlSession, args);</span><br><span class="line">            result = null;</span><br><span class="line">        &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">            //返回一个List</span><br><span class="line">            result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">            //返回一个Map</span><br><span class="line">            result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //返回一个对象</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">        throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">              + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、MapperMethod的executeForMany方法"><a href="#7、MapperMethod的executeForMany方法" class="headerlink" title="7、MapperMethod的executeForMany方法"></a>7、MapperMethod的executeForMany方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    //解析传入参数</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    if (method.hasRowBounds()) &#123;</span><br><span class="line">        //结果有数量限制</span><br><span class="line">        RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    // issue #510 Collections &amp; arrays support</span><br><span class="line">    if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        if (method.getReturnType().isArray()) &#123;</span><br><span class="line">            return convertToArray(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //sql返回的集合，转化为方法声明的集合</span><br><span class="line">            return convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、MapperMethod的convertArgsToSqlCommandParam方法"><a href="#8、MapperMethod的convertArgsToSqlCommandParam方法" class="headerlink" title="8、MapperMethod的convertArgsToSqlCommandParam方法"></a>8、MapperMethod的convertArgsToSqlCommandParam方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public Object convertArgsToSqlCommandParam(Object[] args) &#123;</span><br><span class="line">    //参数个数，配置加载的时候，parameterType只能有一个参数</span><br><span class="line">    final int paramCount = params.size();</span><br><span class="line">    if (args == null || paramCount == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else if (!hasNamedParameters &amp;&amp; paramCount == 1) &#123;</span><br><span class="line">        //获取并返回参数</span><br><span class="line">        return args[params.keySet().iterator().next()];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final Map&lt;String, Object&gt; param = new ParamMap&lt;Object&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Map.Entry&lt;Integer, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">            //按照对应顺序获取参数</span><br><span class="line">            param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">            final String genericParamName = &quot;param&quot; + String.valueOf(i + 1);</span><br><span class="line">            if (!param.containsKey(genericParamName)) &#123;</span><br><span class="line">                param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return param;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###三、获取可执行sql过程</p><h4 id="1、DefaultSqlSession的selectList方法"><a href="#1、DefaultSqlSession的selectList方法" class="headerlink" title="1、DefaultSqlSession的selectList方法"></a>1、DefaultSqlSession的selectList方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //statement是命名空间+sql的id(等于mapper名+sql的id),获取sql的MappedStatement</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、BaseExecutor的query方法"><a href="#2、BaseExecutor的query方法" class="headerlink" title="2、BaseExecutor的query方法"></a>2、BaseExecutor的query方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    //BoundSql包含可执行的sql和参数集合 </span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、MappedStatement的getBoundSql方法"><a href="#3、MappedStatement的getBoundSql方法" class="headerlink" title="3、MappedStatement的getBoundSql方法"></a>3、MappedStatement的getBoundSql方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">      //通过sqlSource对象获取 </span><br><span class="line">      BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">      /parameterMap一般不会配置</span><br><span class="line">      List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">      if (parameterMappings == null || parameterMappings.size() &lt;= 0) &#123;</span><br><span class="line">          boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // check for nested result maps in parameter mappings (issue #30)</span><br><span class="line">      for (ParameterMapping pm : boundSql.getParameterMappings()) &#123;</span><br><span class="line">          String rmId = pm.getResultMapId();</span><br><span class="line">          if (rmId != null) &#123;</span><br><span class="line">              ResultMap rm = configuration.getResultMap(rmId);</span><br><span class="line">              if (rm != null) &#123;</span><br><span class="line">                  hasNestedResultMaps |= rm.hasNestedResultMaps();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、DynamicSqlSource的getBoundSql方法"><a href="#4、DynamicSqlSource的getBoundSql方法" class="headerlink" title="4、DynamicSqlSource的getBoundSql方法"></a>4、DynamicSqlSource的getBoundSql方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">      DynamicContext context = new DynamicContext(configuration, parameterObject);</span><br><span class="line">      //sqlNode使用组合模式实现，他有多个SqlNode对象  </span><br><span class="line">      //每个SqlNode的apply方法调用时，都为将sql加到context中，最终通过context.getSql()得到完整的sql </span><br><span class="line">      rootSqlNode.apply(context);</span><br><span class="line">      SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);</span><br><span class="line">      //参数类型</span><br><span class="line">      Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();</span><br><span class="line">      //这里就是处理&quot;#&#123;&#125;&quot;占位符的地方，返回的StaticSqlSource中包含了可执行的sql </span><br><span class="line">      SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">      //这个BoundSql就是数据库可执行的Sql,同时还包含了运行时的参数  </span><br><span class="line">      BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">      for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">          boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、SqlNode的apply方法"><a href="#5、SqlNode的apply方法" class="headerlink" title="5、SqlNode的apply方法"></a>5、SqlNode的apply方法</h4><p>MixedSqlNode的apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">    for (SqlNode sqlNode : contents) &#123;</span><br><span class="line">        sqlNode.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>混合节点MixedSqlNode的apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">    for (SqlNode sqlNode : contents) &#123;</span><br><span class="line">        sqlNode.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文本节点TextSqlNode的apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">    //解析$&#123;tab_name&#125;这种占位符</span><br><span class="line">    GenericTokenParser parser = new GenericTokenParser(&quot;$&#123;&quot;, &quot;&#125;&quot;, new BindingTokenParser(context));</span><br><span class="line">    //BindingTokenParser的handleToken方法将$&#123;tab_name&#125;替换为传入参数，并将sql加入context中</span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if节点IfSqlNode的apply<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">    //test表达式成立</span><br><span class="line">    if (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        //继续执行子sql节点的apply</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、接（三、4）SqlSourceBuilder的parse方法"><a href="#6、接（三、4）SqlSourceBuilder的parse方法" class="headerlink" title="6、接（三、4）SqlSourceBuilder的parse方法"></a>6、接（三、4）SqlSourceBuilder的parse方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">    //处理占位符的handler </span><br><span class="line">    ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    //要处理什么样的占位符</span><br><span class="line">    GenericTokenParser parser = new GenericTokenParser(&quot;#&#123;&quot;, &quot;&#125;&quot;, handler);</span><br><span class="line">    //开始处理</span><br><span class="line">    String sql = parser.parse(originalSql);</span><br><span class="line">    //这个SqlSource就是一个简单的java对象</span><br><span class="line">    return new StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、ParameterMappingTokenHandler的handleToken方法"><a href="#7、ParameterMappingTokenHandler的handleToken方法" class="headerlink" title="7、ParameterMappingTokenHandler的handleToken方法"></a>7、ParameterMappingTokenHandler的handleToken方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String handleToken(String content) &#123;</span><br><span class="line">    parameterMappings.add(buildParameterMapping(content));</span><br><span class="line">    return &quot;?&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ParameterMappingTokenHandler的buildParameterMapping方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private ParameterMapping buildParameterMapping(String content) &#123;</span><br><span class="line">    //这里content可以是这样子的:#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125;  </span><br><span class="line">    //parseParameterMapping()就是把这种复杂的复杂解析成Map方式</span><br><span class="line">    Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);</span><br><span class="line">    String property = propertiesMap.get(&quot;property&quot;);</span><br><span class="line">    //解析参数的类型,String,int or boolean ...</span><br><span class="line">    Class&lt;?&gt; propertyType;</span><br><span class="line">    if (metaParameters.hasGetter(property)) &#123; // issue #448 get type from additional params</span><br><span class="line">        propertyType = metaParameters.getGetterType(property);</span><br><span class="line">    &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterType)) &#123;</span><br><span class="line">        propertyType = parameterType;</span><br><span class="line">    &#125; else if (JdbcType.CURSOR.name().equals(propertiesMap.get(&quot;jdbcType&quot;))) &#123;</span><br><span class="line">        propertyType = java.sql.ResultSet.class;</span><br><span class="line">    &#125; else if (property != null) &#123;</span><br><span class="line">        MetaClass metaClass = MetaClass.forClass(parameterType);</span><br><span class="line">        if (metaClass.hasGetter(property)) &#123;</span><br><span class="line">            propertyType = metaClass.getGetterType(property);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            propertyType = Object.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        propertyType = Object.class;</span><br><span class="line">    &#125;</span><br><span class="line">    //构建一个ParameterMapping对象，ParameterMapping描述的是java对象的属性与sql执行参数的对应关系。跟ResultMapping对象差不多</span><br><span class="line">    ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType);</span><br><span class="line">    Class&lt;?&gt; javaType = propertyType;</span><br><span class="line">    String typeHandlerAlias = null;</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) &#123;</span><br><span class="line">        String name = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        //示例:#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125;</span><br><span class="line">        if (&quot;javaType&quot;.equals(name)) &#123;</span><br><span class="line">            javaType = resolveClass(value);</span><br><span class="line">            builder.javaType(javaType);</span><br><span class="line">        &#125; else if (&quot;jdbcType&quot;.equals(name)) &#123;</span><br><span class="line">            builder.jdbcType(resolveJdbcType(value));</span><br><span class="line">        &#125; else if (&quot;mode&quot;.equals(name)) &#123;</span><br><span class="line">            builder.mode(resolveParameterMode(value));</span><br><span class="line">        &#125; else if (&quot;numericScale&quot;.equals(name)) &#123;</span><br><span class="line">            builder.numericScale(Integer.valueOf(value));</span><br><span class="line">        &#125; else if (&quot;resultMap&quot;.equals(name)) &#123;</span><br><span class="line">            builder.resultMapId(value);</span><br><span class="line">        &#125; else if (&quot;typeHandler&quot;.equals(name)) &#123;</span><br><span class="line">            typeHandlerAlias = value;</span><br><span class="line">        &#125; else if (&quot;jdbcTypeName&quot;.equals(name)) &#123;</span><br><span class="line">            builder.jdbcTypeName(value);</span><br><span class="line">        &#125; else if (&quot;property&quot;.equals(name)) &#123;</span><br><span class="line">            // Do Nothing</span><br><span class="line">        &#125; else if (&quot;expression&quot;.equals(name)) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Expression based parameters are not supported yet&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new BuilderException(&quot;An invalid property &apos;&quot; + name + &quot;&apos; was found in mapping #&#123;&quot; + content + &quot;&#125;.  Valid properties are &quot; + parameterProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeHandlerAlias != null) &#123;</span><br><span class="line">        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));</span><br><span class="line">    &#125;</span><br><span class="line">    return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、一级缓存处理过程"><a href="#四、一级缓存处理过程" class="headerlink" title="四、一级缓存处理过程"></a>四、一级缓存处理过程</h3><h4 id="1、接（三、2）BaseExecutor的createCacheKey方法"><a href="#1、接（三、2）BaseExecutor的createCacheKey方法" class="headerlink" title="1、接（三、2）BaseExecutor的createCacheKey方法"></a>1、接（三、2）BaseExecutor的createCacheKey方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    //创建缓存key</span><br><span class="line">    CacheKey cacheKey = new CacheKey();</span><br><span class="line">    //sql的id</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    //查询的开始条数</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    //查询的结束条数</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    //可执行的sql，不包含参数</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    if (parameterMappings.size() &gt; 0 &amp;&amp; parameterObject != null) &#123;</span><br><span class="line">        TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">        if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            //查询参数</span><br><span class="line">            cacheKey.update(parameterObject);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            for (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">                String propertyName = parameterMapping.getProperty();</span><br><span class="line">                if (metaObject.hasGetter(propertyName)) &#123;</span><br><span class="line">                    cacheKey.update(metaObject.getValue(propertyName));</span><br><span class="line">                &#125; else if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                    cacheKey.update(boundSql.getAdditionalParameter(propertyName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、接（三、2）BaseExecutor的query方法"><a href="#2、接（三、2）BaseExecutor的query方法" class="headerlink" title="2、接（三、2）BaseExecutor的query方法"></a>2、接（三、2）BaseExecutor的query方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, </span><br><span class="line">      BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</span><br><span class="line">    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    try &#123;</span><br><span class="line">        queryStack++;</span><br><span class="line">        //从缓存中取出数据</span><br><span class="line">        list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">        if (list != null) &#123;</span><br><span class="line">            //如果缓存中有数据，处理过程的缓存</span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果缓存中没有数据，将sql执行生成结果，并加入localCache中</span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (queryStack == 0) &#123;</span><br><span class="line">        for (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        deferredLoads.clear(); // issue #601</span><br><span class="line">        if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            //如果配置为STATEMENT时，将清除所有缓存。说明STATEMENT类型的查询只有queryFromDatabase方法中有效。</span><br><span class="line">            clearLocalCache(); // issue #482</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一级缓存的生命周期与SqlSession的生命周期一样。一级缓存是BaseExecutor中管理的，为PerpetualCache对象，对象有一个Map对象管理缓存数据。<br>一级缓存配置示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION|STATEMENT&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3、BaseExecutor的queryFromDatabase方法"><a href="#3、BaseExecutor的queryFromDatabase方法" class="headerlink" title="3、BaseExecutor的queryFromDatabase方法"></a>3、BaseExecutor的queryFromDatabase方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, </span><br><span class="line">      CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    try &#123;</span><br><span class="line">        //执行sql返回数据</span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    //将缓存加入到localCache中 </span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    if (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、获取数据库连接过程"><a href="#五、获取数据库连接过程" class="headerlink" title="五、获取数据库连接过程"></a>五、获取数据库连接过程</h3><h4 id="1、SimpleExecutor的doQuery方法"><a href="#1、SimpleExecutor的doQuery方法" class="headerlink" title="1、SimpleExecutor的doQuery方法"></a>1、SimpleExecutor的doQuery方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql </span><br><span class="line">      boundSql) throws SQLException &#123;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        //生成一个StatementHandler</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        //执行之前的准备</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        //执行sql </span><br><span class="line">        return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、SimpleExecutor的prepareStatement方法"><a href="#2、SimpleExecutor的prepareStatement方法" class="headerlink" title="2、SimpleExecutor的prepareStatement方法"></a>2、SimpleExecutor的prepareStatement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    //获取一个连接</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    //获取一个statement</span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    //设置执行参数</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、SimpleExecutor的getConnection方法"><a href="#3、SimpleExecutor的getConnection方法" class="headerlink" title="3、SimpleExecutor的getConnection方法"></a>3、SimpleExecutor的getConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected Connection getConnection(Log statementLog) throws SQLException &#123;</span><br><span class="line">    //获取连接</span><br><span class="line">    Connection connection = transaction.getConnection();</span><br><span class="line">    if (statementLog.isDebugEnabled()) &#123;</span><br><span class="line">        return ConnectionLogger.newInstance(connection, statementLog);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、JdbcTransaction的getConnection方法"><a href="#4、JdbcTransaction的getConnection方法" class="headerlink" title="4、JdbcTransaction的getConnection方法"></a>4、JdbcTransaction的getConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">    if (connection == null) &#123;</span><br><span class="line">        //获取连接</span><br><span class="line">        openConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void openConnection() throws SQLException &#123;</span><br><span class="line">    if (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(&quot;Opening JDBC Connection&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //从数据源中获取连接</span><br><span class="line">    connection = dataSource.getConnection();</span><br><span class="line">    if (level != null) &#123;</span><br><span class="line">        //设置事务级别</span><br><span class="line">        connection.setTransactionIsolation(level.getLevel());</span><br><span class="line">    &#125;</span><br><span class="line">    setDesiredAutoCommit(autoCommmit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、PooledDataSource的getConnection方法"><a href="#5、PooledDataSource的getConnection方法" class="headerlink" title="5、PooledDataSource的getConnection方法"></a>5、PooledDataSource的getConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">private PooledConnection popConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">    boolean countedWait = false;</span><br><span class="line">    //封装后的连接</span><br><span class="line">    PooledConnection conn = null;</span><br><span class="line">    long t = System.currentTimeMillis();</span><br><span class="line">    //无效连接个数</span><br><span class="line">    int localBadConnectionCount = 0;</span><br><span class="line">    while (conn == null) &#123;</span><br><span class="line">        synchronized (state) &#123;</span><br><span class="line">            if (state.idleConnections.size() &gt; 0) &#123;</span><br><span class="line">                //连接池有空闲的连接</span><br><span class="line">                //获取该连接</span><br><span class="line">                conn = state.idleConnections.remove(0);</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //连接池没有空闲连接，</span><br><span class="line">                if (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">                    //正在使用的连接数量小于最大数量</span><br><span class="line">                    //创建一个连接，实际连接是UnpooledDataSource的getConnection方法获取的</span><br><span class="line">                    conn = new PooledConnection(dataSource.getConnection(), this);</span><br><span class="line">                    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">                    //used in logging, if enabled</span><br><span class="line">                    Connection realConn = conn.getRealConnection();</span><br><span class="line">                    if (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //正在使用的连接数量大于等于最大数量</span><br><span class="line">                    // Cannot create new connection</span><br><span class="line">                    PooledConnection oldestActiveConnection = state.activeConnections.get(0);</span><br><span class="line">                    //获取连接闲置时间</span><br><span class="line">                    long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">                    if (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">                        //连接闲置时间大于最大时间20秒</span><br><span class="line">                        //收回过期连接数加一</span><br><span class="line">                        state.claimedOverdueConnectionCount++;</span><br><span class="line">                        //连接闲置总时间</span><br><span class="line">                        state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">                        state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">                        //回收该连接</span><br><span class="line">                        state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">                        //回滚该链接未提交事务</span><br><span class="line">                        if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                            oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                        &#125;</span><br><span class="line">                        //重新封装一个连接</span><br><span class="line">                        conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);</span><br><span class="line">                        //旧连接失效</span><br><span class="line">                        oldestActiveConnection.invalidate();</span><br><span class="line">                        if (log.isDebugEnabled()) &#123;</span><br><span class="line">                            log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 连接闲置时间小于最大时间20秒</span><br><span class="line">                        // 无连接可用，必须等待</span><br><span class="line">                        try &#123;</span><br><span class="line">                            //等待次数加一</span><br><span class="line">                            if (!countedWait) &#123;</span><br><span class="line">                                state.hadToWaitCount++;</span><br><span class="line">                                countedWait = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                                log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            long wt = System.currentTimeMillis();</span><br><span class="line">                            //等待最多20秒</span><br><span class="line">                            state.wait(poolTimeToWait);</span><br><span class="line">                            //等待总时间</span><br><span class="line">                            state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                if (conn.isValid()) &#123;</span><br><span class="line">                    //连接有效</span><br><span class="line">                    //回滚未提交事务</span><br><span class="line">                    if (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                        conn.getRealConnection().rollback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">                    //跟新连接的最后使用时间</span><br><span class="line">                    conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">                    conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">                    //连接加入正在使用集合</span><br><span class="line">                    state.activeConnections.add(conn);</span><br><span class="line">                    //请求次数加一</span><br><span class="line">                    state.requestCount++;</span><br><span class="line">                    //累计请求时间</span><br><span class="line">                    state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //连接无效</span><br><span class="line">                    if (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another </span><br><span class="line">                              connection.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //无效链接个数</span><br><span class="line">                    state.badConnectionCount++;</span><br><span class="line">                    localBadConnectionCount++;</span><br><span class="line">                    conn = null;</span><br><span class="line">                    //无效连接超过一定数量，抛出异常</span><br><span class="line">                    if (localBadConnectionCount &gt; (poolMaximumIdleConnections + 3)) &#123;</span><br><span class="line">                        if (log.isDebugEnabled()) &#123;</span><br><span class="line">                            log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (conn == null) &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、UnpooledDataSource的getConnection方法"><a href="#6、UnpooledDataSource的getConnection方法" class="headerlink" title="6、UnpooledDataSource的getConnection方法"></a>6、UnpooledDataSource的getConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">    return doGetConnection(username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Connection doGetConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">    Properties props = new Properties();</span><br><span class="line">    if (driverProperties != null) &#123;</span><br><span class="line">        props.putAll(driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    if (username != null) &#123;</span><br><span class="line">        props.setProperty(&quot;user&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password != null) &#123;</span><br><span class="line">        props.setProperty(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    return doGetConnection(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Connection doGetConnection(Properties properties) throws SQLException &#123;</span><br><span class="line">    //初始化数据库驱动</span><br><span class="line">    initializeDriver();</span><br><span class="line">    //获取实际的数据库连接</span><br><span class="line">    Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">    //配置是否自动提交，以及隔离级别</span><br><span class="line">    configureConnection(connection);</span><br><span class="line">    return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、sql执行预处理过程"><a href="#六、sql执行预处理过程" class="headerlink" title="六、sql执行预处理过程"></a>六、sql执行预处理过程</h3><h4 id="1、接（五、2）RoutingStatementHandler的prepare方法"><a href="#1、接（五、2）RoutingStatementHandler的prepare方法" class="headerlink" title="1、接（五、2）RoutingStatementHandler的prepare方法"></a>1、接（五、2）RoutingStatementHandler的prepare方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Statement prepare(Connection connection) throws SQLException &#123;</span><br><span class="line">    //调的是PreparedStatementHandler的prepare方法</span><br><span class="line">    return delegate.prepare(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、实例化的PreparedStatementHandler"><a href="#2、实例化的PreparedStatementHandler" class="headerlink" title="2、实例化的PreparedStatementHandler"></a>2、实例化的PreparedStatementHandler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PreparedStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler </span><br><span class="line">      resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    super(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler </span><br><span class="line">        resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">      this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">      this.executor = executor;</span><br><span class="line">      this.mappedStatement = mappedStatement;</span><br><span class="line">      this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">      this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">      this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">      if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">          //生成主键，没有则是NoKeyGenerator</span><br><span class="line">          generateKeys(parameterObject);</span><br><span class="line">          boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">      &#125;</span><br><span class="line">      this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">      //创建参数处理器DefaultParameterHandler</span><br><span class="line">      this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">      //创建查询结果处理器DefaultResultSetHandler</span><br><span class="line">      this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、接（六、1）BaseStatementHandler的prepare方法"><a href="#3、接（六、1）BaseStatementHandler的prepare方法" class="headerlink" title="3、接（六、1）BaseStatementHandler的prepare方法"></a>3、接（六、1）BaseStatementHandler的prepare方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Statement prepare(Connection connection) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //预处理</span><br><span class="line">        statement = instantiateStatement(connection);</span><br><span class="line">        //设置超时时间</span><br><span class="line">        setStatementTimeout(statement);</span><br><span class="line">        //设置查询条数</span><br><span class="line">        setFetchSize(statement);</span><br><span class="line">        return statement;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        throw new ExecutorException(&quot;Error preparing statement.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、PreparedStatementHandler的instantiateStatement方法"><a href="#4、PreparedStatementHandler的instantiateStatement方法" class="headerlink" title="4、PreparedStatementHandler的instantiateStatement方法"></a>4、PreparedStatementHandler的instantiateStatement方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected Statement instantiateStatement(Connection connection) throws SQLException &#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    //key生成器为Jdbc3KeyGenerator</span><br><span class="line">    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) &#123;</span><br><span class="line">        //生成的key对应的属性名</span><br><span class="line">        String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">        if (keyColumnNames == null) &#123;</span><br><span class="line">            //执行预编译</span><br><span class="line">            return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //执行预编译</span><br><span class="line">            return connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mappedStatement.getResultSetType() != null) &#123;</span><br><span class="line">        return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（五、2）RoutingStatementHandler的parameterize方法"><a href="#5、接（五、2）RoutingStatementHandler的parameterize方法" class="headerlink" title="5、接（五、2）RoutingStatementHandler的parameterize方法"></a>5、接（五、2）RoutingStatementHandler的parameterize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、PreparedStatementHandler的parameterize方法"><a href="#6、PreparedStatementHandler的parameterize方法" class="headerlink" title="6、PreparedStatementHandler的parameterize方法"></a>6、PreparedStatementHandler的parameterize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、DefaultParameterHandler的setParameters"><a href="#7、DefaultParameterHandler的setParameters" class="headerlink" title="7、DefaultParameterHandler的setParameters"></a>7、DefaultParameterHandler的setParameters</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void setParameters(PreparedStatement ps) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    //参数集合</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    if (parameterMappings != null) &#123;</span><br><span class="line">        MetaObject metaObject = parameterObject == null ? null : configuration.newMetaObject(parameterObject);</span><br><span class="line">        for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">            ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">            if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                Object value;</span><br><span class="line">                //参数属性名</span><br><span class="line">                String propertyName = parameterMapping.getProperty();</span><br><span class="line">                if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params</span><br><span class="line">                    value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                &#125; else if (parameterObject == null) &#123;</span><br><span class="line">                    value = null;</span><br><span class="line">                &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                    //参数值</span><br><span class="line">                    value = parameterObject;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value = metaObject == null ? null : metaObject.getValue(propertyName);</span><br><span class="line">                &#125;</span><br><span class="line">                TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                if (value == null &amp;&amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                //往ps中设置参数</span><br><span class="line">                typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、查询结果集映射"><a href="#七、查询结果集映射" class="headerlink" title="七、查询结果集映射"></a>七、查询结果集映射</h3><h4 id="1、接（五、1）RoutingStatementHandler的query方法"><a href="#1、接（五、1）RoutingStatementHandler的query方法" class="headerlink" title="1、接（五、1）RoutingStatementHandler的query方法"></a>1、接（五、1）RoutingStatementHandler的query方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    return delegate.&lt;E&gt;query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、PreparedStatementHandler的query方法"><a href="#2、PreparedStatementHandler的query方法" class="headerlink" title="2、PreparedStatementHandler的query方法"></a>2、PreparedStatementHandler的query方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、DefaultResultSetHandler的handleResultSets方法"><a href="#3、DefaultResultSetHandler的handleResultSets方法" class="headerlink" title="3、DefaultResultSetHandler的handleResultSets方法"></a>3、DefaultResultSetHandler的handleResultSets方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount = 0;</span><br><span class="line">    //获取第一个ResultSet,通常只会有一个</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">    //从配置中读取对应的ResultMap，通常也只会有一个</span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line"></span><br><span class="line">    int resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        //依次获取resultMap</span><br><span class="line">        ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">        //完成映射，将结果加到入multipleResults中</span><br><span class="line">        handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">        //获取下一个ResultSet</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        //下一个ResultSet</span><br><span class="line">        resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (rsw != null &amp;&amp; resultSetCount &lt; mappedStatement.getResulSets().length) &#123;</span><br><span class="line">            ResultMapping parentMapping = nextResultMaps.get(mappedStatement.getResulSets()[resultSetCount]);</span><br><span class="line">            if (parentMapping != null) &#123;</span><br><span class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">                ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">            &#125;</span><br><span class="line">            rsw = getNextResultSet(stmt);</span><br><span class="line">            cleanUpAfterHandlingResultSet();</span><br><span class="line">            resultSetCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    //如果只有一个映射，返回第一个</span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理某一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) </span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (parentMapping != null) &#123;</span><br><span class="line">            //子映射</span><br><span class="line">            handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //一般情况resultHandler都为空,见ResultHandler.NO_RESULT_HANDLER</span><br><span class="line">            if (resultHandler == null) &#123;</span><br><span class="line">                DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);</span><br><span class="line">                //生成对象，并加到defaultResultHandler.resultList集合中</span><br><span class="line">                handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span><br><span class="line">                //将结果加入multipleResults中</span><br><span class="line">                multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭结果集</span><br><span class="line">        closeResultSet(rsw.getResultSet()); // issue #228 (close resultsets)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、DefaultResultSetHandler的handleRowValues方法"><a href="#4、DefaultResultSetHandler的handleRowValues方法" class="headerlink" title="4、DefaultResultSetHandler的handleRowValues方法"></a>4、DefaultResultSetHandler的handleRowValues方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping </span><br><span class="line">      parentMapping) throws SQLException &#123;</span><br><span class="line">    if (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">        //有子映射或内映射的情况</span><br><span class="line">        ensureNoRowBounds();</span><br><span class="line">        checkResultHandler();</span><br><span class="line">        handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //没有子映射或内映射</span><br><span class="line">        handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、DefaultResultSetHandler的handleRowValuesForSimpleResultMap方法"><a href="#5、DefaultResultSetHandler的handleRowValuesForSimpleResultMap方法" class="headerlink" title="5、DefaultResultSetHandler的handleRowValuesForSimpleResultMap方法"></a>5、DefaultResultSetHandler的handleRowValuesForSimpleResultMap方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds </span><br><span class="line">      rowBounds, ResultMapping parentMapping)throws SQLException &#123;</span><br><span class="line">    DefaultResultContext resultContext = new DefaultResultContext();</span><br><span class="line">    //跳过结果集前排行，直到查询开始位置，开始处理</span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    //依次处理待处理的行</span><br><span class="line">    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) &#123;</span><br><span class="line">        //默认不处理返回resultMap</span><br><span class="line">        ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);</span><br><span class="line">        //真正从ResultSet中映射出一个对象  </span><br><span class="line">        Object rowValue = getRowValue(rsw, discriminatedResultMap, null);</span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、DefaultResultSetHandler的getRowValue方法"><a href="#6、DefaultResultSetHandler的getRowValue方法" class="headerlink" title="6、DefaultResultSetHandler的getRowValue方法"></a>6、DefaultResultSetHandler的getRowValue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey rowKey) throws SQLException &#123;</span><br><span class="line">    final ResultLoaderMap lazyLoader = instantiateResultLoaderMap();</span><br><span class="line">    //实例化一个对象,类型为resultMap.getType(),最终调用了ObjectFactory.create()方法</span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null);</span><br><span class="line">    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">        //设置对象属性 </span><br><span class="line">        final MetaObject metaObject = configuration.newMetaObject(resultObject);</span><br><span class="line">        boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;</span><br><span class="line">        if (shouldApplyAutomaticMappings(resultMap, !AutoMappingBehavior.NONE.equals(configuration.getAutoMappingBehavior()))) &#123;  </span><br><span class="line">            //自动映射,结果集中有的column，但resultMap中并没有配置      </span><br><span class="line">            foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues;</span><br><span class="line">        &#125;</span><br><span class="line">        //映射result节点</span><br><span class="line">        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues;</span><br><span class="line">        foundValues = (lazyLoader != null &amp;&amp; lazyLoader.size() &gt; 0) || foundValues;</span><br><span class="line">        resultObject = foundValues ? resultObject : null;</span><br><span class="line">        return resultObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、DefaultResultSetHandler的createResultObject方法"><a href="#7、DefaultResultSetHandler的createResultObject方法" class="headerlink" title="7、DefaultResultSetHandler的createResultObject方法"></a>7、DefaultResultSetHandler的createResultObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws</span><br><span class="line">       SQLException &#123;</span><br><span class="line">    //构造方法中的参数类型  </span><br><span class="line">    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    //构造方法中具体值 </span><br><span class="line">    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();</span><br><span class="line">    //根据构造方法生成对象  </span><br><span class="line">    final Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    if (resultObject != null &amp;&amp; configuration.isLazyLoadingEnabled() &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">        final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">        for (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">            //如果有子查询</span><br><span class="line">            if (propertyMapping.getNestedQueryId() != null) &#123; // issue #109 (avoid creating proxies for leaf objects)</span><br><span class="line">                //CglibProxyFactory给返回对象创建代理</span><br><span class="line">                return proxyFactory.createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    //结果集中配置的返回类</span><br><span class="line">    final Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">    //resultMap配置中的construnctor节点 </span><br><span class="line">    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line">    if (typeHandlerRegistry.hasTypeHandler(resultType)) &#123;</span><br><span class="line">        return createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; else if (constructorMappings.size() &gt; 0) &#123;</span><br><span class="line">        //construnctor节点有配置 </span><br><span class="line">        return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //construnctor节点没有配置，调用无参的构造方法  </span><br><span class="line">        return objectFactory.create(resultType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、DefaultResultSetHandler的createPrimitiveResultObject方法"><a href="#8、DefaultResultSetHandler的createPrimitiveResultObject方法" class="headerlink" title="8、DefaultResultSetHandler的createPrimitiveResultObject方法"></a>8、DefaultResultSetHandler的createPrimitiveResultObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private Object createParameterizedResultObject(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; constructorMappings,</span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    for (ResultMapping constructorMapping : constructorMappings) &#123;</span><br><span class="line">        final Class&lt;?&gt; parameterType = constructorMapping.getJavaType();</span><br><span class="line">        final String column = constructorMapping.getColumn();</span><br><span class="line">        final Object value;</span><br><span class="line">        //取出参数类型和具体的值</span><br><span class="line">        if (constructorMapping.getNestedQueryId() != null) &#123;</span><br><span class="line">            value = getNestedQueryConstructorValue(rsw.getResultSet(), constructorMapping, columnPrefix);</span><br><span class="line">        &#125; else if (constructorMapping.getNestedResultMapId() != null) &#123;</span><br><span class="line">            final ResultMap resultMap = configuration.getResultMap(constructorMapping.getNestedResultMapId());</span><br><span class="line">            final ResultLoaderMap lazyLoader = instantiateResultLoaderMap();</span><br><span class="line">            value = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final TypeHandler&lt;?&gt; typeHandler = constructorMapping.getTypeHandler();</span><br><span class="line">            //从结果集中获取该属性对应的查询结果</span><br><span class="line">            value = typeHandler.getResult(rsw.getResultSet(), prependPrefix(column, columnPrefix));</span><br><span class="line">        &#125;</span><br><span class="line">        //构造器参数类型</span><br><span class="line">        constructorArgTypes.add(parameterType);</span><br><span class="line">        //构造器参数值</span><br><span class="line">        constructorArgs.add(value);</span><br><span class="line">        foundValues = value != null || foundValues;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建对象 </span><br><span class="line">    return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、接（七、7）CglibProxyFactory的createProxy方法"><a href="#9、接（七、7）CglibProxyFactory的createProxy方法" class="headerlink" title="9、接（七、7）CglibProxyFactory的createProxy方法"></a>9、接（七、7）CglibProxyFactory的createProxy方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object createProxy(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory,</span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123;</span><br><span class="line">    return EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、EnhancedResultObjectProxyImpl的createProxy方法"><a href="#10、EnhancedResultObjectProxyImpl的createProxy方法" class="headerlink" title="10、EnhancedResultObjectProxyImpl的createProxy方法"></a>10、EnhancedResultObjectProxyImpl的createProxy方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static Object createProxy(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, </span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123;</span><br><span class="line">    //被代理对象的类</span><br><span class="line">    final Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    //创建回调</span><br><span class="line">    EnhancedResultObjectProxyImpl callback = new EnhancedResultObjectProxyImpl(type, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">    //创建代理对象</span><br><span class="line">    Object enhanced = crateProxy(type, callback, constructorArgTypes, constructorArgs);</span><br><span class="line">    //target是type的初始化对象  </span><br><span class="line">    //enhanced可能是type的代理对象  </span><br><span class="line">    //将target对象的值赋值到enhanced，包括父类的字段赋值</span><br><span class="line">    PropertyCopier.copyBeanProperties(type, target, enhanced);</span><br><span class="line">    //返回代理enhanced </span><br><span class="line">    return enhanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、CglibProxyFactory的createProxy方法"><a href="#11、CglibProxyFactory的createProxy方法" class="headerlink" title="11、CglibProxyFactory的createProxy方法"></a>11、CglibProxyFactory的createProxy方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static Object crateProxy(Class&lt;?&gt; type, Callback callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123;</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    //设置回调</span><br><span class="line">    enhancer.setCallback(callback);</span><br><span class="line">    //继承被代理的类</span><br><span class="line">    enhancer.setSuperclass(type);</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取目标类型的 writeReplace 方法，如果没有，异常中代理类设置enhancer.setInterfaces(new Class[]&#123;WriteReplaceInterface.class&#125;)</span><br><span class="line">        type.getDeclaredMethod(WRITE_REPLACE_METHOD);</span><br><span class="line">        // ObjectOutputStream will call writeReplace of objects returned by writeReplace</span><br><span class="line">        log.debug(WRITE_REPLACE_METHOD + &quot; method was found on bean &quot; + type + &quot;, make sure it returns this&quot;);</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        enhancer.setInterfaces(new Class[]&#123;WriteReplaceInterface.class&#125;);</span><br><span class="line">    &#125; catch (SecurityException e) &#123;</span><br><span class="line">        // nothing to do here</span><br><span class="line">    &#125;</span><br><span class="line">    Object enhanced = null;</span><br><span class="line">    if (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">        //如果构造函数没有参数，创建代理对象</span><br><span class="line">        enhanced = enhancer.create();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //否则，初始化带有参数的构造函数</span><br><span class="line">        Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(new Class[constructorArgTypes.size()]);</span><br><span class="line">        Object[] valuesArray = constructorArgs.toArray(new Object[constructorArgs.size()]);</span><br><span class="line">        //创建带有参数的代理对象</span><br><span class="line">        enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return enhanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、BaseTypeHandler的getResult方法"><a href="#12、BaseTypeHandler的getResult方法" class="headerlink" title="12、BaseTypeHandler的getResult方法"></a>12、BaseTypeHandler的getResult方法</h4><p>typeHandler以StringTypeHandler为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public T getResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">    T result = getNullableResult(rs, columnName);</span><br><span class="line">    if (rs.wasNull()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="13、StringTypeHandler的getNullableResult方法"><a href="#13、StringTypeHandler的getNullableResult方法" class="headerlink" title="13、StringTypeHandler的getNullableResult方法"></a>13、StringTypeHandler的getNullableResult方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123;</span><br><span class="line">    //获取该字段对应的值</span><br><span class="line">    return rs.getString(columnName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、接（七、6）DefaultResultSetHandler的applyAutomaticMappings方法"><a href="#14、接（七、6）DefaultResultSetHandler的applyAutomaticMappings方法" class="headerlink" title="14、接（七、6）DefaultResultSetHandler的applyAutomaticMappings方法"></a>14、接（七、6）DefaultResultSetHandler的applyAutomaticMappings方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) </span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    //获取结果集中在resultMap中没有配置的列名  </span><br><span class="line">    //如果resultMap中只设置了resultType=&quot;java.util.HashMap&quot;的话，全都会在这里完成映射 </span><br><span class="line">    final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    for (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">        //属性名就是列名</span><br><span class="line">        String propertyName = columnName;</span><br><span class="line">        if (columnPrefix != null &amp;&amp; columnPrefix.length() &gt; 0) &#123;</span><br><span class="line">            // When columnPrefix is specified,</span><br><span class="line">            // ignore columns without the prefix.</span><br><span class="line">            if (columnName.startsWith(columnPrefix)) &#123;</span><br><span class="line">                propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //是否有对应的属性</span><br><span class="line">        final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">        if (property != null &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">            final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">            if (typeHandlerRegistry.hasTypeHandler(propertyType)) &#123;</span><br><span class="line">                final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">                //获取该字段对应的值</span><br><span class="line">                final Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span><br><span class="line">                if (value != null || configuration.isCallSettersOnNulls()) &#123; // issue #377, call setter on nulls</span><br><span class="line">                    if (value != null || !propertyType.isPrimitive()) &#123;</span><br><span class="line">                        //直接设置</span><br><span class="line">                        metaObject.setValue(property, value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    foundValues = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、接（七、6）DefaultResultSetHandler的applyPropertyMappings方法"><a href="#15、接（七、6）DefaultResultSetHandler的applyPropertyMappings方法" class="headerlink" title="15、接（七、6）DefaultResultSetHandler的applyPropertyMappings方法"></a>15、接（七、6）DefaultResultSetHandler的applyPropertyMappings方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, </span><br><span class="line">      String columnPrefix) throws SQLException &#123;</span><br><span class="line">    //有resultMap中配置过的字段名</span><br><span class="line">    final List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    //获取需要映射的ResultMapping</span><br><span class="line">    final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">    for (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">        final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        if (propertyMapping.isCompositeResult() </span><br><span class="line">              || (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) </span><br><span class="line">              || propertyMapping.getResultSet() != null) &#123;</span><br><span class="line">            //在结果中的获取对应的值</span><br><span class="line">            Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">            //获取属性名</span><br><span class="line">            final String property = propertyMapping.getProperty(); // issue #541 make property optional</span><br><span class="line">            if (value != NO_VALUE &amp;&amp; property != null &amp;&amp; (value != null || configuration.isCallSettersOnNulls())) &#123; </span><br><span class="line">                if (value != null || !metaObject.getSetterType(property).isPrimitive()) &#123;</span><br><span class="line">                    //设置属性值</span><br><span class="line">                    metaObject.setValue(property, value);</span><br><span class="line">                &#125;</span><br><span class="line">                foundValues = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16、DefaultResultSetHandler的getPropertyMappingValue方法"><a href="#16、DefaultResultSetHandler的getPropertyMappingValue方法" class="headerlink" title="16、DefaultResultSetHandler的getPropertyMappingValue方法"></a>16、DefaultResultSetHandler的getPropertyMappingValue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, </span><br><span class="line">          ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    if (propertyMapping.getNestedQueryId() != null) &#123;</span><br><span class="line">        //子查询</span><br><span class="line">        return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    &#125; else if (propertyMapping.getResultSet() != null) &#123;</span><br><span class="line">        addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">        return NO_VALUE;</span><br><span class="line">    &#125; else if (propertyMapping.getNestedResultMapId() != null) &#123;</span><br><span class="line">        // the user added a column attribute to a nested result map, ignore it</span><br><span class="line">        return NO_VALUE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">        final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        //直接从结果集里获取值</span><br><span class="line">        return typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、DefaultResultSetHandler的getNestedQueryMappingValue方法"><a href="#17、DefaultResultSetHandler的getNestedQueryMappingValue方法" class="headerlink" title="17、DefaultResultSetHandler的getNestedQueryMappingValue方法"></a>17、DefaultResultSetHandler的getNestedQueryMappingValue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private Object getNestedQueryMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,</span><br><span class="line">      ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    //获取子查询id</span><br><span class="line">    final String nestedQueryId = propertyMapping.getNestedQueryId();</span><br><span class="line">    //获取属性名</span><br><span class="line">    final String property = propertyMapping.getProperty();</span><br><span class="line">    //子查询sql</span><br><span class="line">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span><br><span class="line">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span><br><span class="line">    //预处理子查询参数，从查询结果中取出column对应的值作为参数</span><br><span class="line">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span><br><span class="line">    Object value = NO_VALUE;</span><br><span class="line">    if (nestedQueryParameterObject != null) &#123;</span><br><span class="line">        //获取BoundSql</span><br><span class="line">        final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span><br><span class="line">        //缓存key</span><br><span class="line">        final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span><br><span class="line">        //属性类型</span><br><span class="line">        final Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span><br><span class="line">        //从二级缓存中获取缓存值</span><br><span class="line">        final List&lt;Object&gt; nestedQueryCacheObject = getNestedQueryCacheObject(nestedQuery, key);</span><br><span class="line">        if (nestedQueryCacheObject != null) &#123;</span><br><span class="line">            //从缓存中获取值</span><br><span class="line">            value = resultExtractor.extractObjectFromList(nestedQueryCacheObject, targetType);</span><br><span class="line">        &#125; else if (executor.isCached(nestedQuery, key)) &#123;</span><br><span class="line">            //一级缓存存在，从一级缓存中获取值</span><br><span class="line">            executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span><br><span class="line">            if (configuration.isLazyLoadingEnabled()) &#123;</span><br><span class="line">                //开启懒加载，创建一个LoadPair对象加入loaderMap中，key为属性名</span><br><span class="line">                lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //未开启懒加载，立即执行子查询</span><br><span class="line">                value = resultLoader.loadResult();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、接（七、5）DefaultResultSetHandler的storeObject方法"><a href="#18、接（七、5）DefaultResultSetHandler的storeObject方法" class="headerlink" title="18、接（七、5）DefaultResultSetHandler的storeObject方法"></a>18、接（七、5）DefaultResultSetHandler的storeObject方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void storeObject(ResultHandler resultHandler, DefaultResultContext resultContext, Object rowValue, ResultMapping parentMapping, </span><br><span class="line">    ResultSet rs) throws SQLException &#123;</span><br><span class="line">    if (parentMapping != null) &#123;</span><br><span class="line">        linkToParent(rs, parentMapping, rowValue);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //将查询出的对象加入返回集合</span><br><span class="line">        callResultHandler(resultHandler, resultContext, rowValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19、DefaultResultHandler的callResultHandler方法"><a href="#19、DefaultResultHandler的callResultHandler方法" class="headerlink" title="19、DefaultResultHandler的callResultHandler方法"></a>19、DefaultResultHandler的callResultHandler方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void callResultHandler(ResultHandler resultHandler, DefaultResultContext resultContext, Object rowValue) &#123;</span><br><span class="line">    //rowValue加入DefaultResultContext中</span><br><span class="line">    resultContext.nextResultObject(rowValue);</span><br><span class="line">    //DefaultResultHandler把rowValue加入DefaultResultHandler的List集合</span><br><span class="line">    resultHandler.handleResult(resultContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20、接（七、4）DefaultResultSetHandler的handleRowValuesForNestedResultMap方法"><a href="#20、接（七、4）DefaultResultSetHandler的handleRowValuesForNestedResultMap方法" class="headerlink" title="20、接（七、4）DefaultResultSetHandler的handleRowValuesForNestedResultMap方法"></a>20、接（七、4）DefaultResultSetHandler的handleRowValuesForNestedResultMap方法</h4><p>处理有内部映射的复杂映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler,</span><br><span class="line">      RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    final DefaultResultContext resultContext = new DefaultResultContext();</span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    Object rowValue = null;</span><br><span class="line">    while (shouldProcessMoreRows(rsw.getResultSet(), resultContext, rowBounds)) &#123;</span><br><span class="line">        final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);</span><br><span class="line">        //为这行记录生成一个key,createRowKey方法会利用idResultMapping(即idArg,和id节点)和resultMap的id来生成key</span><br><span class="line">        final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);</span><br><span class="line">        //nestedResultObjects是一个HashMap对象，在映射过程中所有生成的映射对象(包括内映射对象)，都会生成一个key并保存在这里</span><br><span class="line">        Object partialObject = nestedResultObjects.get(rowKey);</span><br><span class="line">        if (mappedStatement.isResultOrdered()) &#123; // issue #577 &amp;&amp; #542</span><br><span class="line">            if (partialObject == null &amp;&amp; rowValue != null) &#123;</span><br><span class="line">                nestedResultObjects.clear();</span><br><span class="line">                storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">            &#125;</span><br><span class="line">            rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //这个方法把结果集的记录映射成java对象</span><br><span class="line">            rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, rowKey, null, partialObject);</span><br><span class="line">            if (partialObject == null) &#123;</span><br><span class="line">                storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered()) &#123;</span><br><span class="line">      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="21、DefaultResultSetHandler的createRowKey方法"><a href="#21、DefaultResultSetHandler的createRowKey方法" class="headerlink" title="21、DefaultResultSetHandler的createRowKey方法"></a>21、DefaultResultSetHandler的createRowKey方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private CacheKey createRowKey(ResultMap resultMap, ResultSetWrapper rsw, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    final CacheKey cacheKey = new CacheKey();</span><br><span class="line">    //加入resultmap的id</span><br><span class="line">    cacheKey.update(resultMap.getId());</span><br><span class="line">    //有id则获取id映射，没有则获取所有映射</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = getResultMappingsForRowKey(resultMap);</span><br><span class="line">    if (resultMappings.size() == 0) &#123;</span><br><span class="line">        if (Map.class.isAssignableFrom(resultMap.getType())) &#123;</span><br><span class="line">            createRowKeyForMap(rsw, cacheKey);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            createRowKeyForUnmappedProperties(resultMap, rsw, cacheKey, columnPrefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //将resultMappings的字段名和值，依次放入cacheKey</span><br><span class="line">        createRowKeyForMappedProperties(resultMap, rsw, cacheKey, resultMappings, columnPrefix);</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22、DefaultResultSetHandler的createRowKeyForMappedProperties方法"><a href="#22、DefaultResultSetHandler的createRowKeyForMappedProperties方法" class="headerlink" title="22、DefaultResultSetHandler的createRowKeyForMappedProperties方法"></a>22、DefaultResultSetHandler的createRowKeyForMappedProperties方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void createRowKeyForMappedProperties(ResultMap resultMap, ResultSetWrapper rsw, CacheKey cacheKey, </span><br><span class="line">      List&lt;ResultMapping&gt; resultMappings, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    for (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">        if (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null) &#123; // Issue #392</span><br><span class="line">            //该映射是一个内映射</span><br><span class="line">            final ResultMap nestedResultMap = configuration.getResultMap(resultMapping.getNestedResultMapId());</span><br><span class="line">            //递归调用本方法处理内映射</span><br><span class="line">            createRowKeyForMappedProperties(nestedResultMap, rsw, cacheKey, nestedResultMap.getConstructorResultMappings(),</span><br><span class="line">            prependPrefix(resultMapping.getColumnPrefix(), columnPrefix));</span><br><span class="line">        &#125; else if (resultMapping.getNestedQueryId() == null) &#123;</span><br><span class="line">            //该映射为属性映射</span><br><span class="line">            final String column = prependPrefix(resultMapping.getColumn(), columnPrefix);</span><br><span class="line">            final TypeHandler&lt;?&gt; th = resultMapping.getTypeHandler();</span><br><span class="line">            List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">            if (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) &#123; // Issue #114</span><br><span class="line">                //获取该字段对应的值</span><br><span class="line">                final Object value = th.getResult(rsw.getResultSet(), column);</span><br><span class="line">                if (value != null) &#123;</span><br><span class="line">                    //将字段名和值，加载进cacheKey</span><br><span class="line">                    cacheKey.update(column);</span><br><span class="line">                    cacheKey.update(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23、接（七、20）DefaultResultSetHandler的getRowValue方法"><a href="#23、接（七、20）DefaultResultSetHandler的getRowValue方法" class="headerlink" title="23、接（七、20）DefaultResultSetHandler的getRowValue方法"></a>23、接（七、20）DefaultResultSetHandler的getRowValue方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, CacheKey absoluteKey, String columnPrefix, </span><br><span class="line">      Object partialObject) throws SQLException &#123;</span><br><span class="line">    Object resultObject = partialObject;</span><br><span class="line">    if (resultObject != null) &#123;</span><br><span class="line">        //缓存中获取的对象不为空</span><br><span class="line">        final MetaObject metaObject = configuration.newMetaObject(resultObject);</span><br><span class="line">        ancestorObjects.put(absoluteKey, resultObject);</span><br><span class="line">        //处理内映射</span><br><span class="line">        applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);</span><br><span class="line">        ancestorObjects.remove(absoluteKey);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //缓存中获取的对象为空</span><br><span class="line">        //懒加载模式则返回ResultLoaderMap对象，否则返回null</span><br><span class="line">        final ResultLoaderMap lazyLoader = instantiateResultLoaderMap();</span><br><span class="line">        //创建返回的对象与（七、7）相同</span><br><span class="line">        resultObject = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">        if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">            final MetaObject metaObject = configuration.newMetaObject(resultObject);</span><br><span class="line">            boolean foundValues = resultMap.getConstructorResultMappings().size() &gt; 0;</span><br><span class="line">            if (shouldApplyAutomaticMappings(resultMap, AutoMappingBehavior.FULL.equals(configuration.getAutoMappingBehavior()))) &#123;</span><br><span class="line">                //自动映射，跟简单映射的处理方式一样,跟简单映射的处理方式一样</span><br><span class="line">                foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">            &#125;</span><br><span class="line">            //映射reulstMap节点，跟简单映射的处理方式一样,跟简单映射的处理方式一样        </span><br><span class="line">            foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">            ancestorObjects.put(absoluteKey, resultObject);</span><br><span class="line">            //处理内映射</span><br><span class="line">            foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;</span><br><span class="line">            ancestorObjects.remove(absoluteKey);</span><br><span class="line">            //取到对象的值，或者懒加载开启，都返回true</span><br><span class="line">            foundValues = (lazyLoader != null &amp;&amp; lazyLoader.size() &gt; 0) || foundValues;</span><br><span class="line">            resultObject = foundValues ? resultObject : null;</span><br><span class="line">        &#125;</span><br><span class="line">        //对象加入缓存</span><br><span class="line">        if (combinedKey != CacheKey.NULL_CACHE_KEY) nestedResultObjects.put(combinedKey, resultObject);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24、DefaultResultSetHandler的applyNestedResultMappings方法"><a href="#24、DefaultResultSetHandler的applyNestedResultMappings方法" class="headerlink" title="24、DefaultResultSetHandler的applyNestedResultMappings方法"></a>24、DefaultResultSetHandler的applyNestedResultMappings方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private boolean applyNestedResultMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String parentPrefix, </span><br><span class="line">      CacheKey parentRowKey, boolean newObject) &#123;</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    for (ResultMapping resultMapping : resultMap.getPropertyResultMappings()) &#123;</span><br><span class="line">        //获取子ResultMapId</span><br><span class="line">        final String nestedResultMapId = resultMapping.getNestedResultMapId();</span><br><span class="line">        if (nestedResultMapId != null &amp;&amp; resultMapping.getResultSet() == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                final String columnPrefix = getColumnPrefix(parentPrefix, resultMapping);</span><br><span class="line">                //获取子ResultMap</span><br><span class="line">                final ResultMap nestedResultMap = getNestedResultMap(rsw.getResultSet(), nestedResultMapId, columnPrefix);</span><br><span class="line">                //创建缓存key</span><br><span class="line">                final CacheKey rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);</span><br><span class="line">                //获取该对象的缓存</span><br><span class="line">                final Object ancestorObject = ancestorObjects.get(rowKey);</span><br><span class="line">                if (ancestorObject != null) &#123; </span><br><span class="line">                    //存在,则直接放入上级对象，解决循环依赖</span><br><span class="line">                    if (newObject) metaObject.setValue(resultMapping.getProperty(), ancestorObject);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //不存在</span><br><span class="line">                    //将上级对象的key与本对象key结合，作为本对象的新的key</span><br><span class="line">                    final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);</span><br><span class="line">                    //再次从缓存中获取该对象            </span><br><span class="line">                    Object rowValue = nestedResultObjects.get(combinedKey);</span><br><span class="line">                    boolean knownValue = (rowValue != null);</span><br><span class="line">                    //实例化集合属性，并加入到上级对象中</span><br><span class="line">                    final Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);</span><br><span class="line">                    //检查是否所有非空字段均有值            </span><br><span class="line">                    if (anyNotNullColumnHasValue(resultMapping, columnPrefix, rsw.getResultSet())) &#123;</span><br><span class="line">                        //生成对象</span><br><span class="line">                        rowValue = getRowValue(rsw, nestedResultMap, combinedKey, rowKey, columnPrefix, rowValue);</span><br><span class="line">                        if (rowValue != null &amp;&amp; !knownValue) &#123;</span><br><span class="line">                            if (collectionProperty != null) &#123;</span><br><span class="line">                                final MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);</span><br><span class="line">                                //对象放入刚刚创建的集合中</span><br><span class="line">                                targetMetaObject.add(rowValue);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                //对象放入上级对象中</span><br><span class="line">                                metaObject.setValue(resultMapping.getProperty(), rowValue);</span><br><span class="line">                            &#125;</span><br><span class="line">                            foundValues = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                throw new ExecutorException(&quot;Error getting nested result map values for &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="25、DefaultResultSetHandler的instantiateCollectionPropertyIfAppropriate方法"><a href="#25、DefaultResultSetHandler的instantiateCollectionPropertyIfAppropriate方法" class="headerlink" title="25、DefaultResultSetHandler的instantiateCollectionPropertyIfAppropriate方法"></a>25、DefaultResultSetHandler的instantiateCollectionPropertyIfAppropriate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private Object instantiateCollectionPropertyIfAppropriate(ResultMapping resultMapping, MetaObject metaObject) &#123;</span><br><span class="line">    //属性名</span><br><span class="line">    final String propertyName = resultMapping.getProperty();</span><br><span class="line">    //设置值</span><br><span class="line">    Object propertyValue = metaObject.getValue(propertyName);</span><br><span class="line">    if (propertyValue == null) &#123;</span><br><span class="line">        //如果为空，取出类型</span><br><span class="line">        Class&lt;?&gt; type = resultMapping.getJavaType();</span><br><span class="line">        if (type == null) &#123;</span><br><span class="line">            type = metaObject.getSetterType(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //如果是集合类型</span><br><span class="line">            if (objectFactory.isCollection(type)) &#123;</span><br><span class="line">                //生成一个集合对象</span><br><span class="line">                propertyValue = objectFactory.create(type);</span><br><span class="line">                //设置到上一级对象中去 </span><br><span class="line">                metaObject.setValue(propertyName, propertyValue);</span><br><span class="line">                return propertyValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new ExecutorException(&quot;Error instantiating collection property for result &apos;&quot; + resultMapping.getProperty() + &quot;&apos;.  Cause: &quot; + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (objectFactory.isCollection(propertyValue.getClass())) &#123;</span><br><span class="line">        return propertyValue;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、懒加载过程"><a href="#八、懒加载过程" class="headerlink" title="八、懒加载过程"></a>八、懒加载过程</h3><h4 id="1、EnhancedResultObjectProxyImpl的intercept方法"><a href="#1、EnhancedResultObjectProxyImpl的intercept方法" class="headerlink" title="1、EnhancedResultObjectProxyImpl的intercept方法"></a>1、EnhancedResultObjectProxyImpl的intercept方法</h4><p>有子查询，返回的是代理对象，执行对象的get方法，会先经过intercept方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object enhanced, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">    //调用的方法</span><br><span class="line">    final String methodName = method.getName();</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (lazyLoader) &#123;</span><br><span class="line">            if (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                //writeReplace方法可以使对象被写入流以前，用一个对象来替换自己</span><br><span class="line">                //将要序列化的对象</span><br><span class="line">                Object original = null;</span><br><span class="line">                if (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">                    //创建原始对象</span><br><span class="line">                    original = objectFactory.create(type);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">                &#125;</span><br><span class="line">                PropertyCopier.copyBeanProperties(type, enhanced, original);   </span><br><span class="line">                if (lazyLoader.size() &gt; 0) &#123;</span><br><span class="line">                    //有懒加载方法</span><br><span class="line">                    //创建代理对象</span><br><span class="line">                    return new CglibSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //返回原始对象</span><br><span class="line">                    return original;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //有懒加载方法，且本方法不为finalize方法</span><br><span class="line">                if (lazyLoader.size() &gt; 0 &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                    if (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                        //加载所有子查询</span><br><span class="line">                        lazyLoader.loadAll();</span><br><span class="line">                    &#125; else if (PropertyNamer.isProperty(methodName)) &#123;</span><br><span class="line">                        //由get或set方法名获取property字段名</span><br><span class="line">                        final String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                        if (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                            //查询该字段</span><br><span class="line">                            lazyLoader.load(property);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return methodProxy.invokeSuper(enhanced, args);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒加载配置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 查询时，关闭关联对象即时加载以提高性能 --&gt;  </span><br><span class="line">&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;  </span><br><span class="line">&lt;!-- 该属性为true，则在访问任何一个懒加载属性时，加载所有懒加载属性 --&gt;  </span><br><span class="line">&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;  </span><br><span class="line">&lt;!-- 配置该方法，触发所有懒加载 --&gt;  </span><br><span class="line">&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;doLazyLoadingNow,equals,clone,hashCode,toString&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、ResultLoaderMap的loadAll方法"><a href="#2、ResultLoaderMap的loadAll方法" class="headerlink" title="2、ResultLoaderMap的loadAll方法"></a>2、ResultLoaderMap的loadAll方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loadAll() throws SQLException &#123;</span><br><span class="line">    //获取所有懒加载方法名</span><br><span class="line">    final Set&lt;String&gt; methodNameSet = loaderMap.keySet();</span><br><span class="line">    String[] methodNames = methodNameSet.toArray(new String[methodNameSet.size()]);</span><br><span class="line">    for (String methodName : methodNames) &#123;</span><br><span class="line">        //加载</span><br><span class="line">        load(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、ResultLoaderMap的load方法"><a href="#3、ResultLoaderMap的load方法" class="headerlink" title="3、ResultLoaderMap的load方法"></a>3、ResultLoaderMap的load方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean load(String property) throws SQLException &#123;</span><br><span class="line">    LoadPair pair = loaderMap.remove(property.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    if (pair != null) &#123;</span><br><span class="line">        //加载</span><br><span class="line">        pair.load();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、LoadPair的load方法"><a href="#4、LoadPair的load方法" class="headerlink" title="4、LoadPair的load方法"></a>4、LoadPair的load方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void load() throws SQLException &#123;</span><br><span class="line">    /* These field should not be null unless the loadpair was serialized.</span><br><span class="line">     * Yet in that case this method should not be called. */</span><br><span class="line">    if (this.metaResultObject == null) throw new IllegalArgumentException(&quot;metaResultObject is null&quot;);</span><br><span class="line">    if (this.resultLoader == null) throw new IllegalArgumentException(&quot;resultLoader is null&quot;);</span><br><span class="line"></span><br><span class="line">    this.load(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void load(final Object userObject) throws SQLException &#123;</span><br><span class="line">    if (this.metaResultObject == null || this.resultLoader == null) &#123;</span><br><span class="line">        if (this.mappedParameter == null) &#123;</span><br><span class="line">            throw new ExecutorException(&quot;Property [&quot; + this.property + &quot;] cannot be loaded because &quot;</span><br><span class="line">                  + &quot;required parameter of mapped statement [&quot;</span><br><span class="line">                  + this.mappedStatement + &quot;] is not serializable.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Configuration config = this.getConfiguration();</span><br><span class="line">        //获取子查询的MappedStatement</span><br><span class="line">        final MappedStatement ms = config.getMappedStatement(this.mappedStatement);</span><br><span class="line">        if (ms == null) &#123;</span><br><span class="line">            throw new ExecutorException(&quot;Cannot lazy load property [&quot; + this.property</span><br><span class="line">                  + &quot;] of deserialized object [&quot; + userObject.getClass()</span><br><span class="line">                  + &quot;] because configuration does not contain statement [&quot;</span><br><span class="line">                  + this.mappedStatement + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.metaResultObject = config.newMetaObject(userObject);</span><br><span class="line">        this.resultLoader = new ResultLoader(config, new ClosedExecutor(), ms, this.mappedParameter,</span><br><span class="line">            metaResultObject.getSetterType(this.property), null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We are using a new executor because we may be (and likely are) on a new thread</span><br><span class="line">     * and executors aren&apos;t thread safe. (Is this sufficient?)</span><br><span class="line">     *</span><br><span class="line">     * A better approach would be making executors thread safe. */</span><br><span class="line">    if (this.serializationCheck == null) &#123;</span><br><span class="line">        //正在序列化过程中,关闭原先的执行器</span><br><span class="line">        final ResultLoader old = this.resultLoader;</span><br><span class="line">        this.resultLoader = new ResultLoader(old.configuration, new ClosedExecutor(), old.mappedStatement,</span><br><span class="line">                old.parameterObject, old.targetType, old.cacheKey, old.boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    //查询出结果，并放入对象中</span><br><span class="line">    this.metaResultObject.setValue(property, this.resultLoader.loadResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、ResultLoader的loadResult方法"><a href="#5、ResultLoader的loadResult方法" class="headerlink" title="5、ResultLoader的loadResult方法"></a>5、ResultLoader的loadResult方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object loadResult() throws SQLException &#123;</span><br><span class="line">    //查询</span><br><span class="line">    List&lt;Object&gt; list = selectList();</span><br><span class="line">    //处理查询结果</span><br><span class="line">    resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、ResultLoader的selectList方法"><a href="#6、ResultLoader的selectList方法" class="headerlink" title="6、ResultLoader的selectList方法"></a>6、ResultLoader的selectList方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; selectList() throws SQLException &#123;</span><br><span class="line">    Executor localExecutor = executor;</span><br><span class="line">    if (Thread.currentThread().getId() != this.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">        //新线程，创建新的执行器</span><br><span class="line">        localExecutor = newExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //查询</span><br><span class="line">        return localExecutor.&lt;E&gt; query(mappedStatement, parameterObject, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (localExecutor != executor) &#123;</span><br><span class="line">            localExecutor.close(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> mybatis3 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zookeeper源码客户端</title>
      <link href="/2018/04/07/zookeeper%E6%BA%90%E7%A0%81/zookeeper%E6%BA%90%E7%A0%81%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <content type="html"><![CDATA[<h2 id="zookeeper源码客户端"><a href="#zookeeper源码客户端" class="headerlink" title="zookeeper源码客户端"></a>zookeeper源码客户端</h2><h3 id="客户端Demo"><a href="#客户端Demo" class="headerlink" title="客户端Demo"></a>客户端Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">//参数1 路径，参数2 内容，参数3 权限，参数4 类型</span><br><span class="line">String znodePath = zk.create(&quot;/demo&quot;, &quot;hello zookeeper&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">   CreateMode.EPHEMERAL);</span><br><span class="line"></span><br><span class="line">//判断/java节点是否存在，并且给它注册一个监听器，这个监听器只能监听一次，监听到一次事件后就会失效  </span><br><span class="line">   zk.exists(&quot;/demo&quot;, new Watcher() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void process(WatchedEvent event) &#123;</span><br><span class="line">               // 收到watch通知后的回调函数</span><br><span class="line">               System.out.println(&quot;事件类型&quot; + event.getType() + &quot;，路径&quot; + event.getPath());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="一、建立连接过程"><a href="#一、建立连接过程" class="headerlink" title="一、建立连接过程"></a>一、建立连接过程</h3><h4 id="1、实例化ZooKeeper"><a href="#1、实例化ZooKeeper" class="headerlink" title="1、实例化ZooKeeper"></a>1、实例化ZooKeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   // connectString 连接字符串 如&quot;192.168.12.1:2181,192.168.12.2:2181,192.168.12.3:2181/root&quot;  </span><br><span class="line">   // sessionTimeout 客户端提议的session有效时间</span><br><span class="line">public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher,</span><br><span class="line">           boolean canBeReadOnly, HostProvider aHostProvider,</span><br><span class="line">           ZKClientConfig clientConfig) throws IOException &#123;</span><br><span class="line">       LOG.info(&quot;Initiating client connection, connectString=&quot; + connectString</span><br><span class="line">               + &quot; sessionTimeout=&quot; + sessionTimeout + &quot; watcher=&quot; + watcher);</span><br><span class="line"></span><br><span class="line">       if (clientConfig == null) &#123;</span><br><span class="line">           clientConfig = new ZKClientConfig();</span><br><span class="line">       &#125;</span><br><span class="line">       this.clientConfig = clientConfig;</span><br><span class="line"></span><br><span class="line">       //创建Watcher监听器的管理器</span><br><span class="line">       watchManager = defaultWatchManager();</span><br><span class="line"></span><br><span class="line">       //设置默认的Watcher监听器</span><br><span class="line">       watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">       ConnectStringParser connectStringParser = new ConnectStringParser(</span><br><span class="line">               connectString);</span><br><span class="line"></span><br><span class="line">       hostProvider = aHostProvider;</span><br><span class="line"></span><br><span class="line">       //客户端负责与服务端通信的对象</span><br><span class="line">       cnxn = new ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">               hostProvider, sessionTimeout, this, watchManager,</span><br><span class="line">               getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line"></span><br><span class="line">       cnxn.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2、实例化ClientCnxn"><a href="#2、实例化ClientCnxn" class="headerlink" title="2、实例化ClientCnxn"></a>2、实例化ClientCnxn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">           ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">           long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">       this.zooKeeper = zooKeeper;</span><br><span class="line">       this.watcher = watcher;</span><br><span class="line">       this.sessionId = sessionId; //初始值为0</span><br><span class="line">       this.sessionPasswd = sessionPasswd; //初始值为 new byte[16]</span><br><span class="line">       this.sessionTimeout = sessionTimeout;</span><br><span class="line">       this.hostProvider = hostProvider;</span><br><span class="line">       this.chrootPath = chrootPath;</span><br><span class="line"></span><br><span class="line">       connectTimeout = sessionTimeout / hostProvider.size();//hostProvider.size() 服务端地址个数</span><br><span class="line">       readTimeout = sessionTimeout * 2 / 3;</span><br><span class="line">       readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">//发送和接收socket数据的线程</span><br><span class="line">       sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line"></span><br><span class="line">       //事件线程</span><br><span class="line">       eventThread = new EventThread();</span><br><span class="line"></span><br><span class="line">       this.clientConfig=zooKeeper.getClientConfig();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3、SendThread的run方法"><a href="#3、SendThread的run方法" class="headerlink" title="3、SendThread的run方法"></a>3、SendThread的run方法</h4><p>ClientCnxn 的start方法 会分别启动SendThread、EventThread、SendThread的run方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    //更新最近接受和发送时间</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    int to;</span><br><span class="line">    long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">    InetSocketAddress serverAddress = null;</span><br><span class="line">    while (state.isAlive()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        //判断是否完成连接</span><br><span class="line">            if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                判断是否关闭</span><br><span class="line">                if (closing) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //若之前连接过只读服务器，直接用上次查找出的读写服务器地址连接</span><br><span class="line">                if (rwServerAddress != null) &#123;</span><br><span class="line">                    serverAddress = rwServerAddress;</span><br><span class="line">                    rwServerAddress = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //获取下一个服务端地址 延迟1s返回</span><br><span class="line">                    serverAddress = hostProvider.next(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                //连接服务端</span><br><span class="line">                startConnect(serverAddress);</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            判断是否已连接</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                // determine whether we need to send an AuthFailed event.</span><br><span class="line">                if (zooKeeperSaslClient != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                    //进行sasl权限验证</span><br><span class="line">                &#125;</span><br><span class="line">                //超时剩余时间</span><br><span class="line">                to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //超时剩余时间</span><br><span class="line">                to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //to &lt;= 0 则说明连接超时</span><br><span class="line">            if (to &lt;= 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //打印日志抛出异常</span><br><span class="line">                throw new SessionTimeoutException(warnInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //如果已连接  定时发送心跳检测</span><br><span class="line">            if (state.isConnected()) &#123;</span><br><span class="line">                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - </span><br><span class="line">                ((clientCnxnSocket.getIdleSend() &gt; 1000) ? 1000 : 0);</span><br><span class="line">                if (timeToNextPing &lt;= 0 || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                    //发送ping数据</span><br><span class="line">                    sendPing();</span><br><span class="line">                    clientCnxnSocket.updateLastSend();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (timeToNextPing &lt; to) &#123;</span><br><span class="line">                        to = timeToNextPing;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果连接的是只读服务器</span><br><span class="line">            if (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                long now = Time.currentElapsedTime();</span><br><span class="line">                int idlePingRwServer = (int) (now - lastPingRwServer);</span><br><span class="line">                if (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                    lastPingRwServer = now;</span><br><span class="line">                    idlePingRwServer = 0;</span><br><span class="line">                    pingRwTimeout =</span><br><span class="line">                        Math.min(2*pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                    //寻找读写服务器，抛出异常，重新连接</span><br><span class="line">                    pingRwServer();</span><br><span class="line">                &#125;</span><br><span class="line">                to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理与客户端的通信</span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (closing) &#123;</span><br><span class="line">                ...</span><br><span class="line">                //跳出主循环，结束线程</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (state) &#123;</span><br><span class="line">        断开连接，处理队列中的数据包</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    关闭socket</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    if (state.isAlive()) &#123;</span><br><span class="line">    //添加断开连接事件</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(Event.EventType.None,</span><br><span class="line">                Event.KeeperState.Disconnected, null));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、startConnect方法连接服务端"><a href="#4、startConnect方法连接服务端" class="headerlink" title="4、startConnect方法连接服务端"></a>4、startConnect方法连接服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startConnect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    客户端状态更新为正在连接</span><br><span class="line">    state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">    //连接服务端</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、ClientCnxnSocketNIO中的connect方法"><a href="#5、ClientCnxnSocketNIO中的connect方法" class="headerlink" title="5、ClientCnxnSocketNIO中的connect方法"></a>5、ClientCnxnSocketNIO中的connect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void connect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line">       SocketChannel sock = createSock();</span><br><span class="line">       try &#123;</span><br><span class="line">          registerAndConnect(sock, addr);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">           sock.close();</span><br><span class="line">           throw e;</span><br><span class="line">       &#125;</span><br><span class="line">       //未初始化</span><br><span class="line">       initialized = false;</span><br><span class="line">       //清空缓存区</span><br><span class="line">       lenBuffer.clear();</span><br><span class="line">       incomingBuffer = lenBuffer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="6、调用了registerAndConnect方法"><a href="#6、调用了registerAndConnect方法" class="headerlink" title="6、调用了registerAndConnect方法"></a>6、调用了registerAndConnect方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void registerAndConnect(SocketChannel sock, InetSocketAddress addr) </span><br><span class="line">   throws IOException &#123;</span><br><span class="line">   //向selector注册SocketChannel指定OP_CONNECT事件</span><br><span class="line">       sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">       //连接服务器</span><br><span class="line">       boolean immediateConnect = sock.connect(addr);</span><br><span class="line">       if (immediateConnect) &#123;</span><br><span class="line">           sendThread.primeConnection();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="7、SendThread的primeConnection方法"><a href="#7、SendThread的primeConnection方法" class="headerlink" title="7、SendThread的primeConnection方法"></a>7、SendThread的primeConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void primeConnection() throws IOException &#123;</span><br><span class="line">       isFirstConnect = false;</span><br><span class="line">       若之前连接过只读服务器，则使用之前的sessionId</span><br><span class="line">       long sessId = (seenRwServerBefore) ? sessionId : 0;</span><br><span class="line">       创建连接请求对象</span><br><span class="line">       ConnectRequest conReq = new ConnectRequest(0, lastZxid,</span><br><span class="line">               sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">      </span><br><span class="line">       //重新连接将已有的监听器注册到服务器</span><br><span class="line">       if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) &#123;</span><br><span class="line">       //类是否存在监听器</span><br><span class="line">           List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();</span><br><span class="line">           //数据变化监听器</span><br><span class="line">           List&lt;String&gt; existWatches = zooKeeper.getExistWatches();</span><br><span class="line">           //子节点变化监听器</span><br><span class="line">           List&lt;String&gt; childWatches = zooKeeper.getChildWatches();</span><br><span class="line">           if (!dataWatches.isEmpty()</span><br><span class="line">                   || !existWatches.isEmpty() || !childWatches.isEmpty()) &#123;</span><br><span class="line">               Iterator&lt;String&gt; dataWatchesIter = prependChroot(dataWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; existWatchesIter = prependChroot(existWatches).iterator();</span><br><span class="line">               Iterator&lt;String&gt; childWatchesIter = prependChroot(childWatches).iterator();</span><br><span class="line">               long setWatchesLastZxid = lastZxid;</span><br><span class="line"></span><br><span class="line">               while (dataWatchesIter.hasNext()</span><br><span class="line">                      || existWatchesIter.hasNext() || childWatchesIter.hasNext()) &#123;</span><br><span class="line">                   List&lt;String&gt; dataWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; existWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   List&lt;String&gt; childWatchesBatch = new ArrayList&lt;String&gt;();</span><br><span class="line">                   int batchLength = 0;</span><br><span class="line"></span><br><span class="line">                   while (batchLength &lt; SET_WATCHES_MAX_LENGTH) &#123;</span><br><span class="line">                       final String watch;</span><br><span class="line">                       if (dataWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = dataWatchesIter.next();</span><br><span class="line">                           dataWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (existWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = existWatchesIter.next();</span><br><span class="line">                           existWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else if (childWatchesIter.hasNext()) &#123;</span><br><span class="line">                           watch = childWatchesIter.next();</span><br><span class="line">                           childWatchesBatch.add(watch);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                       batchLength += watch.length();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   SetWatches sw = new SetWatches(setWatchesLastZxid,</span><br><span class="line">                                                  dataWatchesBatch,</span><br><span class="line">                                                  existWatchesBatch,</span><br><span class="line">                                                  childWatchesBatch);</span><br><span class="line">                   RequestHeader header = new RequestHeader(-8, OpCode.setWatches);</span><br><span class="line">                   Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);</span><br><span class="line">                   outgoingQueue.addFirst(packet);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       //新建一个数据包，加入发送队列</span><br><span class="line">       outgoingQueue.addFirst(new Packet(null, null, conReq,</span><br><span class="line">               null, null, readOnly));</span><br><span class="line">       //该方法修改SocketChannel指定事件为读和写</span><br><span class="line">       clientCnxnSocket.connectionPrimed();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="8、ClientCnxnSocketNIO的doTransport方法"><a href="#8、ClientCnxnSocketNIO的doTransport方法" class="headerlink" title="8、ClientCnxnSocketNIO的doTransport方法"></a>8、ClientCnxnSocketNIO的doTransport方法</h4><p>读取和发送数据的逻辑在实现类ClientCnxnSocketNIO的doTransport方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   void doTransport(int waitTimeOut, List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">           throws IOException, InterruptedException &#123;</span><br><span class="line">       selector.select(waitTimeOut);</span><br><span class="line">       Set&lt;SelectionKey&gt; selected;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           selected = selector.selectedKeys();</span><br><span class="line">       &#125;</span><br><span class="line">       updateNow();</span><br><span class="line">       for (SelectionKey k : selected) &#123;</span><br><span class="line">           SocketChannel sc = ((SocketChannel) k.channel());</span><br><span class="line">           //连接事件未就绪</span><br><span class="line">           if ((k.readyOps() &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">               if (sc.finishConnect()) &#123;</span><br><span class="line">                   updateLastSendAndHeard();</span><br><span class="line">                   更新服务端地址</span><br><span class="line">                   updateSocketAddresses();</span><br><span class="line">                   连接服务端</span><br><span class="line">                   sendThread.primeConnection();</span><br><span class="line">               &#125;</span><br><span class="line">            //读写事件就绪</span><br><span class="line">           &#125; else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) &#123;</span><br><span class="line">               处理通信数据</span><br><span class="line">               doIO(pendingQueue, cnxn);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sendThread.getZkState().isConnected()) &#123;</span><br><span class="line">       //找出可以在sasl认证之前可以预先发送的请求</span><br><span class="line">           if (findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       selected.clear();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="9、ClientCnxnSocketNIO的doIO方法"><a href="#9、ClientCnxnSocketNIO的doIO方法" class="headerlink" title="9、ClientCnxnSocketNIO的doIO方法"></a>9、ClientCnxnSocketNIO的doIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">     throws InterruptedException, IOException &#123;</span><br><span class="line">       SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">       if (sock == null) &#123;</span><br><span class="line">           throw new IOException(&quot;Socket is null!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //就绪事件为读事件</span><br><span class="line">       if (sockKey.isReadable()) &#123;</span><br><span class="line">           int rc = sock.read(incomingBuffer);</span><br><span class="line">           if (rc &lt; 0) &#123;</span><br><span class="line">               throw new EndOfStreamException(</span><br><span class="line">                       &quot;Unable to read additional data from server sessionid 0x&quot;</span><br><span class="line">                               + Long.toHexString(sessionId)</span><br><span class="line">                               + &quot;, likely server has closed socket&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           //incomingBuffer是否还有空间</span><br><span class="line">           if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">               incomingBuffer.flip();</span><br><span class="line">               //如果incomingBuffer和lenBuffer指向同一个byteBuffer，说明是新请求的第一次读 </span><br><span class="line">               if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">               请求次数增加</span><br><span class="line">                   recvCount++;</span><br><span class="line">                   //incomingBuffer缓存区初始化</span><br><span class="line">                   readLength();</span><br><span class="line">               &#125; else if (!initialized) &#123;</span><br><span class="line">               //读取服务端的连接请求返回</span><br><span class="line">                   readConnectResult();</span><br><span class="line">                   enableRead();</span><br><span class="line">                   if (findSendablePacket(outgoingQueue,</span><br><span class="line">                           sendThread.tunnelAuthInProgress()) != null) &#123;</span><br><span class="line">                       enableWrite();</span><br><span class="line">                   &#125;</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">                   initialized = true;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">               //读取服务端的其他请求返回</span><br><span class="line">                   sendThread.readResponse(incomingBuffer);</span><br><span class="line">                   lenBuffer.clear();</span><br><span class="line">                   incomingBuffer = lenBuffer;</span><br><span class="line">                   updateLastHeard();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (sockKey.isWritable()) &#123;</span><br><span class="line">       //查找可发送的数据包</span><br><span class="line">           Packet p = findSendablePacket(outgoingQueue,</span><br><span class="line">                   sendThread.tunnelAuthInProgress());</span><br><span class="line"></span><br><span class="line">           if (p != null) &#123;</span><br><span class="line">               updateLastSend();</span><br><span class="line">               // If we already started writing p, p.bb will already exist</span><br><span class="line">               if (p.bb == null) &#123;</span><br><span class="line">                   if ((p.requestHeader != null) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</span><br><span class="line">                           (p.requestHeader.getType() != OpCode.auth)) &#123;</span><br><span class="line">                       p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                   &#125;</span><br><span class="line">                   p.createBB();</span><br><span class="line">               &#125;</span><br><span class="line">               //发送数据</span><br><span class="line">               sock.write(p.bb);</span><br><span class="line">               if (!p.bb.hasRemaining()) &#123;</span><br><span class="line">                   sentCount++;</span><br><span class="line">                   outgoingQueue.removeFirstOccurrence(p);</span><br><span class="line">                   if (p.requestHeader != null</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.ping</span><br><span class="line">                           &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</span><br><span class="line">                       synchronized (pendingQueue) &#123;</span><br><span class="line">                       //把包裹加入到等待服务端返回队列</span><br><span class="line">                           pendingQueue.add(p);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">               发送队列为空，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else if (!initialized &amp;&amp; p != null &amp;&amp; !p.bb.hasRemaining()) &#123;</span><br><span class="line">               连接请求发送完成，取消对OP_WRITE事件的指定</span><br><span class="line">               disableWrite();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Just in case</span><br><span class="line">               enableWrite();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="10、ClientCnxnSocketNIO的readConnectResult方法"><a href="#10、ClientCnxnSocketNIO的readConnectResult方法" class="headerlink" title="10、ClientCnxnSocketNIO的readConnectResult方法"></a>10、ClientCnxnSocketNIO的readConnectResult方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void readConnectResult() throws IOException &#123;</span><br><span class="line">       if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">           StringBuilder buf = new StringBuilder(&quot;0x[&quot;);</span><br><span class="line">           for (byte b : incomingBuffer.array()) &#123;</span><br><span class="line">               buf.append(Integer.toHexString(b) + &quot;,&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           buf.append(&quot;]&quot;);</span><br><span class="line">           LOG.trace(&quot;readConnectResult &quot; + incomingBuffer.remaining() + &quot; &quot;</span><br><span class="line">                   + buf.toString());</span><br><span class="line">       &#125;</span><br><span class="line">       ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">       BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">       ConnectResponse conRsp = new ConnectResponse();</span><br><span class="line">       反序列化连接请求返回</span><br><span class="line">       conRsp.deserialize(bbia, &quot;connect&quot;);</span><br><span class="line"></span><br><span class="line">       // read &quot;is read-only&quot; flag</span><br><span class="line">       boolean isRO = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           isRO = bbia.readBool(&quot;readOnly&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           // this is ok -- just a packet from an old server which</span><br><span class="line">           // doesn&apos;t contain readOnly field</span><br><span class="line">           LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //获取服务端返回的sessionId</span><br><span class="line">       this.sessionId = conRsp.getSessionId();</span><br><span class="line">       //最终处理连接返回数据</span><br><span class="line">       sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,</span><br><span class="line">               conRsp.getPasswd(), isRO);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="11、sendThread的onConnected方法"><a href="#11、sendThread的onConnected方法" class="headerlink" title="11、sendThread的onConnected方法"></a>11、sendThread的onConnected方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void onConnected(int _negotiatedSessionTimeout, long _sessionId,</span><br><span class="line">                byte[] _sessionPasswd, boolean isRO) throws IOException &#123;</span><br><span class="line">    negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">    //session是否过期</span><br><span class="line">    if (negotiatedSessionTimeout &lt;= 0) &#123;</span><br><span class="line">        state = States.CLOSED;</span><br><span class="line">        //session过期 关闭客户端</span><br><span class="line">        eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">                Watcher.Event.EventType.None,</span><br><span class="line">                Watcher.Event.KeeperState.Expired, null));</span><br><span class="line">        eventThread.queueEventOfDeath();</span><br><span class="line">        ...</span><br><span class="line">        throw new SessionExpiredException(warnInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    //读写客户端连接上只读服务器，则打印错误日志</span><br><span class="line">    if (!readOnly &amp;&amp; isRO) &#123;</span><br><span class="line">        LOG.error(&quot;Read/write client got connected to read-only server&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    readTimeout = negotiatedSessionTimeout * 2 / 3;</span><br><span class="line">    connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">    hostProvider.onConnected();</span><br><span class="line">    sessionId = _sessionId;</span><br><span class="line">    sessionPasswd = _sessionPasswd;</span><br><span class="line">    //连接成功修改连接状态</span><br><span class="line">    state = (isRO) ?</span><br><span class="line">            States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">    //是否连接上读写服务器</span><br><span class="line">    seenRwServerBefore |= !isRO;</span><br><span class="line">    KeeperState eventState = (isRO) ?</span><br><span class="line">            KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">    事件队列添加一个None类型的事件</span><br><span class="line">    eventThread.queueEvent(new WatchedEvent(</span><br><span class="line">            Watcher.Event.EventType.None,</span><br><span class="line">            eventState, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、EventThread的queueEvent方法"><a href="#12、EventThread的queueEvent方法" class="headerlink" title="12、EventThread的queueEvent方法"></a>12、EventThread的queueEvent方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void queueEvent(WatchedEvent event,</span><br><span class="line">           Set&lt;Watcher&gt; materializedWatchers) &#123;</span><br><span class="line">       if (event.getType() == EventType.None</span><br><span class="line">               &amp;&amp; sessionState == event.getState()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       sessionState = event.getState();</span><br><span class="line">       final Set&lt;Watcher&gt; watchers;</span><br><span class="line">       if (materializedWatchers == null) &#123;</span><br><span class="line">           // 获取与该事件相关的所有监听器</span><br><span class="line">           watchers = watcher.materialize(event.getState(),</span><br><span class="line">                   event.getType(), event.getPath());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">           watchers.addAll(materializedWatchers);</span><br><span class="line">       &#125;</span><br><span class="line">       WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);</span><br><span class="line">       //往队列添加监听器和事件对</span><br><span class="line">       waitingEvents.add(pair);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="13、ZKWatchManager的materialize方法"><a href="#13、ZKWatchManager的materialize方法" class="headerlink" title="13、ZKWatchManager的materialize方法"></a>13、ZKWatchManager的materialize方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Set&lt;Watcher&gt; materialize(Watcher.Event.KeeperState state,</span><br><span class="line">                                       Watcher.Event.EventType type,</span><br><span class="line">                                       String clientPath)</span><br><span class="line">   &#123;</span><br><span class="line">       Set&lt;Watcher&gt; result = new HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">       switch (type) &#123;</span><br><span class="line">       //None类型的事件通知所有监听器</span><br><span class="line">       case None:</span><br><span class="line">           result.add(defaultWatcher);</span><br><span class="line">           boolean clear = disableAutoWatchReset &amp;&amp; state != Watcher.Event.KeeperState.SyncConnected;</span><br><span class="line">           synchronized(dataWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: dataWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   dataWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(existWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: existWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   existWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           synchronized(childWatches) &#123;</span><br><span class="line">               for(Set&lt;Watcher&gt; ws: childWatches.values()) &#123;</span><br><span class="line">                   result.addAll(ws);</span><br><span class="line">               &#125;</span><br><span class="line">               if (clear) &#123;</span><br><span class="line">                   childWatches.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       case NodeDataChanged:</span><br><span class="line">       case NodeCreated:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               addTo(existWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeChildrenChanged:</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case NodeDeleted:</span><br><span class="line">           synchronized (dataWatches) &#123;</span><br><span class="line">               addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           // XXX This shouldn&apos;t be needed, but just in case</span><br><span class="line">           synchronized (existWatches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; list = existWatches.remove(clientPath);</span><br><span class="line">               if (list != null) &#123;</span><br><span class="line">                   addTo(existWatches.remove(clientPath), result);</span><br><span class="line">                   LOG.warn(&quot;We are triggering an exists watch for delete! Shouldn&apos;t happen!&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           synchronized (childWatches) &#123;</span><br><span class="line">               addTo(childWatches.remove(clientPath), result);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       default:</span><br><span class="line">           String msg = &quot;Unhandled watch event type &quot; + type</span><br><span class="line">               + &quot; with state &quot; + state + &quot; on path &quot; + clientPath;</span><br><span class="line">           LOG.error(msg);</span><br><span class="line">           throw new RuntimeException(msg);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="14、EventThread的processEvent方法"><a href="#14、EventThread的processEvent方法" class="headerlink" title="14、EventThread的processEvent方法"></a>14、EventThread的processEvent方法</h4><p>EventThread的run方法中的processEvent方法处理事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private void processEvent(Object event) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (event instanceof WatcherSetEventPair) &#123;</span><br><span class="line">            //是监听器事件则调用所有监听器</span><br><span class="line">            WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">            for (Watcher watcher : pair.watchers) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                      watcher.process(pair.event);</span><br><span class="line">                catch (Throwable t) &#123;</span><br><span class="line">                      LOG.error(&quot;Error while calling watcher &quot;, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //调用回调函数</span><br><span class="line">        &#125; else if (event instanceof LocalCallback) &#123;</span><br><span class="line">            LocalCallback lcb = (LocalCallback) event;</span><br><span class="line">            if (lcb.cb instanceof StatCallback) &#123;</span><br><span class="line">                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path,</span><br><span class="line">                        lcb.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //是数据包则调用其中的回调函数</span><br><span class="line">            Packet p = (Packet) event;</span><br><span class="line">            int rc = 0;</span><br><span class="line">            String clientPath = p.clientPath;</span><br><span class="line">            if (p.replyHeader.getErr() != 0) &#123;</span><br><span class="line">                rc = p.replyHeader.getErr();</span><br><span class="line">            &#125;</span><br><span class="line">            if (p.cb == null) &#123;</span><br><span class="line">                LOG.warn(&quot;Somehow a null cb got to EventThread!&quot;);</span><br><span class="line">            &#125; else if (p.response instanceof ExistsResponse</span><br><span class="line">                      || p.response instanceof SetDataResponse</span><br><span class="line">                      || p.response instanceof SetACLResponse) &#123;</span><br><span class="line">            StatCallback cb = (StatCallback) p.cb;</span><br><span class="line">                if (rc == 0) &#123;</span><br><span class="line">                    if (p.response instanceof ExistsResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((ExistsResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetDataResponse) &#123;</span><br><span class="line">                        cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetDataResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125; else if (p.response instanceof SetACLResponse) &#123;</span><br><span class="line">                          cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                                  ((SetACLResponse) p.response)</span><br><span class="line">                                          .getStat());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                      cb.processResult(rc, clientPath, p.ctx, null);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... </span><br><span class="line">       &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        LOG.error(&quot;Caught unexpected throwable&quot;, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此客户端连接成功</p><h3 id="二、添加节点过程"><a href="#二、添加节点过程" class="headerlink" title="二、添加节点过程"></a>二、添加节点过程</h3><h4 id="1、ZooKeeper类中的create方法"><a href="#1、ZooKeeper类中的create方法" class="headerlink" title="1、ZooKeeper类中的create方法"></a>1、ZooKeeper类中的create方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   //path   节点的位置</span><br><span class="line">   //data[] 节点的数据</span><br><span class="line">   //acl OPEN_ACL_UNSAFE：完全开放</span><br><span class="line">//CREATOR_ALL_ACL：创建该znode的连接拥有所有权限</span><br><span class="line">//READ_ACL_UNSAFE：所有的客户端都可读</span><br><span class="line">   //createMode PERSISTENT：持久化节点</span><br><span class="line">//PERSISTENT_SEQUENTIAL：持久化有序节点</span><br><span class="line">//EPHEMERAL：临时节点（连接断开自动删除）</span><br><span class="line">//EPHEMERAL_SEQUENTIAL：临时有序节点（连接断开自动删除）</span><br><span class="line">public String create(final String path, byte data[], List&lt;ACL&gt; acl,</span><br><span class="line">           CreateMode createMode)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">       EphemeralType.validateTTL(createMode, -1);</span><br><span class="line">       validateACL(acl);</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">       CreateRequest request = new CreateRequest();</span><br><span class="line">       CreateResponse response = new CreateResponse();</span><br><span class="line">       request.setData(data);</span><br><span class="line">       request.setFlags(createMode.toFlag());</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setAcl(acl);</span><br><span class="line">       //发送请求</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, null);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line">       if (cnxn.chrootPath == null) &#123;</span><br><span class="line">           return response.getPath();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return response.getPath().substring(cnxn.chrootPath.length());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2、ClientCnxn的submitRequest方法"><a href="#2、ClientCnxn的submitRequest方法" class="headerlink" title="2、ClientCnxn的submitRequest方法"></a>2、ClientCnxn的submitRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ReplyHeader submitRequest(RequestHeader h, Record request,</span><br><span class="line">           Record response, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       ReplyHeader r = new ReplyHeader();</span><br><span class="line">       //将请求打包并加入发送队列</span><br><span class="line">       Packet packet = queuePacket(h, r, request, response, null, null, null,</span><br><span class="line">               null, watchRegistration, watchDeregistration);</span><br><span class="line">       synchronized (packet) &#123;</span><br><span class="line">       //等待直到数据包处理</span><br><span class="line">           while (!packet.finished) &#123;</span><br><span class="line">               packet.wait();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3、ClientCnxn的queuePacket方法"><a href="#3、ClientCnxn的queuePacket方法" class="headerlink" title="3、ClientCnxn的queuePacket方法"></a>3、ClientCnxn的queuePacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Packet queuePacket(RequestHeader h, ReplyHeader r, Record request,</span><br><span class="line">           Record response, AsyncCallback cb, String clientPath,</span><br><span class="line">           String serverPath, Object ctx, WatchRegistration watchRegistration,</span><br><span class="line">           WatchDeregistration watchDeregistration) &#123;</span><br><span class="line">       Packet packet = null;</span><br><span class="line"></span><br><span class="line">       //创建待发送的数据包裹</span><br><span class="line">       packet = new Packet(h, r, request, response, watchRegistration);</span><br><span class="line">       packet.cb = cb;</span><br><span class="line">       packet.ctx = ctx;</span><br><span class="line">       packet.clientPath = clientPath;</span><br><span class="line">       packet.serverPath = serverPath;</span><br><span class="line">       packet.watchDeregistration = watchDeregistration;</span><br><span class="line">       </span><br><span class="line">       synchronized (state) &#123;</span><br><span class="line">           if (!state.isAlive() || closing) &#123;</span><br><span class="line">           //客户端已关闭或正在关闭，关闭包裹</span><br><span class="line">               conLossPacket(packet);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果发送的是关闭请求,更改正关闭状态为true</span><br><span class="line">               if (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                   closing = true;</span><br><span class="line">               &#125;</span><br><span class="line">               将数据包裹加入待发送队列</span><br><span class="line">               outgoingQueue.add(packet);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //唤醒selector</span><br><span class="line">       sendThread.getClientCnxnSocket().packetAdded();</span><br><span class="line">       return packet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4、SendThread类的readResponse方法"><a href="#4、SendThread类的readResponse方法" class="headerlink" title="4、SendThread类的readResponse方法"></a>4、SendThread类的readResponse方法</h4><p>发送数据包的逻辑在（一、9）的doIO中，readResponse方法读取客户端返回数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">void readResponse(ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    ByteBufferInputStream bbis = new ByteBufferInputStream(</span><br><span class="line">            incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ReplyHeader replyHdr = new ReplyHeader();</span><br><span class="line"></span><br><span class="line">    replyHdr.deserialize(bbia, &quot;header&quot;);</span><br><span class="line">    //ping请求返回</span><br><span class="line">    if (replyHdr.getXid() == -2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //权限认证请求返回</span><br><span class="line">    if (replyHdr.getXid() == -4) &#123;</span><br><span class="line">        if(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">            state = States.AUTH_FAILED;                    </span><br><span class="line">            eventThread.queueEvent( new WatchedEvent(Watcher.Event.EventType.None, </span><br><span class="line">                    Watcher.Event.KeeperState.AuthFailed, null) );                        </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //客户端返回通知</span><br><span class="line">    if (replyHdr.getXid() == -1) &#123;</span><br><span class="line">        WatcherEvent event = new WatcherEvent();</span><br><span class="line">        event.deserialize(bbia, &quot;response&quot;);</span><br><span class="line"></span><br><span class="line">        //把event中的path转换为客户端path</span><br><span class="line">        if (chrootPath != null) &#123;</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            if(serverPath.compareTo(chrootPath)==0)</span><br><span class="line">                event.setPath(&quot;/&quot;);</span><br><span class="line">            else if (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            else &#123;</span><br><span class="line">            LOG.warn(&quot;Got server path &quot; + event.getPath()</span><br><span class="line">            + &quot; which is too short for chroot path &quot;</span><br><span class="line">            + chrootPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WatchedEvent we = new WatchedEvent(event);</span><br><span class="line">        //添加事件，逻辑在（一、12）中</span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Packet packet;</span><br><span class="line">    synchronized (pendingQueue) &#123;</span><br><span class="line">        if (pendingQueue.size() == 0) &#123;</span><br><span class="line">            throw new IOException(&quot;Nothing in the queue, but got &quot;</span><br><span class="line">                    + replyHdr.getXid());</span><br><span class="line">        &#125;</span><br><span class="line">        //服务端已返回，从队列中删除该数据包</span><br><span class="line">        packet = pendingQueue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    //数据包裹按顺序处理，返回不一致则抛出异常</span><br><span class="line">    try &#123;</span><br><span class="line">        if (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">            packet.replyHeader.setErr(</span><br><span class="line">                    KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">            throw new IOException(&quot;Xid out of order. Got Xid &quot;</span><br><span class="line">                    + replyHdr.getXid() + &quot; with err &quot; +</span><br><span class="line">                    + replyHdr.getErr() +</span><br><span class="line">                    &quot; expected Xid &quot;</span><br><span class="line">                    + packet.requestHeader.getXid()</span><br><span class="line">                    + &quot; for a packet with details: &quot;</span><br><span class="line">                    + packet );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">        packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">        if (replyHdr.getZxid() &gt; 0) &#123;</span><br><span class="line">        //更新最新处理事物id</span><br><span class="line">            lastZxid = replyHdr.getZxid();</span><br><span class="line">        &#125;</span><br><span class="line">        if (packet.response != null &amp;&amp; replyHdr.getErr() == 0) &#123;</span><br><span class="line">        //序列化返回数据</span><br><span class="line">            packet.response.deserialize(bbia, &quot;response&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    //最终完成数据包处理</span><br><span class="line">        finishPacket(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、SendThread的finishPacket方法"><a href="#5、SendThread的finishPacket方法" class="headerlink" title="5、SendThread的finishPacket方法"></a>5、SendThread的finishPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void finishPacket(Packet p) &#123;</span><br><span class="line">       int err = p.replyHeader.getErr();</span><br><span class="line">       if (p.watchRegistration != null) &#123;</span><br><span class="line">       //注册监听器到watchManager中</span><br><span class="line">           p.watchRegistration.register(err);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       数据包裹处理完成</span><br><span class="line">       if (p.cb == null) &#123;</span><br><span class="line">           synchronized (p) &#123;</span><br><span class="line">               p.finished = true;</span><br><span class="line">               p.notifyAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           p.finished = true;</span><br><span class="line">           eventThread.queuePacket(p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到此create处理完成</p><h3 id="三、添加监听器过程"><a href="#三、添加监听器过程" class="headerlink" title="三、添加监听器过程"></a>三、添加监听器过程</h3><h4 id="1、以ZooKeepe类中的exists方法为例"><a href="#1、以ZooKeepe类中的exists方法为例" class="headerlink" title="1、以ZooKeepe类中的exists方法为例"></a>1、以ZooKeepe类中的exists方法为例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Stat exists(final String path, Watcher watcher)</span><br><span class="line">       throws KeeperException, InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">       final String clientPath = path;</span><br><span class="line">       PathUtils.validatePath(clientPath);</span><br><span class="line">       WatchRegistration wcb = null;</span><br><span class="line">       if (watcher != null) &#123;</span><br><span class="line">       //新建Exist监听器注册器</span><br><span class="line">           wcb = new ExistsWatchRegistration(watcher, clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">       RequestHeader h = new RequestHeader();</span><br><span class="line">       h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">       //实例化Exists请求</span><br><span class="line">       ExistsRequest request = new ExistsRequest();</span><br><span class="line">       request.setPath(serverPath);</span><br><span class="line">       request.setWatch(watcher != null);</span><br><span class="line">       SetDataResponse response = new SetDataResponse();</span><br><span class="line">       //发送请求，见（二、2）</span><br><span class="line">       ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">       if (r.getErr() != 0) &#123;</span><br><span class="line">           if (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           throw KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                   clientPath);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return response.getStat().getCzxid() == -1 ? null : response.getStat();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2、ExistsWatchRegistration的register方法"><a href="#2、ExistsWatchRegistration的register方法" class="headerlink" title="2、ExistsWatchRegistration的register方法"></a>2、ExistsWatchRegistration的register方法</h4><p>发送和接受请求与二中相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void register(int rc) &#123;</span><br><span class="line">       if (shouldAddWatch(rc)) &#123;</span><br><span class="line">           Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">           synchronized(watches) &#123;</span><br><span class="line">               Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">               if (watchers == null) &#123;</span><br><span class="line">                   watchers = new HashSet&lt;Watcher&gt;();</span><br><span class="line">                   watches.put(clientPath, watchers);</span><br><span class="line">               &#125;</span><br><span class="line">               watchers.add(watcher);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、ExistsWatchRegistration的getWatches方法"><a href="#3、ExistsWatchRegistration的getWatches方法" class="headerlink" title="3、ExistsWatchRegistration的getWatches方法"></a>3、ExistsWatchRegistration的getWatches方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(int rc) &#123;</span><br><span class="line">   //返回成功则注册到dataWatches，不存在则注册到existWatches中</span><br><span class="line">       return rc == 0 ?  watchManager.dataWatches : watchManager.existWatches;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到此zookeeper客户端源码就介绍完了</p>]]></content>
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zookeeper源码单机版服务端</title>
      <link href="/2018/04/07/zookeeper%E6%BA%90%E7%A0%81/zookeeper%E6%BA%90%E7%A0%81%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <content type="html"><![CDATA[<h2 id="zookeeper源码单机版服务端"><a href="#zookeeper源码单机版服务端" class="headerlink" title="zookeeper源码单机版服务端"></a>zookeeper源码单机版服务端</h2><h3 id="一、服务器启动过程"><a href="#一、服务器启动过程" class="headerlink" title="一、服务器启动过程"></a>一、服务器启动过程</h3><h4 id="1、ZooKeeperServerMain的nitializeAndRun方法"><a href="#1、ZooKeeperServerMain的nitializeAndRun方法" class="headerlink" title="1、ZooKeeperServerMain的nitializeAndRun方法"></a>1、ZooKeeperServerMain的nitializeAndRun方法</h4><p>单机版入口为ZooKeeperServerMain类main方法，调用了initializeAndRun方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected void initializeAndRun(String[] args)</span><br><span class="line">     throws ConfigException, IOException, AdminServerException</span><br><span class="line"> &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         ManagedUtil.registerLog4jMBeans();</span><br><span class="line">     &#125; catch (JMException e) &#123;</span><br><span class="line">         LOG.warn(&quot;Unable to register log4j JMX control&quot;, e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ServerConfig config = new ServerConfig();</span><br><span class="line">     if (args.length == 1) &#123;</span><br><span class="line">         //args[0]为配置文件路径</span><br><span class="line">         config.parse(args[0]);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         config.parse(args);</span><br><span class="line">     &#125;</span><br><span class="line">     runFromConfig(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、ServerConfig的parse方法"><a href="#2、ServerConfig的parse方法" class="headerlink" title="2、ServerConfig的parse方法"></a>2、ServerConfig的parse方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void parse(String path) throws ConfigException &#123;</span><br><span class="line">    QuorumPeerConfig config = new QuorumPeerConfig();</span><br><span class="line">    //解析配置文件</span><br><span class="line">    config.parse(path);</span><br><span class="line">    //将解析存放于QuorumPeerConfig中的配置信息赋值给ServerConfig</span><br><span class="line">    readFrom(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、runFromConfig方法"><a href="#3、runFromConfig方法" class="headerlink" title="3、runFromConfig方法"></a>3、runFromConfig方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> public void runFromConfig(ServerConfig config)</span><br><span class="line">        throws IOException, AdminServerException &#123;</span><br><span class="line">    FileTxnSnapLog txnLog = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //FileTxnSnapLog包含了日志和快照文件 </span><br><span class="line">        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);</span><br><span class="line">        //zookeeper服务器实例</span><br><span class="line">        final ZooKeeperServer zkServer = new ZooKeeperServer(txnLog,</span><br><span class="line">                config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);</span><br><span class="line">        //主线程以此等待zkServer关闭</span><br><span class="line">        final CountDownLatch shutdownLatch = new CountDownLatch(1);</span><br><span class="line">        zkServer.registerServerShutdownHandler(</span><br><span class="line">                new ZooKeeperServerShutdownHandler(shutdownLatch));</span><br><span class="line"></span><br><span class="line">        //内嵌的管理控制台是通过jetty启动,占用8080 端口</span><br><span class="line">        adminServer = AdminServerFactory.createAdminServer();</span><br><span class="line">        adminServer.setZooKeeperServer(zkServer);</span><br><span class="line">        adminServer.start();</span><br><span class="line"></span><br><span class="line">        boolean needStartZKServer = true;</span><br><span class="line">        if (config.getClientPortAddress() != null) &#123;</span><br><span class="line">            //连接工厂，默认NIOServerCnxnFactory </span><br><span class="line">            cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            //监听客户端请求，实例化接受、处理请求的线程</span><br><span class="line">            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), false);</span><br><span class="line">            cnxnFactory.startup(zkServer);</span><br><span class="line">            // zkServer has been started. So we don&apos;t need to start it again in secureCnxnFactory.</span><br><span class="line">            needStartZKServer = false;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        //定期删除子节点为空的容器节点</span><br><span class="line">        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor,</span><br><span class="line">                Integer.getInteger(&quot;znode.container.checkIntervalMs&quot;, (int) TimeUnit.MINUTES.toMillis(1)),</span><br><span class="line">                Integer.getInteger(&quot;znode.container.maxPerMinute&quot;, 10000)</span><br><span class="line">        );</span><br><span class="line">        containerManager.start();</span><br><span class="line"></span><br><span class="line">        // Watch status of ZooKeeper server. It will do a graceful shutdown</span><br><span class="line">        // if the server is not running or hits an internal error.</span><br><span class="line">        shutdownLatch.await();</span><br><span class="line"></span><br><span class="line">        shutdown();</span><br><span class="line"></span><br><span class="line">        //等待子线程执行完毕</span><br><span class="line">        if (cnxnFactory != null) &#123;</span><br><span class="line">            cnxnFactory.join();</span><br><span class="line">        &#125;</span><br><span class="line">        if (secureCnxnFactory != null) &#123;</span><br><span class="line">            secureCnxnFactory.join();</span><br><span class="line">        &#125;</span><br><span class="line">        if (zkServer.canShutdown()) &#123;</span><br><span class="line">            zkServer.shutdown(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // warn, but generally this is ok</span><br><span class="line">        LOG.warn(&quot;Server interrupted&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (txnLog != null) &#123;</span><br><span class="line">            txnLog.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、NIOServerCnxnFactory的configure方法"><a href="#4、NIOServerCnxnFactory的configure方法" class="headerlink" title="4、NIOServerCnxnFactory的configure方法"></a>4、NIOServerCnxnFactory的configure方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configure(InetSocketAddress addr, int maxcc, boolean secure) throws IOException &#123;</span><br><span class="line">    if (secure) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;SSL isn&apos;t supported in NIOServerCnxn&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    configureSaslLogin();</span><br><span class="line">    //单个客户端与单台服务器之间的连接数的限制</span><br><span class="line">    maxClientCnxns = maxcc;</span><br><span class="line">    //服务端连接过期时间</span><br><span class="line">    sessionlessCnxnTimeout = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);</span><br><span class="line">    //存放服务端接收到的连接</span><br><span class="line">    cnxnExpiryQueue =</span><br><span class="line">        new ExpiryQueue&lt;NIOServerCnxn&gt;(sessionlessCnxnTimeout);</span><br><span class="line">    //该线程关闭cnxnExpiryQueue中已经过期的连接</span><br><span class="line">    expirerThread = new ConnectionExpirerThread();</span><br><span class="line"></span><br><span class="line">    int numCores = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    // 32 cores sweet spot seems to be 4 selector threads</span><br><span class="line">    numSelectorThreads = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_NUM_SELECTOR_THREADS,</span><br><span class="line">        Math.max((int) Math.sqrt((float) numCores/2), 1));</span><br><span class="line">    if (numSelectorThreads &lt; 1) &#123;</span><br><span class="line">        throw new IOException(&quot;numSelectorThreads must be at least 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numWorkerThreads = Integer.getInteger(</span><br><span class="line">        ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);</span><br><span class="line">    workerShutdownTimeoutMS = Long.getLong(</span><br><span class="line">        ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);</span><br><span class="line"></span><br><span class="line">    //处理接收到请求的线程</span><br><span class="line">    for(int i=0; i&lt;numSelectorThreads; ++i) &#123;</span><br><span class="line">        selectorThreads.add(new SelectorThread(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.ss = ServerSocketChannel.open();</span><br><span class="line">    ss.socket().setReuseAddress(true);</span><br><span class="line">    LOG.info(&quot;binding to port &quot; + addr);</span><br><span class="line">    ss.socket().bind(addr);</span><br><span class="line">    ss.configureBlocking(false);</span><br><span class="line">    //接受客户端请求的线程</span><br><span class="line">    acceptThread = new AcceptThread(ss, addr, selectorThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（一、3）NIOServerCnxnFactory的startup方法"><a href="#5、接（一、3）NIOServerCnxnFactory的startup方法" class="headerlink" title="5、接（一、3）NIOServerCnxnFactory的startup方法"></a>5、接（一、3）NIOServerCnxnFactory的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startup(ZooKeeperServer zks, boolean startServer)</span><br><span class="line">        throws IOException, InterruptedException &#123;</span><br><span class="line">    start();</span><br><span class="line">    setZooKeeperServer(zks);</span><br><span class="line">    if (startServer) &#123;</span><br><span class="line">        zks.startdata();</span><br><span class="line">        zks.startup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、NIOServerCnxnFactory的start方法"><a href="#6、NIOServerCnxnFactory的start方法" class="headerlink" title="6、NIOServerCnxnFactory的start方法"></a>6、NIOServerCnxnFactory的start方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">    stopped = false;</span><br><span class="line">    if (workerPool == null) &#123;</span><br><span class="line">        //封装了一组线程池集合，集合大小默认2 * numCores。定长线程池大小1，</span><br><span class="line">        workerPool = new WorkerService(</span><br><span class="line">            &quot;NIOWorker&quot;, numWorkerThreads, false);</span><br><span class="line">    &#125;</span><br><span class="line">    //启动处理接收到请求的线程</span><br><span class="line">    for(SelectorThread thread : selectorThreads) &#123;</span><br><span class="line">        if (thread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动管理请求线程</span><br><span class="line">    if (acceptThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">        acceptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭cnxnExpiryQueue中已经过期的连接</span><br><span class="line">    if (expirerThread.getState() == Thread.State.NEW) &#123;</span><br><span class="line">        expirerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（一、3）实例化ZooKeeperServer"><a href="#7、接（一、3）实例化ZooKeeperServer" class="headerlink" title="7、接（一、3）实例化ZooKeeperServer"></a>7、接（一、3）实例化ZooKeeperServer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime,</span><br><span class="line">        int minSessionTimeout, int maxSessionTimeout, ZKDatabase zkDb) &#123;</span><br><span class="line">    serverStats = new ServerStats(this);</span><br><span class="line">    //封装日志和快照</span><br><span class="line">    this.txnLogFactory = txnLogFactory;</span><br><span class="line">    //内存数据ZKDatabase</span><br><span class="line">    this.zkDb = zkDb;</span><br><span class="line">    //最小事件单位</span><br><span class="line">    this.tickTime = tickTime;</span><br><span class="line">    //最小session时间</span><br><span class="line">    setMinSessionTimeout(minSessionTimeout);</span><br><span class="line">    //最大session时间</span><br><span class="line">    setMaxSessionTimeout(maxSessionTimeout);</span><br><span class="line">    listener = new ZooKeeperServerListenerImpl(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、接（一、5）ZooKeeperServer的startdata方法恢复数据s"><a href="#8、接（一、5）ZooKeeperServer的startdata方法恢复数据s" class="headerlink" title="8、接（一、5）ZooKeeperServer的startdata方法恢复数据s"></a>8、接（一、5）ZooKeeperServer的startdata方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public void startdata()</span><br><span class="line"> throws IOException, InterruptedException &#123;</span><br><span class="line">     //check to see if zkDb is not null</span><br><span class="line">     if (zkDb == null) &#123;</span><br><span class="line">         zkDb = new ZKDatabase(this.txnLogFactory);</span><br><span class="line">     &#125;</span><br><span class="line">     if (!zkDb.isInitialized()) &#123;</span><br><span class="line">//恢复数据</span><br><span class="line">         loadData();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="9、ZooKeeperServer的loadData方法恢复数据s"><a href="#9、ZooKeeperServer的loadData方法恢复数据s" class="headerlink" title="9、ZooKeeperServer的loadData方法恢复数据s"></a>9、ZooKeeperServer的loadData方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  public void loadData() throws IOException, InterruptedException &#123;</span><br><span class="line">//设置最新的事务Zxid</span><br><span class="line">      if(zkDb.isInitialized())&#123;</span><br><span class="line">          setZxid(zkDb.getDataTreeLastProcessedZxid());</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">//恢复数据</span><br><span class="line">          setZxid(zkDb.loadDataBase());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // Clean up dead sessions</span><br><span class="line">      List&lt;Long&gt; deadSessions = new LinkedList&lt;Long&gt;();</span><br><span class="line">//获取过期的session</span><br><span class="line">      for (Long session : zkDb.getSessions()) &#123;</span><br><span class="line">          if (zkDb.getSessionWithTimeOuts().get(session) == null) &#123;</span><br><span class="line">              deadSessions.add(session);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//清除过期的session</span><br><span class="line">      for (long session : deadSessions) &#123;</span><br><span class="line">          killSession(session, zkDb.getDataTreeLastProcessedZxid());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //创建一个最新的快照文件</span><br><span class="line">      takeSnapshot();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="10、ZKDatabase的loadDataBase方法恢复数据"><a href="#10、ZKDatabase的loadDataBase方法恢复数据" class="headerlink" title="10、ZKDatabase的loadDataBase方法恢复数据"></a>10、ZKDatabase的loadDataBase方法恢复数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public long loadDataBase() throws IOException &#123;</span><br><span class="line">        PlayBackListener listener=new PlayBackListener()&#123;</span><br><span class="line">            public void onTxnLoaded(TxnHeader hdr,Record txn)&#123;</span><br><span class="line">                Request r = new Request(0, hdr.getCxid(),hdr.getType(), hdr, txn, hdr.getZxid());</span><br><span class="line">                addCommittedProposal(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">//实际恢复数据的方法</span><br><span class="line">        long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);</span><br><span class="line">        initialized = true;</span><br><span class="line">        return zxid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="11、FileTxnSnapLog的restore方法恢复数据s"><a href="#11、FileTxnSnapLog的restore方法恢复数据s" class="headerlink" title="11、FileTxnSnapLog的restore方法恢复数据s"></a>11、FileTxnSnapLog的restore方法恢复数据s</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public long restore(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span><br><span class="line">           PlayBackListener listener) throws IOException &#123;</span><br><span class="line">//从快照文件中恢复数据</span><br><span class="line">       long deserializeResult = snapLog.deserialize(dt, sessions);</span><br><span class="line">//事务记录</span><br><span class="line">       FileTxnLog txnLog = new FileTxnLog(dataDir);</span><br><span class="line">       boolean trustEmptyDB;</span><br><span class="line">       File initFile = new File(dataDir.getParent(), &quot;initialize&quot;);</span><br><span class="line">       if (Files.deleteIfExists(initFile.toPath())) &#123;</span><br><span class="line">           LOG.info(&quot;Initialize file found, an empty database will not block voting participation&quot;);</span><br><span class="line">           trustEmptyDB = true;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           trustEmptyDB = autoCreateDB;</span><br><span class="line">       &#125;</span><br><span class="line">//无快照文件</span><br><span class="line">       if (-1L == deserializeResult) &#123;</span><br><span class="line">           //无快照文件，但是有事务记录</span><br><span class="line">           if (txnLog.getLastLoggedZxid() != -1) &#123;</span><br><span class="line">               throw new IOException(</span><br><span class="line">                       &quot;No snapshot found, but there are log entries. &quot; +</span><br><span class="line">                       &quot;Something is broken!&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (trustEmptyDB) &#123;</span><br><span class="line">               //创建内存快照</span><br><span class="line">               save(dt, (ConcurrentHashMap&lt;Long, Integer&gt;)sessions, false);</span><br><span class="line">               //内存DataTree数据为空</span><br><span class="line">               return 0L;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //返回-1L可能丢失数据</span><br><span class="line">               dt.lastProcessedZxid = -1L;</span><br><span class="line">               return -1L;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">//获取事务id大于最新快照文件的事务记录</span><br><span class="line">       TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);</span><br><span class="line">       long highestZxid = dt.lastProcessedZxid;</span><br><span class="line">       TxnHeader hdr;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true) &#123;</span><br><span class="line">获取事务头</span><br><span class="line">               hdr = itr.getHeader();</span><br><span class="line">//空事务记录</span><br><span class="line">               if (hdr == null) &#123;</span><br><span class="line">                   return dt.lastProcessedZxid;</span><br><span class="line">               &#125;</span><br><span class="line">//取出的事务记录id应当不小于快照中的</span><br><span class="line">               if (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != 0) &#123;</span><br><span class="line">                   LOG.error(&quot;&#123;&#125;(highestZxid) &gt; &#123;&#125;(next log) for type &#123;&#125;&quot;,</span><br><span class="line">                           highestZxid, hdr.getZxid(), hdr.getType());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   highestZxid = hdr.getZxid();</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">    //将事务执行到内存树DataTree上</span><br><span class="line">                   processTransaction(hdr,dt,sessions, itr.getTxn());</span><br><span class="line">               &#125; catch(KeeperException.NoNodeException e) &#123;</span><br><span class="line">                  throw new IOException(&quot;Failed to process transaction type: &quot; +</span><br><span class="line">                        hdr.getType() + &quot; error: &quot; + e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">//调用监听器将事务commitedLog集合，待服务恢复的时候会同步到其他leaner server</span><br><span class="line">               listener.onTxnLoaded(hdr, itr.getTxn());</span><br><span class="line">               if (!itr.next())</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (itr != null) &#123;</span><br><span class="line">               itr.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return highestZxid;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="12、接（一、5）ZooKeeperServer的startup方法"><a href="#12、接（一、5）ZooKeeperServer的startup方法" class="headerlink" title="12、接（一、5）ZooKeeperServer的startup方法"></a>12、接（一、5）ZooKeeperServer的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void startup() &#123;</span><br><span class="line">       if (sessionTracker == null) &#123;</span><br><span class="line">//创建SessionTrackerImpl用来管理Session</span><br><span class="line">           createSessionTracker();</span><br><span class="line">       &#125;</span><br><span class="line">//启动SessionTrackerImpl</span><br><span class="line">       startSessionTracker();</span><br><span class="line">//初始化处理器</span><br><span class="line">       setupRequestProcessors();</span><br><span class="line">       registerJMX();</span><br><span class="line">       setState(State.RUNNING);</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="13、ZooKeeperServer的setupRequestProcessors方法"><a href="#13、ZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="13、ZooKeeperServer的setupRequestProcessors方法"></a>13、ZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">//FinalRequestProcessor负责把已经commit的写操作应用到本机，对于读操作则从本机中读取数据并返回给client</span><br><span class="line">       RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">//这个 processor负责把写request持久化到本地磁盘</span><br><span class="line">       RequestProcessor syncProcessor = new SyncRequestProcessor(this,</span><br><span class="line">               finalProcessor);</span><br><span class="line">       ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">//为修改状态的操作建立相应的TxnHeader和Record对象</span><br><span class="line">       firstProcessor = new PrepRequestProcessor(this, syncProcessor);</span><br><span class="line">       ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="14、接（一、12）实例化SessionTrackerImpl"><a href="#14、接（一、12）实例化SessionTrackerImpl" class="headerlink" title="14、接（一、12）实例化SessionTrackerImpl"></a>14、接（一、12）实例化SessionTrackerImpl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public SessionTrackerImpl(SessionExpirer expirer,</span><br><span class="line">           ConcurrentMap&lt;Long, Integer&gt; sessionsWithTimeout, int tickTime,</span><br><span class="line">           long serverId, ZooKeeperServerListener listener)</span><br><span class="line">   &#123;</span><br><span class="line">       super(&quot;SessionTracker&quot;, listener);</span><br><span class="line">       this.expirer = expirer;</span><br><span class="line">//管理session的队列</span><br><span class="line">       this.sessionExpiryQueue = new ExpiryQueue&lt;SessionImpl&gt;(tickTime);</span><br><span class="line">       this.sessionsWithTimeout = sessionsWithTimeout;</span><br><span class="line">//初始化sessionId</span><br><span class="line">       this.nextSessionId.set(initializeNextSession(serverId));</span><br><span class="line">//恢复的数据中的sessions，加入SessionTrackerImpl</span><br><span class="line">       for (Entry&lt;Long, Integer&gt; e : sessionsWithTimeout.entrySet()) &#123;</span><br><span class="line">           addSession(e.getKey(), e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="15、SessionTrackerImpl的run方法"><a href="#15、SessionTrackerImpl的run方法" class="headerlink" title="15、SessionTrackerImpl的run方法"></a>15、SessionTrackerImpl的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (running) &#123;</span><br><span class="line">//获取最近过期时间</span><br><span class="line">               long waitTime = sessionExpiryQueue.getWaitTime();</span><br><span class="line">               if (waitTime &gt; 0) &#123;</span><br><span class="line">                   Thread.sleep(waitTime);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">//获取最近过期时间对应的Session集合</span><br><span class="line">               for (SessionImpl s : sessionExpiryQueue.poll()) &#123;</span><br><span class="line">//关闭Session</span><br><span class="line">                   setSessionClosing(s.sessionId);</span><br><span class="line">//调用ZooKeeperServer的expire方法，提交关闭session请求，关闭session</span><br><span class="line">                   expirer.expire(s);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           handleException(this.getName(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="16、接（一、13）PrepRequestProcessor的run方法"><a href="#16、接（一、13）PrepRequestProcessor的run方法" class="headerlink" title="16、接（一、13）PrepRequestProcessor的run方法"></a>16、接（一、13）PrepRequestProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true) &#123;</span><br><span class="line">//获取提交到队列中请求</span><br><span class="line">               Request request = submittedRequests.take();</span><br><span class="line">               long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">               if (request.type == OpCode.ping) &#123;</span><br><span class="line">                   traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">               &#125;</span><br><span class="line">               if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                   ZooTrace.logRequest(LOG, traceMask, &apos;P&apos;, request, &quot;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               if (Request.requestOfDeath == request) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">//处理请求</span><br><span class="line">               pRequest(request);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="17、接（一、13）SyncRequestProcessor的run方法"><a href="#17、接（一、13）SyncRequestProcessor的run方法" class="headerlink" title="17、接（一、13）SyncRequestProcessor的run方法"></a>17、接（一、13）SyncRequestProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           int logCount = 0;</span><br><span class="line">           int randRoll = r.nextInt(snapCount/2);</span><br><span class="line">           while (true) &#123;</span><br><span class="line">               Request si = null;</span><br><span class="line">               //等待刷新到本地的磁盘为空</span><br><span class="line">               if (toFlush.isEmpty()) &#123;</span><br><span class="line">                   //从等待队列中获取待处理请求</span><br><span class="line">                   si = queuedRequests.take();</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   si = queuedRequests.poll();</span><br><span class="line">                   if (si == null) &#123;</span><br><span class="line">                       //将日志文件刷新到磁盘，调用下个处理器处理队列中的请求</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //关闭请求</span><br><span class="line">               if (si == requestOfDeath) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               if (si != null) &#123;</span><br><span class="line">                   //往日志文件文件尾部添加一条记录</span><br><span class="line">                   if (zks.getZKDatabase().append(si)) &#123;</span><br><span class="line">                       logCount++;</span><br><span class="line">                       //事务达到一定数量则保存快照</span><br><span class="line">                       if (logCount &gt; (snapCount / 2 + randRoll)) &#123;</span><br><span class="line">                           randRoll = r.nextInt(snapCount/2);</span><br><span class="line">                           //将日志文件刷新到磁盘，释放资源，之后的日志开新文件保存</span><br><span class="line">                           zks.getZKDatabase().rollLog();</span><br><span class="line">                           //创建快照文件</span><br><span class="line">                           if (snapInProcess != null &amp;&amp; snapInProcess.isAlive()) &#123;</span><br><span class="line">                               LOG.warn(&quot;Too busy to snap, skipping&quot;);</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               snapInProcess = new ZooKeeperThread(&quot;Snapshot Thread&quot;) &#123;</span><br><span class="line">                                       public void run() &#123;</span><br><span class="line">                                           try &#123;</span><br><span class="line">                                               zks.takeSnapshot();</span><br><span class="line">                                           &#125; catch(Exception e) &#123;</span><br><span class="line">                                               LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;;</span><br><span class="line">                               snapInProcess.start();</span><br><span class="line">                           &#125;</span><br><span class="line">                           logCount = 0;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else if (toFlush.isEmpty()) &#123;</span><br><span class="line">                       //如果本次请求是读请求，并且没有待刷新的请求，直接调用下个处理器</span><br><span class="line">                       if (nextProcessor != null) &#123;</span><br><span class="line">                           nextProcessor.processRequest(si);</span><br><span class="line">                           if (nextProcessor instanceof Flushable) &#123;</span><br><span class="line">                               ((Flushable)nextProcessor).flush();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //本次请求添加到待刷新队列</span><br><span class="line">                   toFlush.add(si);</span><br><span class="line">                   if (toFlush.size() &gt; 1000) &#123;</span><br><span class="line">                       //将日志文件刷新到磁盘，调用下个处理器处理队列中的请求</span><br><span class="line">                       flush(toFlush);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           handleException(this.getName(), t);</span><br><span class="line">       &#125; finally&#123;</span><br><span class="line">           running = false;</span><br><span class="line">       &#125;</span><br><span class="line">       LOG.info(&quot;SyncRequestProcessor exited!&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="18、接（一、4）实例化AcceptThread"><a href="#18、接（一、4）实例化AcceptThread" class="headerlink" title="18、接（一、4）实例化AcceptThread"></a>18、接（一、4）实例化AcceptThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public AcceptThread(ServerSocketChannel ss, InetSocketAddress addr,</span><br><span class="line">        Set&lt;SelectorThread&gt; selectorThreads) throws IOException &#123;</span><br><span class="line">    super(&quot;NIOServerCxnFactory.AcceptThread:&quot; + addr);</span><br><span class="line">    //NiO服务端ServerSocketChannel</span><br><span class="line">    this.acceptSocket = ss;</span><br><span class="line">    //注册到selector指定OP_ACCEPT事件,selector在父类AbstractSelectThread中</span><br><span class="line">    this.acceptKey =</span><br><span class="line">        acceptSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    this.selectorThreads = Collections.unmodifiableList(</span><br><span class="line">        new ArrayList&lt;SelectorThread&gt;(selectorThreads));</span><br><span class="line">    selectorIterator = this.selectorThreads.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19、AcceptThread的run方法"><a href="#19、AcceptThread的run方法" class="headerlink" title="19、AcceptThread的run方法"></a>19、AcceptThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stopped &amp;&amp; !acceptSocket.socket().isClosed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理连接</span><br><span class="line">                select();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSelector();</span><br><span class="line">        // This will wake up the selector threads, and tell the</span><br><span class="line">        // worker thread pool to begin shutdown.</span><br><span class="line">        if (!reconfiguring) &#123;                    </span><br><span class="line">            NIOServerCnxnFactory.this.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20、AcceptThread的select方法"><a href="#20、AcceptThread的select方法" class="headerlink" title="20、AcceptThread的select方法"></a>20、AcceptThread的select方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void select() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //等待事件就绪</span><br><span class="line">        selector.select();</span><br><span class="line">        //获取就绪的事件</span><br><span class="line">        Iterator&lt;SelectionKey&gt; selectedKeys =</span><br><span class="line">            selector.selectedKeys().iterator();</span><br><span class="line">        while (!stopped &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = selectedKeys.next();</span><br><span class="line">            selectedKeys.remove();</span><br><span class="line"></span><br><span class="line">            if (!key.isValid()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (key.isAcceptable()) &#123;</span><br><span class="line">                //处理接到的请求</span><br><span class="line">                if (!doAccept()) &#123;</span><br><span class="line">                    //如果获取连接失败，由于需要释放资源，等待一段时间。</span><br><span class="line">                    pauseAccept(10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.warn(&quot;Unexpected ops in accept select &quot;</span><br><span class="line">                         + key.readyOps());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21、接（一、4）实例化SelectorThread"><a href="#21、接（一、4）实例化SelectorThread" class="headerlink" title="21、接（一、4）实例化SelectorThread"></a>21、接（一、4）实例化SelectorThread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public SelectorThread(int id) throws IOException &#123;</span><br><span class="line">    super(&quot;NIOServerCxnFactory.SelectorThread-&quot; + id);</span><br><span class="line">    this.id = id;</span><br><span class="line">    //接收到的客户端请求</span><br><span class="line">    acceptedQueue = new LinkedBlockingQueue&lt;SocketChannel&gt;();</span><br><span class="line">    //待修改连接指定等待事件的队列</span><br><span class="line">    updateQueue = new LinkedBlockingQueue&lt;SelectionKey&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22、SelectorThread的run方法"><a href="#22、SelectorThread的run方法" class="headerlink" title="22、SelectorThread的run方法"></a>22、SelectorThread的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stopped) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //处理请求</span><br><span class="line">                select();</span><br><span class="line">                //封装获取到的连接</span><br><span class="line">                processAcceptedConnections();</span><br><span class="line">                //修改连接指定的事件</span><br><span class="line">                processInterestOpsUpdateRequests();</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring unexpected exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //关闭连接</span><br><span class="line">        for (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line">            if (cnxn.isSelectable()) &#123;</span><br><span class="line">                cnxn.close();</span><br><span class="line">            &#125;</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        SocketChannel accepted;</span><br><span class="line">        //关闭尚未处理的连接</span><br><span class="line">        while ((accepted = acceptedQueue.poll()) != null) &#123;</span><br><span class="line">            fastCloseSock(accepted);</span><br><span class="line">        &#125;</span><br><span class="line">        updateQueue.clear();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSelector();</span><br><span class="line">        // This will wake up the accept thread and the other selector</span><br><span class="line">        // threads, and tell the worker thread pool to begin shutdown.</span><br><span class="line">        NIOServerCnxnFactory.this.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、建立连接"><a href="#二、建立连接" class="headerlink" title="二、建立连接"></a>二、建立连接</h3><h4 id="1、接（一、20）AcceptThread的doAccept"><a href="#1、接（一、20）AcceptThread的doAccept" class="headerlink" title="1、接（一、20）AcceptThread的doAccept"></a>1、接（一、20）AcceptThread的doAccept</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private boolean doAccept() &#123;</span><br><span class="line">    boolean accepted = false;</span><br><span class="line">    SocketChannel sc = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取连接</span><br><span class="line">        sc = acceptSocket.accept();</span><br><span class="line">        accepted = true;</span><br><span class="line">        //获取连接的客户端地址            </span><br><span class="line">        InetAddress ia = sc.socket().getInetAddress();</span><br><span class="line">        //该客户端的连接数量</span><br><span class="line">        int cnxncount = getClientCnxnCount(ia);</span><br><span class="line">        if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;</span><br><span class="line">            throw new IOException(&quot;Too many connections from &quot; + ia</span><br><span class="line">                                  + &quot; - max is &quot; + maxClientCnxns );</span><br><span class="line">        &#125;</span><br><span class="line">        sc.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        if (!selectorIterator.hasNext()) &#123;</span><br><span class="line">            selectorIterator = selectorThreads.iterator();</span><br><span class="line">        &#125;</span><br><span class="line">        //获取处理该次取到的SocketChannel的SelectorThread对象</span><br><span class="line">        SelectorThread selectorThread = selectorIterator.next();</span><br><span class="line">        //将获取到的SocketChannel加入到acceptedQueue队列中</span><br><span class="line">        if (!selectorThread.addAcceptedConnection(sc)) &#123;</span><br><span class="line">            throw new IOException(</span><br><span class="line">                &quot;Unable to add connection to selector queue&quot;</span><br><span class="line">                + (stopped ? &quot; (shutdown in progress)&quot; : &quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        acceptErrorLogger.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // accept, maxClientCnxns, configureBlocking</span><br><span class="line">        acceptErrorLogger.rateLimitLog(</span><br><span class="line">            &quot;Error accepting new connection: &quot; + e.getMessage());</span><br><span class="line">        fastCloseSock(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    return accepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、selectorThread的processAcceptedConnections方法"><a href="#2、selectorThread的processAcceptedConnections方法" class="headerlink" title="2、selectorThread的processAcceptedConnections方法"></a>2、selectorThread的processAcceptedConnections方法</h4><p>selectorThread处理连接run方法首先经过processAcceptedConnections<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void processAcceptedConnections() &#123;</span><br><span class="line">    SocketChannel accepted;</span><br><span class="line">    while (!stopped &amp;&amp; (accepted = acceptedQueue.poll()) != null) &#123;</span><br><span class="line">        SelectionKey key = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将获取到的SocketChannel注册到selector中，指定OP_READ事件</span><br><span class="line">            key = accepted.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            //将连接包装成NIOServerCnxn对象</span><br><span class="line">            NIOServerCnxn cnxn = createConnection(accepted, key, this);</span><br><span class="line">            key.attach(cnxn);</span><br><span class="line"></span><br><span class="line">            addCnxn(cnxn);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // register, createConnection</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">            fastCloseSock(accepted);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、SelectorThread的addCnxn方法"><a href="#3、SelectorThread的addCnxn方法" class="headerlink" title="3、SelectorThread的addCnxn方法"></a>3、SelectorThread的addCnxn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void addCnxn(NIOServerCnxn cnxn) &#123;</span><br><span class="line">    //获取客户端ip</span><br><span class="line">    InetAddress addr = cnxn.getSocketAddress();</span><br><span class="line">    //该客户端连接的集合</span><br><span class="line">    Set&lt;NIOServerCnxn&gt; set = ipMap.get(addr);</span><br><span class="line"></span><br><span class="line">    if (set == null) &#123;</span><br><span class="line">        set = Collections.newSetFromMap(</span><br><span class="line">            new ConcurrentHashMap&lt;NIOServerCnxn, Boolean&gt;(2));</span><br><span class="line">        //防止其他线程已经添加</span><br><span class="line">        Set&lt;NIOServerCnxn&gt; existingSet = ipMap.putIfAbsent(addr, set);</span><br><span class="line">        if (existingSet != null) &#123;</span><br><span class="line">            set = existingSet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //加入该ip的连接集合</span><br><span class="line">    set.add(cnxn);</span><br><span class="line">    //加入连接集合</span><br><span class="line">    cnxns.add(cnxn);</span><br><span class="line">    //该方法将cnxn添加到cnxnExpiryQueue的最新时间所对应的集合中，重原来的时间对应的集合中删除</span><br><span class="line">    touchCnxn(cnxn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、SelectorThread的select方法"><a href="#4、SelectorThread的select方法" class="headerlink" title="4、SelectorThread的select方法"></a>4、SelectorThread的select方法</h4><p>processAcceptedConnections处理完，select继续处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void select() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             //等待事件就绪</span><br><span class="line">             selector.select();</span><br><span class="line">             //获取就绪事件</span><br><span class="line">             Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</span><br><span class="line">             ArrayList&lt;SelectionKey&gt; selectedList =</span><br><span class="line">                 new ArrayList&lt;SelectionKey&gt;(selected);</span><br><span class="line">             Collections.shuffle(selectedList);</span><br><span class="line">             Iterator&lt;SelectionKey&gt; selectedKeys = selectedList.iterator();</span><br><span class="line">             while(!stopped &amp;&amp; selectedKeys.hasNext()) &#123;</span><br><span class="line">                 获取就绪事件的key</span><br><span class="line">                 SelectionKey key = selectedKeys.next();</span><br><span class="line">                 selected.remove(key);</span><br><span class="line"></span><br><span class="line">                 if (!key.isValid()) &#123;</span><br><span class="line">                     cleanupSelectionKey(key);</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (key.isReadable() || key.isWritable()) &#123;</span><br><span class="line">                     //处理就绪事件的key</span><br><span class="line">                     handleIO(key);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     LOG.warn(&quot;Unexpected ops in select &quot; + key.readyOps());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (IOException e) &#123;</span><br><span class="line">             LOG.warn(&quot;Ignoring IOException while selecting&quot;, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h4 id="5、SelectorThread的shandleIO方法"><a href="#5、SelectorThread的shandleIO方法" class="headerlink" title="5、SelectorThread的shandleIO方法"></a>5、SelectorThread的shandleIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void handleIO(SelectionKey key) &#123;</span><br><span class="line">    IOWorkRequest workRequest = new IOWorkRequest(this, key);</span><br><span class="line">    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line"></span><br><span class="line">    // 正在处理中的连接不可宣</span><br><span class="line">    cnxn.disableSelectable();</span><br><span class="line">    key.interestOps(0);</span><br><span class="line">    //将cnxn更新到最新时间所对应下的连接集合中</span><br><span class="line">    touchCnxn(cnxn);</span><br><span class="line">    //WorkerService对象中有一个线程池集合，用于执行线程ScheduledWorkRequest，</span><br><span class="line">    //ScheduledWorkRequest线程run方法，调用IOWorkRequest的doWork方法</span><br><span class="line">    workerPool.schedule(workRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、IOWorkRequest的doWork方法"><a href="#6、IOWorkRequest的doWork方法" class="headerlink" title="6、IOWorkRequest的doWork方法"></a>6、IOWorkRequest的doWork方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void doWork() throws InterruptedException &#123;</span><br><span class="line">    if (!key.isValid()) &#123;</span><br><span class="line">        selectorThread.cleanupSelectionKey(key);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key.isReadable() || key.isWritable()) &#123;</span><br><span class="line">        //处理key就绪的事件</span><br><span class="line">        cnxn.doIO(key);</span><br><span class="line"></span><br><span class="line">        // Check if we shutdown or doIO() closed this connection</span><br><span class="line">        if (stopped) &#123;</span><br><span class="line">            cnxn.close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            selectorThread.cleanupSelectionKey(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        touchCnxn(cnxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理完成标记可选</span><br><span class="line">    cnxn.enableSelectable();</span><br><span class="line">    //将key加入updateQueue队列中</span><br><span class="line">    if (!selectorThread.addInterestOpsUpdateRequest(key)) &#123;</span><br><span class="line">        cnxn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、NIOServerCnxn的doIO方法"><a href="#7、NIOServerCnxn的doIO方法" class="headerlink" title="7、NIOServerCnxn的doIO方法"></a>7、NIOServerCnxn的doIO方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void doIO(SelectionKey k) throws InterruptedException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (isSocketOpen() == false) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //就绪事件为读事件</span><br><span class="line">        if (k.isReadable()) &#123;</span><br><span class="line">            //数据读入缓冲区incomingBuffer</span><br><span class="line">            int rc = sock.read(incomingBuffer);</span><br><span class="line">            if (rc &lt; 0) &#123;</span><br><span class="line">                throw new EndOfStreamException(</span><br><span class="line">                        &quot;Unable to read additional data from client sessionid 0x&quot;</span><br><span class="line">                        + Long.toHexString(sessionId)</span><br><span class="line">                        + &quot;, likely client has closed socket&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (incomingBuffer.remaining() == 0) &#123;</span><br><span class="line">                boolean isPayload;</span><br><span class="line">//相等则说明是新请求</span><br><span class="line">                if (incomingBuffer == lenBuffer) &#123; // start of next request</span><br><span class="line">                    incomingBuffer.flip();</span><br><span class="line">//读取头四个字节，校检长度及请求类型</span><br><span class="line">                    isPayload = readLength(k);</span><br><span class="line">                    incomingBuffer.clear();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // continuation</span><br><span class="line">                    isPayload = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isPayload) &#123; // not the case for 4letterword</span><br><span class="line">//处理请求</span><br><span class="line">                    readPayload();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // four letter words take care</span><br><span class="line">                    // need not do anything else</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //就绪事件为写事件</span><br><span class="line">        if (k.isWritable()) &#123;</span><br><span class="line">            handleWrite(k);</span><br><span class="line"></span><br><span class="line">            if (!initialized &amp;&amp; !getReadInterest() &amp;&amp; !getWriteInterest()) &#123;</span><br><span class="line">                throw new CloseRequestException(&quot;responded to info probe&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、NIOServerCnxn的readPayload方法"><a href="#8、NIOServerCnxn的readPayload方法" class="headerlink" title="8、NIOServerCnxn的readPayload方法"></a>8、NIOServerCnxn的readPayload方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void readPayload() throws IOException, InterruptedException &#123;</span><br><span class="line">       if (incomingBuffer.remaining() != 0) &#123; // have we read length bytes?</span><br><span class="line">//读取客户端数据</span><br><span class="line">           int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok</span><br><span class="line">           if (rc &lt; 0) &#123;</span><br><span class="line">               throw new EndOfStreamException(</span><br><span class="line">                       &quot;Unable to read additional data from client sessionid 0x&quot;</span><br><span class="line">                       + Long.toHexString(sessionId)</span><br><span class="line">                       + &quot;, likely client has closed socket&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (incomingBuffer.remaining() == 0) &#123; // have we read length bytes?</span><br><span class="line">           //记录获取到的数据包个数</span><br><span class="line">packetReceived();</span><br><span class="line">           incomingBuffer.flip();</span><br><span class="line">           if (!initialized) &#123;</span><br><span class="line">//读取连接请求</span><br><span class="line">               readConnectRequest();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">//读取请求</span><br><span class="line">               readRequest();</span><br><span class="line">           &#125;</span><br><span class="line">           lenBuffer.clear();</span><br><span class="line">//处理完成,重置</span><br><span class="line">           incomingBuffer = lenBuffer;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="9、NIOServerCnxn的readConnectRequest方法"><a href="#9、NIOServerCnxn的readConnectRequest方法" class="headerlink" title="9、NIOServerCnxn的readConnectRequest方法"></a>9、NIOServerCnxn的readConnectRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void readConnectRequest() throws IOException, InterruptedException &#123;</span><br><span class="line">       if (!isZKServerRunning()) &#123;</span><br><span class="line">           throw new IOException(&quot;ZooKeeperServer not running&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">//处理连接请求</span><br><span class="line">       zkServer.processConnectRequest(this, incomingBuffer);</span><br><span class="line">       initialized = true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="10、ZooKeeperServer的processConnectRequest方法"><a href="#10、ZooKeeperServer的processConnectRequest方法" class="headerlink" title="10、ZooKeeperServer的processConnectRequest方法"></a>10、ZooKeeperServer的processConnectRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">       BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));</span><br><span class="line">       ConnectRequest connReq = new ConnectRequest();</span><br><span class="line">       //反序列化请求数据</span><br><span class="line">connReq.deserialize(bia, &quot;connect&quot;);</span><br><span class="line">       boolean readOnly = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           readOnly = bia.readBool(&quot;readOnly&quot;);</span><br><span class="line">           cnxn.isOldClient = false;</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">//客户端非只读，而服务端为只读服务器</span><br><span class="line">       if (!readOnly &amp;&amp; this instanceof ReadOnlyZooKeeperServer) &#123;</span><br><span class="line">           String msg = &quot;Refusing session request for not-read-only client &quot;</span><br><span class="line">               + cnxn.getRemoteSocketAddress();</span><br><span class="line">           LOG.info(msg);</span><br><span class="line">           throw new CloseRequestException(msg);</span><br><span class="line">       &#125;</span><br><span class="line">//客户端的事务id大于服务端，需要重连其他服务器</span><br><span class="line">       if (connReq.getLastZxidSeen() &gt; zkDb.dataTree.lastProcessedZxid) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       int sessionTimeout = connReq.getTimeOut();</span><br><span class="line">       byte passwd[] = connReq.getPasswd();</span><br><span class="line">       int minSessionTimeout = getMinSessionTimeout();</span><br><span class="line">       if (sessionTimeout &lt; minSessionTimeout) &#123;</span><br><span class="line">           sessionTimeout = minSessionTimeout;</span><br><span class="line">       &#125;</span><br><span class="line">       int maxSessionTimeout = getMaxSessionTimeout();</span><br><span class="line">       if (sessionTimeout &gt; maxSessionTimeout) &#123;</span><br><span class="line">           sessionTimeout = maxSessionTimeout;</span><br><span class="line">       &#125;</span><br><span class="line">//协商后的Session超时事件</span><br><span class="line">       cnxn.setSessionTimeout(sessionTimeout);</span><br><span class="line">       //停止接受新的请求，把SelectionKey加入updateQueue中，见（二、17）</span><br><span class="line">       cnxn.disableRecv();</span><br><span class="line">       long sessionId = connReq.getSessionId();</span><br><span class="line">//sessionId == 0新客户端连接，否则短线重连</span><br><span class="line">       if (sessionId == 0) &#123;</span><br><span class="line">//创建session</span><br><span class="line">           createSession(cnxn, passwd, sessionTimeout);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           long clientSessionId = connReq.getSessionId();</span><br><span class="line">           //sessionMap中移除sessionId，关闭旧连接</span><br><span class="line">           if (serverCnxnFactory != null) &#123;</span><br><span class="line">               serverCnxnFactory.closeSession(sessionId);</span><br><span class="line">           &#125;</span><br><span class="line">           if (secureServerCnxnFactory != null) &#123;</span><br><span class="line">               secureServerCnxnFactory.closeSession(sessionId);</span><br><span class="line">           &#125;</span><br><span class="line">//添加新sessionId</span><br><span class="line">           cnxn.setSessionId(sessionId);</span><br><span class="line">           reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="11、ZooKeeperServer的createSession方法"><a href="#11、ZooKeeperServer的createSession方法" class="headerlink" title="11、ZooKeeperServer的createSession方法"></a>11、ZooKeeperServer的createSession方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;</span><br><span class="line">       if (passwd == null) &#123;</span><br><span class="line">           passwd = new byte[0];</span><br><span class="line">       &#125;</span><br><span class="line">//创建session</span><br><span class="line">       long sessionId = sessionTracker.createSession(timeout);</span><br><span class="line">       Random r = new Random(sessionId ^ superSecret);</span><br><span class="line">       r.nextBytes(passwd);</span><br><span class="line">       ByteBuffer to = ByteBuffer.allocate(4);</span><br><span class="line">       to.putInt(timeout);</span><br><span class="line">//sessionMap中加入sessionId及本连接对象</span><br><span class="line">       cnxn.setSessionId(sessionId);</span><br><span class="line">//创建Session请求</span><br><span class="line">       Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);</span><br><span class="line">setLocalSessionFlag(si);</span><br><span class="line">//提交请求</span><br><span class="line">       submitRequest(si);</span><br><span class="line">       return sessionId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="12、ZooKeeperServer的submitRequest方法"><a href="#12、ZooKeeperServer的submitRequest方法" class="headerlink" title="12、ZooKeeperServer的submitRequest方法"></a>12、ZooKeeperServer的submitRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void submitRequest(Request si) &#123;</span><br><span class="line">       if (firstProcessor == null) &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">//等待初始化</span><br><span class="line">                   while (state == State.INITIAL) &#123;</span><br><span class="line">                       wait(1000);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   LOG.warn(&quot;Unexpected interruption&quot;, e);</span><br><span class="line">               &#125;</span><br><span class="line">               if (firstProcessor == null || state != State.RUNNING) &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;Not started&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           touch(si.cnxn);</span><br><span class="line">           boolean validpacket = Request.isValid(si.type);</span><br><span class="line">           if (validpacket) &#123;</span><br><span class="line">//请求加入处理器待处理请求队列,处理器为prepRequestProcessor</span><br><span class="line">               firstProcessor.processRequest(si);</span><br><span class="line">               if (si.cnxn != null) &#123;</span><br><span class="line">//正在处理的请求加一</span><br><span class="line">                   incInProcess();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               new UnimplementedRequestProcessor().processRequest(si);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="13、prepRequestProcessor的pRequest方法"><a href="#13、prepRequestProcessor的pRequest方法" class="headerlink" title="13、prepRequestProcessor的pRequest方法"></a>13、prepRequestProcessor的pRequest方法</h4><p>prepRequestProcessor从请求队列中获取请求后调用pRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">       request.setHdr(null);</span><br><span class="line">       request.setTxn(null);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           switch (request.type) &#123;</span><br><span class="line">           //为不同请求生成请求对象</span><br><span class="line">           case OpCode.createContainer:</span><br><span class="line">           case OpCode.create:</span><br><span class="line">           case OpCode.create2:</span><br><span class="line">               CreateRequest create2Request = new CreateRequest();</span><br><span class="line">               pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);</span><br><span class="line">               break;</span><br><span class="line">           ...</span><br><span class="line">           //create/close session don&apos;t require request record</span><br><span class="line">           case OpCode.createSession:</span><br><span class="line">           case OpCode.closeSession:</span><br><span class="line">               if (!request.isLocalSession()) &#123;</span><br><span class="line">                   pRequest2Txn(request.type, zks.getNextZxid(), request,</span><br><span class="line">                                null, true);</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">           //下列请求只需要验证Session</span><br><span class="line">           case OpCode.sync:</span><br><span class="line">           case OpCode.exists:</span><br><span class="line">           case OpCode.getData:</span><br><span class="line">           case OpCode.getACL:</span><br><span class="line">           case OpCode.getChildren:</span><br><span class="line">           case OpCode.getChildren2:</span><br><span class="line">           case OpCode.ping:</span><br><span class="line">           case OpCode.setWatches:</span><br><span class="line">           case OpCode.checkWatches:</span><br><span class="line">           case OpCode.removeWatches:</span><br><span class="line">               zks.sessionTracker.checkSession(request.sessionId,</span><br><span class="line">                       request.getOwner());</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       ...</span><br><span class="line">       //获取事务zxid</span><br><span class="line">       request.zxid = zks.getZxid();</span><br><span class="line">       //提交到下个处理器处理</span><br><span class="line">       nextProcessor.processRequest(request);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="14、PrepRequestProcessor的pRequest2Txn方法"><a href="#14、PrepRequestProcessor的pRequest2Txn方法" class="headerlink" title="14、PrepRequestProcessor的pRequest2Txn方法"></a>14、PrepRequestProcessor的pRequest2Txn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                            Record record, boolean deserialize)</span><br><span class="line">    throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">    // 创建事务头</span><br><span class="line">    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">            Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //请求类型为创建会话请求</span><br><span class="line">        case OpCode.createSession:</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            int to = request.request.getInt();</span><br><span class="line">            //创建会话请求</span><br><span class="line">            request.setTxn(new CreateSessionTxn(to));</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            //往sessionTrackerImpl中添加新session</span><br><span class="line">            if (request.isLocalSession()) &#123;</span><br><span class="line">                // This will add to local session tracker if it is enabled</span><br><span class="line">                zks.sessionTracker.addSession(request.sessionId, to);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Explicitly add to global session if the flag is not set</span><br><span class="line">                zks.sessionTracker.addGlobalSession(request.sessionId, to);</span><br><span class="line">            &#125;</span><br><span class="line">            //设置该session所属的客户端</span><br><span class="line">            zks.setOwner(request.sessionId, request.getOwner());</span><br><span class="line">            break;</span><br><span class="line">        // 关闭会话请求</span><br><span class="line">        case OpCode.closeSession:</span><br><span class="line">            //获取该session对应的临时节点</span><br><span class="line">            Set&lt;String&gt; es = zks.getZKDatabase()</span><br><span class="line">                    .getEphemerals(request.sessionId);</span><br><span class="line">            synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">                for (ChangeRecord c : zks.outstandingChanges) &#123;</span><br><span class="line">                    if (c.stat == null) &#123;</span><br><span class="line">                        // Doing a delete</span><br><span class="line">                        es.remove(c.path);</span><br><span class="line">                    &#125; else if (c.stat.getEphemeralOwner() == request.sessionId) &#123;</span><br><span class="line">                        //添加到零时节点路径集合</span><br><span class="line">                        es.add(c.path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for (String path2Delete : es) &#123;</span><br><span class="line">                    //添加变更记录</span><br><span class="line">                    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));</span><br><span class="line">                &#125;</span><br><span class="line">                //关闭session</span><br><span class="line">                zks.sessionTracker.setSessionClosing(request.sessionId);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">        default:</span><br><span class="line">            LOG.warn(&quot;unknown type &quot; + type);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、FinalRequestProcessor的processRequest方法"><a href="#15、FinalRequestProcessor的processRequest方法" class="headerlink" title="15、FinalRequestProcessor的processRequest方法"></a>15、FinalRequestProcessor的processRequest方法</h4><p>SyncRequestProcessor的获取到请求，添加完日志文件如（一、17），之后调用FinalRequestProcessor的processRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    // request.addRQRec(&quot;&gt;final&quot;);</span><br><span class="line">    long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">    if (request.type == OpCode.ping) &#123;</span><br><span class="line">        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    ProcessTxnResult rc = null;</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        // zookeeperserver处理请求</span><br><span class="line">        rc = zks.processTxn(request);</span><br><span class="line"></span><br><span class="line">        // request.hdr is set for write requests, which are the only ones</span><br><span class="line">        // that add to outstandingChanges.</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            TxnHeader hdr = request.getHdr();</span><br><span class="line">            Record txn = request.getTxn();</span><br><span class="line">            long zxid = hdr.getZxid();</span><br><span class="line">            // outstandingChanges不为空且首个元素的zxid小于等于请求的zxid，移除首个元素</span><br><span class="line">            while (!zks.outstandingChanges.isEmpty()</span><br><span class="line">                   &amp;&amp; zks.outstandingChanges.get(0).zxid &lt;= zxid) &#123;</span><br><span class="line">                ChangeRecord cr = zks.outstandingChanges.remove(0);</span><br><span class="line">                if (zks.outstandingChangesForPath.get(cr.path) == cr) &#123;</span><br><span class="line">                    // 移除cr的路径对应的记录</span><br><span class="line">                    zks.outstandingChangesForPath.remove(cr.path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 判断是否是集群范围的请求</span><br><span class="line">        if (request.isQuorum()) &#123;</span><br><span class="line">            //加入集群最近Commit提议队列</span><br><span class="line">            zks.getZKDatabase().addCommittedProposal(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接请求，连接已关闭</span><br><span class="line">    if (request.type == OpCode.closeSession &amp;&amp; connClosedByClient(request)) &#123;</span><br><span class="line">        //关闭Session</span><br><span class="line">        if (closeSession(zks.serverCnxnFactory, request.sessionId) ||</span><br><span class="line">                closeSession(zks.secureServerCnxnFactory, request.sessionId)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (request.cnxn == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ServerCnxn cnxn = request.cnxn;</span><br><span class="line"></span><br><span class="line">    String lastOp = &quot;NA&quot;;</span><br><span class="line">    zks.decInProcess();</span><br><span class="line">    Code err = Code.OK;</span><br><span class="line">    Record rsp = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        case OpCode.ping: &#123;</span><br><span class="line">            //更新等待时间</span><br><span class="line">            zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">            lastOp = &quot;PING&quot;;</span><br><span class="line">            // 更新响应的状态</span><br><span class="line">            cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">                    request.createTime, Time.currentElapsedTime());</span><br><span class="line">            // 发回响应</span><br><span class="line">            cnxn.sendResponse(new ReplyHeader(-2,</span><br><span class="line">                    zks.getZKDatabase().getDataTreeLastProcessedZxid(), 0), null, &quot;response&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        case OpCode.createSession: &#123;</span><br><span class="line">            zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">            lastOp = &quot;SESS&quot;;</span><br><span class="line">            // 更新响应的状态</span><br><span class="line">            cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">                    request.createTime, Time.currentElapsedTime());</span><br><span class="line">            //完成session的初始化</span><br><span class="line">            zks.finishSessionInit(request.cnxn, true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="16、ZooKeeperServer的processTxn方法"><a href="#16、ZooKeeperServer的processTxn方法" class="headerlink" title="16、ZooKeeperServer的processTxn方法"></a>16、ZooKeeperServer的processTxn方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private ProcessTxnResult processTxn(Request request, TxnHeader hdr,</span><br><span class="line">                                    Record txn) &#123;</span><br><span class="line">    ProcessTxnResult rc;</span><br><span class="line">    int opCode = request != null ? request.type : hdr.getType();</span><br><span class="line">    long sessionId = request != null ? request.sessionId : hdr.getClientId();</span><br><span class="line">    //无请求头为读请求</span><br><span class="line">    if (hdr != null) &#123;</span><br><span class="line">        //处理普通请求</span><br><span class="line">        rc = getZKDatabase().processTxn(hdr, txn);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //读请求处理结果，空的，后续会处理。</span><br><span class="line">        rc = new ProcessTxnResult();</span><br><span class="line">    &#125;</span><br><span class="line">    if (opCode == OpCode.createSession) &#123;</span><br><span class="line">        if (hdr != null &amp;&amp; txn instanceof CreateSessionTxn) &#123;</span><br><span class="line">            CreateSessionTxn cst = (CreateSessionTxn) txn;</span><br><span class="line">            //添加session</span><br><span class="line">            sessionTracker.addGlobalSession(sessionId, cst.getTimeOut());</span><br><span class="line">        &#125; else if (request != null &amp;&amp; request.isLocalSession()) &#123;</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            int timeout = request.request.getInt();</span><br><span class="line">            request.request.rewind();</span><br><span class="line">            //添加session</span><br><span class="line">            sessionTracker.addSession(request.sessionId, timeout);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (opCode == OpCode.closeSession) &#123;</span><br><span class="line">        //关闭session</span><br><span class="line">        sessionTracker.removeSession(sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、接（二、15）ZooKeeperServer的finishSessionInit方法"><a href="#17、接（二、15）ZooKeeperServer的finishSessionInit方法" class="headerlink" title="17、接（二、15）ZooKeeperServer的finishSessionInit方法"></a>17、接（二、15）ZooKeeperServer的finishSessionInit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void finishSessionInit(ServerCnxn cnxn, boolean valid) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建连接请求返回</span><br><span class="line">        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout()</span><br><span class="line">                : 0, valid ? cnxn.getSessionId() : 0, // send 0 if session is no</span><br><span class="line">                        // longer valid</span><br><span class="line">                        valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">        bos.writeInt(-1, &quot;len&quot;);</span><br><span class="line">        rsp.serialize(bos, &quot;connect&quot;);</span><br><span class="line">        if (!cnxn.isOldClient) &#123;</span><br><span class="line">            bos.writeBool(</span><br><span class="line">                    this instanceof ReadOnlyZooKeeperServer, &quot;readOnly&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.close();</span><br><span class="line">        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());</span><br><span class="line">        bb.putInt(bb.remaining() - 4).rewind();</span><br><span class="line">        //发送返回数据包裹</span><br><span class="line">        cnxn.sendBuffer(bb);</span><br><span class="line"></span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            //连接已完成，允许接受新请求</span><br><span class="line">            cnxn.enableRecv();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cnxn.sendBuffer(ServerCnxnFactory.closeConn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        cnxn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、SelectorThread的processInterestOpsUpdateRequests方法"><a href="#18、SelectorThread的processInterestOpsUpdateRequests方法" class="headerlink" title="18、SelectorThread的processInterestOpsUpdateRequests方法"></a>18、SelectorThread的processInterestOpsUpdateRequests方法</h4><p>连接建立完成，允许key接受读取事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void processInterestOpsUpdateRequests() &#123;</span><br><span class="line">    SelectionKey key;</span><br><span class="line">    while (!stopped &amp;&amp; (key = updateQueue.poll()) != null) &#123;</span><br><span class="line">        if (!key.isValid()) &#123;</span><br><span class="line">            cleanupSelectionKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();</span><br><span class="line">        if (cnxn.isSelectable()) &#123;</span><br><span class="line">            //key指定事件</span><br><span class="line">            key.interestOps(cnxn.getInterestOps());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，连接就建立完成了。</p><h3 id="三、create请求处理过程"><a href="#三、create请求处理过程" class="headerlink" title="三、create请求处理过程"></a>三、create请求处理过程</h3><h4 id="1、接（二、8）NIOServerCnxn的readRequest-方法"><a href="#1、接（二、8）NIOServerCnxn的readRequest-方法" class="headerlink" title="1、接（二、8）NIOServerCnxn的readRequest 方法"></a>1、接（二、8）NIOServerCnxn的readRequest 方法</h4><p>处理普通连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void readRequest() throws IOException &#123;</span><br><span class="line">    zkServer.processPacket(this, incomingBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、ZooKeeperServer的processPacket方法"><a href="#2、ZooKeeperServer的processPacket方法" class="headerlink" title="2、ZooKeeperServer的processPacket方法"></a>2、ZooKeeperServer的processPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    // We have the request, now process and setup for next</span><br><span class="line">    InputStream bais = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">    BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);</span><br><span class="line">    RequestHeader h = new RequestHeader();</span><br><span class="line">    h.deserialize(bia, &quot;header&quot;);</span><br><span class="line">    incomingBuffer = incomingBuffer.slice();</span><br><span class="line">    if (h.getType() == OpCode.auth) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (h.getType() == OpCode.sasl) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //封装请求</span><br><span class="line">            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(),</span><br><span class="line">              h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">            si.setOwner(ServerCnxn.me);</span><br><span class="line">            setLocalSessionFlag(si);</span><br><span class="line">            //将请求加入处理器等待队列（见二、12）</span><br><span class="line">            submitRequest(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //提交但还未返回的请求数增加1</span><br><span class="line">    cnxn.incrOutstandingRequests(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、PrepRequestProcessor的pRequest2Txn方法"><a href="#3、PrepRequestProcessor的pRequest2Txn方法" class="headerlink" title="3、PrepRequestProcessor的pRequest2Txn方法"></a>3、PrepRequestProcessor的pRequest2Txn方法</h4><p>前面和创建session请求相同，直到pRequest2Txn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                            Record record, boolean deserialize)</span><br><span class="line">    throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">            Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case OpCode.create:</span><br><span class="line">        case OpCode.create2:</span><br><span class="line">        case OpCode.createTTL:</span><br><span class="line">        case OpCode.createContainer: &#123;</span><br><span class="line">            //处理增加请求</span><br><span class="line">            pRequest2TxnCreate(type, request, record, deserialize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            LOG.warn(&quot;unknown type &quot; + type);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、PrepRequestProcessor的pRequest2TxnCreate方法"><a href="#4、PrepRequestProcessor的pRequest2TxnCreate方法" class="headerlink" title="4、PrepRequestProcessor的pRequest2TxnCreate方法"></a>4、PrepRequestProcessor的pRequest2TxnCreate方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private void pRequest2TxnCreate(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException &#123;</span><br><span class="line">    if (deserialize) &#123;</span><br><span class="line">        ByteBufferInputStream.byteBuffer2Record(request.request, record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int flags;</span><br><span class="line">    String path;</span><br><span class="line">    List&lt;ACL&gt; acl;</span><br><span class="line">    byte[] data;</span><br><span class="line">    long ttl;</span><br><span class="line">    if (type == OpCode.createTTL) &#123;</span><br><span class="line">        CreateTTLRequest createTtlRequest = (CreateTTLRequest)record;</span><br><span class="line">        flags = createTtlRequest.getFlags();</span><br><span class="line">        path = createTtlRequest.getPath();</span><br><span class="line">        acl = createTtlRequest.getAcl();</span><br><span class="line">        data = createTtlRequest.getData();</span><br><span class="line">        ttl = createTtlRequest.getTtl();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CreateRequest createRequest = (CreateRequest)record;</span><br><span class="line">        flags = createRequest.getFlags();</span><br><span class="line">        path = createRequest.getPath();</span><br><span class="line">        acl = createRequest.getAcl();</span><br><span class="line">        data = createRequest.getData();</span><br><span class="line">        ttl = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateMode createMode = CreateMode.fromFlag(flags);</span><br><span class="line">    validateCreateRequest(path, createMode, request, ttl);</span><br><span class="line">    String parentPath = validatePathForCreate(path, request.sessionId);</span><br><span class="line"></span><br><span class="line">    List&lt;ACL&gt; listACL = fixupACL(path, request.authInfo, acl);</span><br><span class="line">    //父节点的最新变化记录</span><br><span class="line">    ChangeRecord parentRecord = getRecordForPath(parentPath);</span><br><span class="line">    checkACL(zks, request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);</span><br><span class="line">    //父节点修改次数</span><br><span class="line">    int parentCVersion = parentRecord.stat.getCversion();</span><br><span class="line">    //按顺序创建</span><br><span class="line">    if (createMode.isSequential()) &#123;</span><br><span class="line">        path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    validatePath(path, request.sessionId);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (getRecordForPath(path) != null) &#123;</span><br><span class="line">            throw new KeeperException.NodeExistsException(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (KeeperException.NoNodeException e) &#123;</span><br><span class="line">        // ignore this one</span><br><span class="line">    &#125;</span><br><span class="line">    //临时节点不允许创建子节点</span><br><span class="line">    boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;</span><br><span class="line">    if (ephemeralParent) &#123;</span><br><span class="line">        throw new KeeperException.NoChildrenForEphemeralsException(path);</span><br><span class="line">    &#125;</span><br><span class="line">    //子节点修改次数</span><br><span class="line">    int newCversion = parentRecord.stat.getCversion()+1;</span><br><span class="line">    //创建具体事务</span><br><span class="line">    if (type == OpCode.createContainer) &#123;</span><br><span class="line">        request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));</span><br><span class="line">    &#125; else if (type == OpCode.createTTL) &#123;</span><br><span class="line">        request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(),</span><br><span class="line">                newCversion));</span><br><span class="line">    &#125;</span><br><span class="line">    StatPersisted s = new StatPersisted();</span><br><span class="line">    if (createMode.isEphemeral()) &#123;</span><br><span class="line">        s.setEphemeralOwner(request.sessionId);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建最新的父节点变化记录</span><br><span class="line">    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());</span><br><span class="line">    parentRecord.childCount++;</span><br><span class="line">    parentRecord.stat.setCversion(newCversion);</span><br><span class="line">    //添加父节点最新的变化记录</span><br><span class="line">    addChangeRecord(parentRecord);</span><br><span class="line">    //添加本节点最新的变化记录</span><br><span class="line">    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、FinalRequestProcessor的processRequest方法"><a href="#5、FinalRequestProcessor的processRequest方法" class="headerlink" title="5、FinalRequestProcessor的processRequest方法"></a>5、FinalRequestProcessor的processRequest方法</h4><p>SyncRequestProcessor处理也与创建session相同，直到FinalRequestProcessor的processRequest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ProcessTxnResult rc = null;</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        //处理请求</span><br><span class="line">        rc = zks.processTxn(request);</span><br><span class="line"></span><br><span class="line">        // request.hdr is set for write requests, which are the only ones</span><br><span class="line">        // that add to outstandingChanges.</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            TxnHeader hdr = request.getHdr();</span><br><span class="line">            Record txn = request.getTxn();</span><br><span class="line">            long zxid = hdr.getZxid();</span><br><span class="line">            while (!zks.outstandingChanges.isEmpty()</span><br><span class="line">                   &amp;&amp; zks.outstandingChanges.get(0).zxid &lt;= zxid) &#123;</span><br><span class="line">                ChangeRecord cr = zks.outstandingChanges.remove(0);</span><br><span class="line">                if (cr.zxid &lt; zxid) &#123;</span><br><span class="line">                    LOG.warn(&quot;Zxid outstanding &quot; + cr.zxid</span><br><span class="line">                             + &quot; is less than current &quot; + zxid);</span><br><span class="line">                &#125;</span><br><span class="line">                if (zks.outstandingChangesForPath.get(cr.path) == cr) &#123;</span><br><span class="line">                    zks.outstandingChangesForPath.remove(cr.path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // do not add non quorum packets to the queue.</span><br><span class="line">        if (request.isQuorum()) &#123;</span><br><span class="line">            zks.getZKDatabase().addCommittedProposal(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case OpCode.create: &#123;</span><br><span class="line">            lastOp = &quot;CREA&quot;;</span><br><span class="line">            //创建请求返回</span><br><span class="line">            rsp = new CreateResponse(rc.path);</span><br><span class="line">            err = Code.get(rc.err);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case OpCode.create2:</span><br><span class="line">        case OpCode.createTTL:</span><br><span class="line">        case OpCode.createContainer: &#123;</span><br><span class="line">            lastOp = &quot;CREA&quot;;</span><br><span class="line">            //创建请求返回</span><br><span class="line">            rsp = new Create2Response(rc.path, rc.stat);</span><br><span class="line">            err = Code.get(rc.err);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch ...</span><br><span class="line">    //获取最近的一个事务编号</span><br><span class="line">    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">    //创建返回头</span><br><span class="line">    ReplyHeader hdr =</span><br><span class="line">        new ReplyHeader(request.cxid, lastZxid, err.intValue());</span><br><span class="line"></span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">    //更新响应状态</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,</span><br><span class="line">                request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //返回数据</span><br><span class="line">        cnxn.sendResponse(hdr, rsp, &quot;response&quot;);</span><br><span class="line">        if (request.type == OpCode.closeSession) &#123;</span><br><span class="line">            cnxn.sendCloseSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;FIXMSG&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6、DataTree的processTxn方法"><a href="#6、DataTree的processTxn方法" class="headerlink" title="6、DataTree的processTxn方法"></a>6、DataTree的processTxn方法</h4><p>之后与（二、15）同，接（二、16）依次调用ZKDatabase、DataTree的processTxn方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public ProcessTxnResult processTxn(TxnHeader header, Record txn)</span><br><span class="line">&#123;</span><br><span class="line">    ProcessTxnResult rc = new ProcessTxnResult();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        rc.clientId = header.getClientId();</span><br><span class="line">        rc.cxid = header.getCxid();</span><br><span class="line">        rc.zxid = header.getZxid();</span><br><span class="line">        rc.type = header.getType();</span><br><span class="line">        rc.err = 0;</span><br><span class="line">        rc.multiResult = null;</span><br><span class="line">        switch (header.getType()) &#123;</span><br><span class="line">            case OpCode.create:</span><br><span class="line">                CreateTxn createTxn = (CreateTxn) txn;</span><br><span class="line">                rc.path = createTxn.getPath();</span><br><span class="line">                createNode(</span><br><span class="line">                        createTxn.getPath(),</span><br><span class="line">                        createTxn.getData(),</span><br><span class="line">                        createTxn.getAcl(),</span><br><span class="line">                        createTxn.getEphemeral() ? header.getClientId() : 0,</span><br><span class="line">                        createTxn.getParentCVersion(),</span><br><span class="line">                        header.getZxid(), header.getTime(), null);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch </span><br><span class="line">    ...</span><br><span class="line">    //更新最新处理Zxid</span><br><span class="line">    if (rc.zxid &gt; lastProcessedZxid) &#123;</span><br><span class="line">        lastProcessedZxid = rc.zxid;</span><br><span class="line">    &#125;</span><br><span class="line">    //要创建的节点已存在</span><br><span class="line">    if (header.getType() == OpCode.create &amp;&amp;</span><br><span class="line">            rc.err == Code.NODEEXISTS.intValue()) &#123;</span><br><span class="line">        int lastSlash = rc.path.lastIndexOf(&apos;/&apos;);</span><br><span class="line">        String parentName = rc.path.substring(0, lastSlash);</span><br><span class="line">        CreateTxn cTxn = (CreateTxn)txn;</span><br><span class="line">        try &#123;</span><br><span class="line">            //更新节点相关信息（修改次数、Zxid）</span><br><span class="line">            setCversionPzxid(parentName, cTxn.getParentCVersion(),</span><br><span class="line">                    header.getZxid());</span><br><span class="line">        &#125; catch (KeeperException.NoNodeException e) &#123;</span><br><span class="line">            LOG.error(&quot;Failed to set parent cversion for: &quot; +</span><br><span class="line">                  parentName, e);</span><br><span class="line">            rc.err = e.code().intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (rc.err != Code.OK.intValue()) &#123;</span><br><span class="line">        LOG.debug(&quot;Ignoring processTxn failure hdr: &quot; + header.getType() +</span><br><span class="line">              &quot; : error: &quot; + rc.err);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、DataTree的createNode方法"><a href="#7、DataTree的createNode方法" class="headerlink" title="7、DataTree的createNode方法"></a>7、DataTree的createNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void createNode(final String path, byte data[], List&lt;ACL&gt; acl,</span><br><span class="line">        long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat)</span><br><span class="line">        throws KeeperException.NoNodeException,</span><br><span class="line">        KeeperException.NodeExistsException &#123;</span><br><span class="line">    int lastSlash = path.lastIndexOf(&apos;/&apos;);</span><br><span class="line">    String parentName = path.substring(0, lastSlash);</span><br><span class="line">    String childName = path.substring(lastSlash + 1);</span><br><span class="line">    StatPersisted stat = new StatPersisted();</span><br><span class="line">    stat.setCtime(time);</span><br><span class="line">    stat.setMtime(time);</span><br><span class="line">    stat.setCzxid(zxid);</span><br><span class="line">    stat.setMzxid(zxid);</span><br><span class="line">    stat.setPzxid(zxid);</span><br><span class="line">    stat.setVersion(0);</span><br><span class="line">    stat.setAversion(0);</span><br><span class="line">    stat.setEphemeralOwner(ephemeralOwner);</span><br><span class="line">    //父节点</span><br><span class="line">    DataNode parent = nodes.get(parentName);</span><br><span class="line">    if (parent == null) &#123;</span><br><span class="line">        throw new KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (parent) &#123;</span><br><span class="line">        //父节点的子节点集合</span><br><span class="line">        Set&lt;String&gt; children = parent.getChildren();</span><br><span class="line">        if (children.contains(childName)) &#123;</span><br><span class="line">            throw new KeeperException.NodeExistsException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentCVersion == -1) &#123;</span><br><span class="line">            parentCVersion = parent.stat.getCversion();</span><br><span class="line">            parentCVersion++;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.stat.setCversion(parentCVersion);</span><br><span class="line">        parent.stat.setPzxid(zxid);</span><br><span class="line">        Long longval = aclCache.convertAcls(acl);</span><br><span class="line">        //创建节点</span><br><span class="line">        DataNode child = new DataNode(data, longval, stat);</span><br><span class="line">        //添加子节点名</span><br><span class="line">        parent.addChild(childName);</span><br><span class="line">        //添加子节点</span><br><span class="line">        nodes.put(path, child);</span><br><span class="line">        //节点类型</span><br><span class="line">        EphemeralType ephemeralType = EphemeralType.get(ephemeralOwner);</span><br><span class="line">        if (ephemeralType == EphemeralType.CONTAINER) &#123;</span><br><span class="line">            containers.add(path);</span><br><span class="line">        &#125; else if (ephemeralType == EphemeralType.TTL) &#123;</span><br><span class="line">            ttls.add(path);</span><br><span class="line">        &#125; else if (ephemeralOwner != 0) &#123;</span><br><span class="line">            //添加入零时节点</span><br><span class="line">            HashSet&lt;String&gt; list = ephemerals.get(ephemeralOwner);</span><br><span class="line">            if (list == null) &#123;</span><br><span class="line">                list = new HashSet&lt;String&gt;();</span><br><span class="line">                ephemerals.put(ephemeralOwner, list);</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (list) &#123;</span><br><span class="line">                list.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (outputStat != null) &#123;</span><br><span class="line">            child.copyStat(outputStat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // now check if its one of the zookeeper node child</span><br><span class="line">    if (parentName.startsWith(quotaZookeeper)) &#123;</span><br><span class="line">        // now check if its the limit node</span><br><span class="line">        if (Quotas.limitNode.equals(childName)) &#123;</span><br><span class="line">            // this is the limit node</span><br><span class="line">            // get the parent and add it to the trie</span><br><span class="line">            pTrie.addPath(parentName.substring(quotaZookeeper.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (Quotas.statNode.equals(childName)) &#123;</span><br><span class="line">            updateQuotaForPath(parentName</span><br><span class="line">                    .substring(quotaZookeeper.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // also check to update the quotas for this node</span><br><span class="line">    String lastPrefix = getMaxPrefixWithQuota(path);</span><br><span class="line">    if(lastPrefix != null) &#123;</span><br><span class="line">        // ok we have some match and need to update</span><br><span class="line">        updateCount(lastPrefix, 1);</span><br><span class="line">        updateBytes(lastPrefix, data == null ? 0 : data.length);</span><br><span class="line">    &#125;</span><br><span class="line">    //触发该事件对应的监听器</span><br><span class="line">    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);</span><br><span class="line">    childWatches.triggerWatch(parentName.equals(&quot;&quot;) ? &quot;/&quot; : parentName,</span><br><span class="line">            Event.EventType.NodeChildrenChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建节点到这里就结束了</p><h3 id="四、exists请求添加监听器，处理过程"><a href="#四、exists请求添加监听器，处理过程" class="headerlink" title="四、exists请求添加监听器，处理过程"></a>四、exists请求添加监听器，处理过程</h3><h4 id="1、接（三、5）PrepRequestProcessor的processRequest方法"><a href="#1、接（三、5）PrepRequestProcessor的processRequest方法" class="headerlink" title="1、接（三、5）PrepRequestProcessor的processRequest方法"></a>1、接（三、5）PrepRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        switch (request.type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case OpCode.exists: &#123;</span><br><span class="line">            lastOp = &quot;EXIS&quot;;</span><br><span class="line">            // TODO we need to figure out the security requirement for this!</span><br><span class="line">            ExistsRequest existsRequest = new ExistsRequest();</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                    existsRequest);</span><br><span class="line">            String path = existsRequest.getPath();</span><br><span class="line">            if (path.indexOf(&apos;\0&apos;) != -1) &#123;</span><br><span class="line">                throw new KeeperException.BadArgumentsException();</span><br><span class="line">            &#125;</span><br><span class="line">            //注册监听器</span><br><span class="line">            Stat stat = zks.getZKDatabase().statNode(path, existsRequest</span><br><span class="line">                    .getWatch() ? cnxn : null);</span><br><span class="line">            rsp = new ExistsResponse(stat);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">    ReplyHeader hdr =</span><br><span class="line">        new ReplyHeader(request.cxid, lastZxid, err.intValue());</span><br><span class="line"></span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,</span><br><span class="line">                request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //发送返回数据</span><br><span class="line">        cnxn.sendResponse(hdr, rsp, &quot;response&quot;);</span><br><span class="line">        if (request.type == OpCode.closeSession) &#123;</span><br><span class="line">            cnxn.sendCloseSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;FIXMSG&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、DataTree的statNode方法"><a href="#2、DataTree的statNode方法" class="headerlink" title="2、DataTree的statNode方法"></a>2、DataTree的statNode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Stat statNode(String path, Watcher watcher)</span><br><span class="line">        throws KeeperException.NoNodeException &#123;</span><br><span class="line">    Stat stat = new Stat();</span><br><span class="line">    //快速获取节点</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    if (watcher != null) &#123;</span><br><span class="line">        //监听器添加到集合中</span><br><span class="line">        dataWatches.addWatch(path, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == null) &#123;</span><br><span class="line">        throw new KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (n) &#123;</span><br><span class="line">        //获取节点状态信息</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        return stat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册监听器，到这儿就结束了。<br>单机版服务端源码介绍到此就结束了。</p>]]></content>
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zookeeper源码分布式服务端（2）</title>
      <link href="/2018/04/07/zookeeper%E6%BA%90%E7%A0%81/zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%882%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="zookeeper源码分布服务端（2）-分布式CREATE事务处理过程"><a href="#zookeeper源码分布服务端（2）-分布式CREATE事务处理过程" class="headerlink" title="zookeeper源码分布服务端（2） 分布式CREATE事务处理过程"></a>zookeeper源码分布服务端（2） 分布式CREATE事务处理过程</h2><h3 id="一、分布式CREATE事务处理过程Leader部分"><a href="#一、分布式CREATE事务处理过程Leader部分" class="headerlink" title="一、分布式CREATE事务处理过程Leader部分"></a>一、分布式CREATE事务处理过程Leader部分</h3><h4 id="1、LeaderRequestProcessor的run方法"><a href="#1、LeaderRequestProcessor的run方法" class="headerlink" title="1、LeaderRequestProcessor的run方法"></a>1、LeaderRequestProcessor的run方法</h4><p>前面与单机版相同，分布式Leader的firstProcessor为LeaderRequestProcessor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void processRequest(Request request)</span><br><span class="line">        throws RequestProcessorException &#123;</span><br><span class="line">    Request upgradeRequest = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        upgradeRequest = lzks.checkUpgradeSession(request);</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (upgradeRequest != null) &#123;</span><br><span class="line">        nextProcessor.processRequest(upgradeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    //PrepRequestProcessor继续处理请求</span><br><span class="line">    nextProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、PrepRequestProcessor的run方法"><a href="#2、PrepRequestProcessor的run方法" class="headerlink" title="2、PrepRequestProcessor的run方法"></a>2、PrepRequestProcessor的run方法</h4><p>leader接受到follower转发的事务后PrepRequestProcessor来处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Request request = submittedRequests.take();</span><br><span class="line">            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">            if (request.type == OpCode.ping) &#123;</span><br><span class="line">                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Request.requestOfDeath == request) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RequestProcessorException e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;PrepRequestProcessor exited loop!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pRequest(request)与单机版相同，调用ProposalRequestProcessor继续处理request</p><h4 id="3、ProposalRequestProcessor的processRequest方法"><a href="#3、ProposalRequestProcessor的processRequest方法" class="headerlink" title="3、ProposalRequestProcessor的processRequest方法"></a>3、ProposalRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">    if (request instanceof LearnerSyncRequest)&#123;</span><br><span class="line">        zks.getLeader().processSync((LearnerSyncRequest)request);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //先交给CommitProcessor处理下，此时还未提交  </span><br><span class="line">        nextProcessor.processRequest(request);</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //发起一个事务投票</span><br><span class="line">                zks.getLeader().propose(request);</span><br><span class="line">            &#125; catch (XidRolloverException e) &#123;</span><br><span class="line">                throw new RequestProcessorException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            //事务写进log，并完成投票</span><br><span class="line">            syncProcessor.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、CommitProcessor的run方法"><a href="#4、CommitProcessor的run方法" class="headerlink" title="4、CommitProcessor的run方法"></a>4、CommitProcessor的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int requestsToProcess = 0;</span><br><span class="line">        boolean commitIsWaiting = false;</span><br><span class="line">        do &#123;</span><br><span class="line">            //有投票完成的事务需要commit</span><br><span class="line">            commitIsWaiting = !committedRequests.isEmpty();</span><br><span class="line">            //需要处理的事务</span><br><span class="line">            requestsToProcess =  queuedRequests.size();</span><br><span class="line">            if (requestsToProcess == 0 &amp;&amp; !commitIsWaiting)&#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    //没有事务待处理，等待</span><br><span class="line">                    while (!stopped &amp;&amp; requestsToProcess == 0</span><br><span class="line">                            &amp;&amp; !commitIsWaiting) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                        commitIsWaiting = !committedRequests.isEmpty();</span><br><span class="line">                        requestsToProcess = queuedRequests.size();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            Request request = null;</span><br><span class="line">            while (!stopped &amp;&amp; requestsToProcess &gt; 0</span><br><span class="line">                    &amp;&amp; (request = queuedRequests.poll()) != null) &#123;</span><br><span class="line">                requestsToProcess--;</span><br><span class="line">                //事务请求需要投票,该session有事务请求，则非事务请求也要按顺序处理</span><br><span class="line">                if (needCommit(request)</span><br><span class="line">                        || pendingRequests.containsKey(request.sessionId)) &#123;</span><br><span class="line">                    // Add request to pending</span><br><span class="line">                    LinkedList&lt;Request&gt; requests = pendingRequests</span><br><span class="line">                            .get(request.sessionId);</span><br><span class="line">                    if (requests == null) &#123;</span><br><span class="line">                        requests = new LinkedList&lt;Request&gt;();</span><br><span class="line">                        pendingRequests.put(request.sessionId, requests);</span><br><span class="line">                    &#125;</span><br><span class="line">                    requests.addLast(request);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //ToBeAppliedRequestProcessor继续处理</span><br><span class="line">                    sendToNextProcessor(request);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!pendingRequests.isEmpty() &amp;&amp; !committedRequests.isEmpty())&#123;</span><br><span class="line">                    //有投票完成，待处理的事务</span><br><span class="line">                    commitIsWaiting = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (commitIsWaiting &amp;&amp; !stopped)&#123;</span><br><span class="line">                //有事务正在处理，等待</span><br><span class="line">                waitForEmptyPool();</span><br><span class="line"></span><br><span class="line">                if (stopped)&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Process committed head</span><br><span class="line">                if ((request = committedRequests.poll()) == null) &#123;</span><br><span class="line">                    throw new IOException(&quot;Error: committed head is null&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //该session下所有待处理的请求</span><br><span class="line">                LinkedList&lt;Request&gt; sessionQueue = pendingRequests</span><br><span class="line">                        .get(request.sessionId);</span><br><span class="line">                if (sessionQueue != null) &#123;</span><br><span class="line">                    // If session queue != null, then it is also not empty.</span><br><span class="line">                    Request topPending = sessionQueue.poll();</span><br><span class="line">                    if (request.cxid != topPending.cxid) &#123;</span><br><span class="line">                        sessionQueue.addFirst(topPending);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        topPending.setHdr(request.getHdr());</span><br><span class="line">                        topPending.setTxn(request.getTxn());</span><br><span class="line">                        topPending.zxid = request.zxid;</span><br><span class="line">                        request = topPending;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //ToBeAppliedRequestProcessor继续处理</span><br><span class="line">                sendToNextProcessor(request);</span><br><span class="line"></span><br><span class="line">                waitForEmptyPool();</span><br><span class="line"></span><br><span class="line">                //继续处理该session下的非事务请求</span><br><span class="line">                if (sessionQueue != null) &#123;</span><br><span class="line">                    while (!stopped &amp;&amp; !sessionQueue.isEmpty()</span><br><span class="line">                            &amp;&amp; !needCommit(sessionQueue.peek())) &#123;</span><br><span class="line">                        sendToNextProcessor(sessionQueue.poll());</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Remove empty queues</span><br><span class="line">                    if (sessionQueue.isEmpty()) &#123;</span><br><span class="line">                        pendingRequests.remove(request.sessionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!stoppedMainLoop);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(&quot;CommitProcessor exited loop!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、接（一、3）Leader的propose方法"><a href="#5、接（一、3）Leader的propose方法" class="headerlink" title="5、接（一、3）Leader的propose方法"></a>5、接（一、3）Leader的propose方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public Proposal propose(Request request) throws XidRolloverException &#123;</span><br><span class="line">    //事务zxid超过32位，重新选举Leader</span><br><span class="line">    if ((request.zxid &amp; 0xffffffffL) == 0xffffffffL) &#123;</span><br><span class="line">        String msg =</span><br><span class="line">                &quot;zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start&quot;;</span><br><span class="line">        shutdown(msg);</span><br><span class="line">        throw new XidRolloverException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">    try &#123;</span><br><span class="line">        request.getHdr().serialize(boa, &quot;hdr&quot;);</span><br><span class="line">        if (request.getTxn() != null) &#123;</span><br><span class="line">            request.getTxn().serialize(boa, &quot;txn&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.warn(&quot;This really should be impossible&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid,</span><br><span class="line">            baos.toByteArray(), null);</span><br><span class="line"></span><br><span class="line">    Proposal p = new Proposal();</span><br><span class="line">    p.packet = pp;</span><br><span class="line">    p.request = request;                </span><br><span class="line">    </span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">       p.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">               </span><br><span class="line">       if (request.getHdr().getType() == OpCode.reconfig)&#123;</span><br><span class="line">           self.setLastSeenQuorumVerifier(request.qv, true);                       </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if (self.getQuorumVerifier().getVersion()&lt;self.getLastSeenQuorumVerifier().getVersion()) &#123;</span><br><span class="line">           p.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">       &#125;</span><br><span class="line">               </span><br><span class="line">        lastProposed = p.packet.getZxid();</span><br><span class="line">        //leader发起提议的集合</span><br><span class="line">        outstandingProposals.put(lastProposed, p);</span><br><span class="line">        //向follower发送提议</span><br><span class="line">        sendPacket(pp);</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、AckRequestProcessor的processRequest方法"><a href="#6、AckRequestProcessor的processRequest方法" class="headerlink" title="6、AckRequestProcessor的processRequest方法"></a>6、AckRequestProcessor的processRequest方法</h4><p>syncProcessor将事务写入日志与单机版相同，之后AckRequestProcessor继续处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) &#123;</span><br><span class="line">    QuorumPeer self = leader.self;</span><br><span class="line">    if(self != null)</span><br><span class="line">        //处理投票</span><br><span class="line">        leader.processAck(self.getId(), request.zxid, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7、Leader的processAck方法"><a href="#7、Leader的processAck方法" class="headerlink" title="7、Leader的processAck方法"></a>7、Leader的processAck方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void processAck(long sid, long zxid, SocketAddress followerAddr) &#123;        </span><br><span class="line">    if (!allowedToCommit) return; // last op committed was a leader change - from now on </span><br><span class="line">                                 // the new leader should commit       </span><br><span class="line">    if ((zxid &amp; 0xffffffffL) == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;     </span><br><span class="line">    //没有待处理的提议   </span><br><span class="line">    if (outstandingProposals.size() == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //提议已被处理</span><br><span class="line">    if (lastCommitted &gt;= zxid) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //待投票的提议</span><br><span class="line">    Proposal p = outstandingProposals.get(zxid);</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //向提议中添加服务器</span><br><span class="line">    p.addAck(sid);        </span><br><span class="line">    </span><br><span class="line">    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);</span><br><span class="line"></span><br><span class="line">    if (hasCommitted &amp;&amp; p.request!=null &amp;&amp; p.request.getHdr().getType() == OpCode.reconfig)&#123;</span><br><span class="line">           long curZxid = zxid;</span><br><span class="line">       while (allowedToCommit &amp;&amp; hasCommitted &amp;&amp; p!=null)&#123;</span><br><span class="line">           curZxid++;</span><br><span class="line">           p = outstandingProposals.get(curZxid);</span><br><span class="line">           if (p !=null) hasCommitted = tryToCommit(p, curZxid, null);             </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、Leader的tryToCommit方法"><a href="#8、Leader的tryToCommit方法" class="headerlink" title="8、Leader的tryToCommit方法"></a>8、Leader的tryToCommit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">synchronized public boolean tryToCommit(Proposal p, long zxid, SocketAddress followerAddr) &#123;       </span><br><span class="line">   </span><br><span class="line">   if (outstandingProposals.containsKey(zxid - 1)) return false;</span><br><span class="line">   </span><br><span class="line">   //判断是否超过半数follower完成投票</span><br><span class="line">    if (!p.hasAllQuorums()) &#123;</span><br><span class="line">       return false;                 </span><br><span class="line">    &#125;  </span><br><span class="line">    //从待投票的集合中移除</span><br><span class="line">    outstandingProposals.remove(zxid);</span><br><span class="line">    </span><br><span class="line">    if (p.request != null) &#123;</span><br><span class="line">         //已投票待commit的request</span><br><span class="line">         toBeApplied.add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (p.request == null) &#123;</span><br><span class="line">        LOG.warn(&quot;Going to commmit null: &quot; + p);</span><br><span class="line">    &#125; else if (p.request.getHdr().getType() == OpCode.reconfig) &#123;       </span><br><span class="line">        Long designatedLeader = getDesignatedLeader(p, zxid);</span><br><span class="line">       </span><br><span class="line">        QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size()-1).getQuorumVerifier();</span><br><span class="line">   </span><br><span class="line">        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);</span><br><span class="line"></span><br><span class="line">        if (designatedLeader != self.getId()) &#123;</span><br><span class="line">            allowedToCommit = false;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        commitAndActivate(zxid, designatedLeader);</span><br><span class="line">        informAndActivate(p, designatedLeader);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //向follower发送commit</span><br><span class="line">        commit(zxid);</span><br><span class="line">        inform(p);</span><br><span class="line">    &#125;</span><br><span class="line">    //commit该事务</span><br><span class="line">    zk.commitProcessor.commit(p.request);</span><br><span class="line">    if(pendingSyncs.containsKey(zxid))&#123;</span><br><span class="line">        for(LearnerSyncRequest r: pendingSyncs.remove(zxid)) &#123;</span><br><span class="line">            sendSync(r);</span><br><span class="line">        &#125;               </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    return  true;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、CommitProcessor的commit方法"><a href="#9、CommitProcessor的commit方法" class="headerlink" title="9、CommitProcessor的commit方法"></a>9、CommitProcessor的commit方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void commit(Request request) &#123;</span><br><span class="line">    if (stopped || request == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //事务加入已commit集合</span><br><span class="line">    committedRequests.add(request);</span><br><span class="line">    wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、ToBeAppliedRequestProcessor的processRequest方法"><a href="#10、ToBeAppliedRequestProcessor的processRequest方法" class="headerlink" title="10、ToBeAppliedRequestProcessor的processRequest方法"></a>10、ToBeAppliedRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">        //FinalRequestProcessor处理请求，修改内存db结构，与单机版相同</span><br><span class="line">        next.processRequest(request);</span><br><span class="line"></span><br><span class="line">        // 事务请求,处理完内存之后将事务提议从toBeApplied集合中删除</span><br><span class="line">        if (request.getHdr() != null) &#123;</span><br><span class="line">            long zxid = request.getHdr().getZxid();</span><br><span class="line">            Iterator&lt;Proposal&gt; iter = leader.toBeApplied.iterator();</span><br><span class="line">            if (iter.hasNext()) &#123;</span><br><span class="line">                Proposal p = iter.next();</span><br><span class="line">                if (p.request != null &amp;&amp; p.request.zxid == zxid) &#123;</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二、分布式CREATE事务处理过程Follower部分"><a href="#二、分布式CREATE事务处理过程Follower部分" class="headerlink" title="二、分布式CREATE事务处理过程Follower部分"></a>二、分布式CREATE事务处理过程Follower部分</h3><h4 id="1、FollowerRequestProcessor的run方法"><a href="#1、FollowerRequestProcessor的run方法" class="headerlink" title="1、FollowerRequestProcessor的run方法"></a>1、FollowerRequestProcessor的run方法</h4><p>前面的处理于单机版相同，分布式Follower的firstProcessor为FollowerRequestProcessor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!finished) &#123;</span><br><span class="line">            Request request = queuedRequests.take();</span><br><span class="line">            if (request == Request.requestOfDeath) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //先交给CommitProcessor，最终投票通过后，会通过CommitProcessor的commit方法最终提交事务 </span><br><span class="line">            nextProcessor.processRequest(request);</span><br><span class="line"></span><br><span class="line">            //只有事务请求才转发给leader，进行投票  </span><br><span class="line">            switch (request.type) &#123;</span><br><span class="line">            case OpCode.sync:</span><br><span class="line">                zks.pendingSyncs.add(request);</span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                break;</span><br><span class="line">            case OpCode.create:</span><br><span class="line">            case OpCode.create2:</span><br><span class="line">            case OpCode.createTTL:</span><br><span class="line">            case OpCode.createContainer:</span><br><span class="line">            case OpCode.delete:</span><br><span class="line">            case OpCode.deleteContainer:</span><br><span class="line">            case OpCode.setData:</span><br><span class="line">            case OpCode.reconfig:</span><br><span class="line">            case OpCode.setACL:</span><br><span class="line">            case OpCode.multi:</span><br><span class="line">            case OpCode.check:</span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                break;</span><br><span class="line">            case OpCode.createSession:</span><br><span class="line">            case OpCode.closeSession:</span><br><span class="line">                // Don&apos;t forward local sessions to the leader.</span><br><span class="line">                if (!request.isLocalSession()) &#123;</span><br><span class="line">                    zks.getFollower().request(request);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、Learner的request方法"><a href="#2、Learner的request方法" class="headerlink" title="2、Learner的request方法"></a>2、Learner的request方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void request(Request request) throws IOException &#123;</span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    DataOutputStream oa = new DataOutputStream(baos);</span><br><span class="line">    oa.writeLong(request.sessionId);</span><br><span class="line">    oa.writeInt(request.cxid);</span><br><span class="line">    oa.writeInt(request.type);</span><br><span class="line">    if (request.request != null) &#123;</span><br><span class="line">        request.request.rewind();</span><br><span class="line">        int len = request.request.remaining();</span><br><span class="line">        byte b[] = new byte[len];</span><br><span class="line">        request.request.get(b);</span><br><span class="line">        request.request.rewind();</span><br><span class="line">        oa.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">    oa.close();</span><br><span class="line">    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos</span><br><span class="line">            .toByteArray(), request.authInfo);</span><br><span class="line">    //转发事务请求给leader</span><br><span class="line">    writePacket(qp, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、Follower的readPacket方法"><a href="#3、Follower的readPacket方法" class="headerlink" title="3、Follower的readPacket方法"></a>3、Follower的readPacket方法</h4><p>Follower的followLeader的中的主循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void readPacket(QuorumPacket pp) throws IOException &#123;</span><br><span class="line">    synchronized (leaderIs) &#123;</span><br><span class="line">        //读取leader返回数据</span><br><span class="line">        leaderIs.readRecord(pp, &quot;packet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;</span><br><span class="line">    if (pp.getType() == Leader.PING) &#123;</span><br><span class="line">        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    if (LOG.isTraceEnabled()) &#123;</span><br><span class="line">        ZooTrace.logQuorumPacket(LOG, traceMask, &apos;i&apos;, pp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4、Follower的processPacket方法"><a href="#4、Follower的processPacket方法" class="headerlink" title="4、Follower的processPacket方法"></a>4、Follower的processPacket方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected void processPacket(QuorumPacket qp) throws Exception&#123;</span><br><span class="line">     switch (qp.getType()) &#123;</span><br><span class="line">     case Leader.PING:            </span><br><span class="line">         ping(qp);            </span><br><span class="line">         break;</span><br><span class="line">     case Leader.PROPOSAL:           </span><br><span class="line">         TxnHeader hdr = new TxnHeader();</span><br><span class="line">         Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);</span><br><span class="line">         lastQueued = hdr.getZxid();</span><br><span class="line">         </span><br><span class="line">         if (hdr.getType() == OpCode.reconfig)&#123;</span><br><span class="line">            SetDataTxn setDataTxn = (SetDataTxn) txn;       </span><br><span class="line">            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));</span><br><span class="line">            self.setLastSeenQuorumVerifier(qv, true);                               </span><br><span class="line">         &#125;</span><br><span class="line">         //添加日志文件，并完成投票</span><br><span class="line">         fzk.logRequest(hdr, txn);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.COMMIT:</span><br><span class="line">         //Leader完成事务投票，发来commit</span><br><span class="line">         fzk.commit(qp.getZxid());</span><br><span class="line">         break;            </span><br><span class="line">     case Leader.COMMITANDACTIVATE:</span><br><span class="line">        // get the new configuration from the request</span><br><span class="line">        Request request = fzk.pendingTxns.element();</span><br><span class="line">        SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();                                                                                                      </span><br><span class="line">        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                                </span><br><span class="line"> </span><br><span class="line">        // get new designated leader from (current) leader&apos;s message</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());    </span><br><span class="line">        long suggestedLeaderId = buffer.getLong();</span><br><span class="line">         boolean majorChange = </span><br><span class="line">                self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);</span><br><span class="line">        // commit (writes the new config to ZK tree (/zookeeper/config)                     </span><br><span class="line">        fzk.commit(qp.getZxid());</span><br><span class="line">         if (majorChange) &#123;</span><br><span class="line">            throw new Exception(&quot;changes proposed in reconfig&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">     case Leader.UPTODATE:</span><br><span class="line">         LOG.error(&quot;Received an UPTODATE message after Follower started&quot;);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.REVALIDATE:</span><br><span class="line">         revalidate(qp);</span><br><span class="line">         break;</span><br><span class="line">     case Leader.SYNC:</span><br><span class="line">         fzk.sync();</span><br><span class="line">         break;</span><br><span class="line">     default:</span><br><span class="line">         LOG.warn(&quot;Unknown packet type: &#123;&#125;&quot;, LearnerHandler.packetToString(qp));</span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5、FollowerZooKeeperServer的logRequest方法"><a href="#5、FollowerZooKeeperServer的logRequest方法" class="headerlink" title="5、FollowerZooKeeperServer的logRequest方法"></a>5、FollowerZooKeeperServer的logRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void logRequest(TxnHeader hdr, Record txn) &#123;</span><br><span class="line">    Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());</span><br><span class="line">    if ((request.zxid &amp; 0xffffffffL) != 0) &#123;</span><br><span class="line">        pendingTxns.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    syncProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follower的SyncRequestProcessor与Leader相同，后续处理器为SendAckRequestProcessor</p><h4 id="6、SendAckRequestProcessor的processRequest方法"><a href="#6、SendAckRequestProcessor的processRequest方法" class="headerlink" title="6、SendAckRequestProcessor的processRequest方法"></a>6、SendAckRequestProcessor的processRequest方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void processRequest(Request si) &#123;</span><br><span class="line">    if(si.type != OpCode.sync)&#123;</span><br><span class="line">        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null,</span><br><span class="line">            null);</span><br><span class="line">        try &#123;</span><br><span class="line">            //向leader发送事务成功的投票信息</span><br><span class="line">            learner.writePacket(qp, false);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>follower接到Leader发来的commit之后，CommitProcessor完成commit，FinalRequestProcessor将事务写进内存db。<br>Create事务到此就结束了。</p>]]></content>
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zookeeper源码分布式服务端（1）</title>
      <link href="/2018/04/07/zookeeper%E6%BA%90%E7%A0%81/zookeeper%E6%BA%90%E7%A0%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%881%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="zookeeper源码分布服务端（1）-服务端启动过程"><a href="#zookeeper源码分布服务端（1）-服务端启动过程" class="headerlink" title="zookeeper源码分布服务端（1） 服务端启动过程"></a>zookeeper源码分布服务端（1） 服务端启动过程</h2><h3 id="一、LEADER选举过程"><a href="#一、LEADER选举过程" class="headerlink" title="一、LEADER选举过程"></a>一、LEADER选举过程</h3><h4 id="1、QuorumPeerMain的runFromConfig方法"><a href="#1、QuorumPeerMain的runFromConfig方法" class="headerlink" title="1、QuorumPeerMain的runFromConfig方法"></a>1、QuorumPeerMain的runFromConfig方法</h4><p>分布式zookeeper启动入口为QuorumPeerMain的main方法，之后调用了runFromConfig方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public void runFromConfig(QuorumPeerConfig config)</span><br><span class="line">        throws IOException, AdminServerException</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  try &#123;</span><br><span class="line">      ServerCnxnFactory cnxnFactory = null;</span><br><span class="line">      ServerCnxnFactory secureCnxnFactory = null;</span><br><span class="line">      //创建连接工厂与单机版相同</span><br><span class="line">      if (config.getClientPortAddress() != null) &#123;</span><br><span class="line">          cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">          cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                  config.getMaxClientCnxns(),</span><br><span class="line">                  false);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (config.getSecureClientPortAddress() != null) &#123;</span><br><span class="line">          secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">          secureCnxnFactory.configure(config.getSecureClientPortAddress(),</span><br><span class="line">                  config.getMaxClientCnxns(),</span><br><span class="line">                  true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      quorumPeer = getQuorumPeer();</span><br><span class="line">      //设置日志及快照文件</span><br><span class="line">      quorumPeer.setTxnFactory(new FileTxnSnapLog(</span><br><span class="line">                  config.getDataLogDir(),</span><br><span class="line">                  config.getDataDir()));</span><br><span class="line">      quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());</span><br><span class="line">      quorumPeer.enableLocalSessionsUpgrading(</span><br><span class="line">          config.isLocalSessionsUpgradingEnabled());</span><br><span class="line">      //集群机器地址</span><br><span class="line">      quorumPeer.setQuorumPeers(config.getAllMembers());</span><br><span class="line">      //leader选择器类型</span><br><span class="line">      quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">      //本机的集群编号</span><br><span class="line">      quorumPeer.setMyid(config.getServerId());</span><br><span class="line">      //服务器单位时间</span><br><span class="line">      quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">      quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">      quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">      //LF初始通信时限</span><br><span class="line">      quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">      //LF同步通信时限</span><br><span class="line">      quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">      quorumPeer.setConfigFileName(config.getConfigFilename());</span><br><span class="line">      //内存数据</span><br><span class="line">      quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));</span><br><span class="line">      //投票决定方式，默认超过半数就通过  </span><br><span class="line">      quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);</span><br><span class="line">      if (config.getLastSeenQuorumVerifier()!=null) &#123;</span><br><span class="line">          quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);</span><br><span class="line">      &#125;</span><br><span class="line">      quorumPeer.initConfigInZKDatabase();</span><br><span class="line">      //设置连接工厂</span><br><span class="line">      quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">      quorumPeer.setSecureCnxnFactory(secureCnxnFactory);</span><br><span class="line">      quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line">      quorumPeer.setSyncEnabled(config.getSyncEnabled());</span><br><span class="line">      quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</span><br><span class="line"></span><br><span class="line">      // sets quorum sasl authentication configurations</span><br><span class="line">      quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</span><br><span class="line">      if(quorumPeer.isQuorumSaslAuthEnabled())&#123;</span><br><span class="line">          quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</span><br><span class="line">          quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</span><br><span class="line">          quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</span><br><span class="line">          quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</span><br><span class="line">          quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</span><br><span class="line">      &#125;</span><br><span class="line">      quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</span><br><span class="line">      quorumPeer.initialize();</span><br><span class="line">      //启动主线程 </span><br><span class="line">      quorumPeer.start();</span><br><span class="line">      quorumPeer.join();</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      // warn, but generally this is ok</span><br><span class="line">      LOG.warn(&quot;Quorum Peer interrupted&quot;, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2、QuorumPeer的start方法"><a href="#2、QuorumPeer的start方法" class="headerlink" title="2、QuorumPeer的start方法"></a>2、QuorumPeer的start方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    if (!getView().containsKey(myid)) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //恢复本机数据</span><br><span class="line">    loadDataBase();</span><br><span class="line">    //启动连接工厂</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    try &#123;</span><br><span class="line">        //内嵌的管理控制台是通过jetty启动,占用8080 端口</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; catch (AdminServerException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //开始投票</span><br><span class="line">    startLeaderElection();</span><br><span class="line">    //主流程</span><br><span class="line">    super.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、QuorumPeer的startLeaderElection方法"><a href="#3、QuorumPeer的startLeaderElection方法" class="headerlink" title="3、QuorumPeer的startLeaderElection方法"></a>3、QuorumPeer的startLeaderElection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void startLeaderElection() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            //首次投票给自己</span><br><span class="line">            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        throw re;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建选举器</span><br><span class="line">    this.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、QuorumPeer的createElectionAlgorithm方法"><a href="#4、QuorumPeer的createElectionAlgorithm方法" class="headerlink" title="4、QuorumPeer的createElectionAlgorithm方法"></a>4、QuorumPeer的createElectionAlgorithm方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> protected Election createElectionAlgorithm(int electionAlgorithm)&#123;</span><br><span class="line">    Election le=null;</span><br><span class="line">    //TODO: use a factory rather than a switch</span><br><span class="line">    switch (electionAlgorithm) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        le = new AuthFastLeaderElection(this);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        le = new AuthFastLeaderElection(this, true);</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        //leader选举通信管理类</span><br><span class="line">        qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        if(listener != null)&#123;</span><br><span class="line">            //启动已绑定3888端口的选举线程，等待集群其他机器连接</span><br><span class="line">            listener.start();</span><br><span class="line">            //基于TCP的选举算法</span><br><span class="line">            FastLeaderElection fle = new FastLeaderElection(this, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG.error(&quot;Null listener when initializing cnx manager&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        assert false;</span><br><span class="line">    &#125;</span><br><span class="line">    return le;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、实例化QuorumCnxManager"><a href="#5、实例化QuorumCnxManager" class="headerlink" title="5、实例化QuorumCnxManager"></a>5、实例化QuorumCnxManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public QuorumCnxManager(QuorumPeer self,</span><br><span class="line">                        final long mySid,</span><br><span class="line">                        Map&lt;Long,QuorumPeer.QuorumServer&gt; view,</span><br><span class="line">                        QuorumAuthServer authServer,</span><br><span class="line">                        QuorumAuthLearner authLearner,</span><br><span class="line">                        int socketTimeout,</span><br><span class="line">                        boolean listenOnAllIPs,</span><br><span class="line">                        int quorumCnxnThreadsSize,</span><br><span class="line">                        boolean quorumSaslAuthEnabled) &#123;</span><br><span class="line">    //接收到的投票消息队列</span><br><span class="line">    this.recvQueue = new ArrayBlockingQueue&lt;Message&gt;(RECV_CAPACITY);</span><br><span class="line">    //往其他服务器待发送消息队列</span><br><span class="line">    this.queueSendMap = new ConcurrentHashMap&lt;Long, ArrayBlockingQueue&lt;ByteBuffer&gt;&gt;();</span><br><span class="line">    //往其他服务器发送消息线程</span><br><span class="line">    this.senderWorkerMap = new ConcurrentHashMap&lt;Long, SendWorker&gt;();</span><br><span class="line">    //往其他服务器发送的最新消息</span><br><span class="line">    this.lastMessageSent = new ConcurrentHashMap&lt;Long, ByteBuffer&gt;();</span><br><span class="line">    </span><br><span class="line">    String cnxToValue = System.getProperty(&quot;zookeeper.cnxTimeout&quot;);</span><br><span class="line">    if(cnxToValue != null)&#123;</span><br><span class="line">        this.cnxTO = Integer.parseInt(cnxToValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.self = self;</span><br><span class="line"></span><br><span class="line">    this.mySid = mySid;</span><br><span class="line">    this.socketTimeout = socketTimeout;</span><br><span class="line">    this.view = view;</span><br><span class="line">    //各服务器ip</span><br><span class="line">    this.listenOnAllIPs = listenOnAllIPs;</span><br><span class="line"></span><br><span class="line">    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,</span><br><span class="line">            quorumSaslAuthEnabled);</span><br><span class="line"></span><br><span class="line">    //等待其他服务器连接的线程</span><br><span class="line">    listener = new Listener();</span><br><span class="line">    listener.setName(&quot;QuorumPeerListener&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、接（一、4）Listener的run方法"><a href="#6、接（一、4）Listener的run方法" class="headerlink" title="6、接（一、4）Listener的run方法"></a>6、接（一、4）Listener的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //重连次数</span><br><span class="line">    int numRetries = 0;</span><br><span class="line">    InetSocketAddress addr;</span><br><span class="line">    Socket client = null;</span><br><span class="line">    while((!shutdown) &amp;&amp; (numRetries &lt; 3))&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //启动Socket服务端</span><br><span class="line">            ss = new ServerSocket();</span><br><span class="line">            ss.setReuseAddress(true);</span><br><span class="line">            if (self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">                int port = self.getElectionAddress().getPort();</span><br><span class="line">                addr = new InetSocketAddress(port);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Resolve hostname for this server in case the</span><br><span class="line">                // underlying ip address has changed.</span><br><span class="line">                self.recreateSocketAddresses(self.getId());</span><br><span class="line">                addr = self.getElectionAddress();</span><br><span class="line">            &#125;</span><br><span class="line">            setName(addr.toString());</span><br><span class="line">            ss.bind(addr);</span><br><span class="line">            while (!shutdown) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    client = ss.accept();</span><br><span class="line">                    setSockOpts(client);</span><br><span class="line">                    LOG.info(&quot;Received connection request &quot;</span><br><span class="line">                             + client.getRemoteSocketAddress());</span><br><span class="line">                    if (quorumSaslAuthEnabled) &#123;</span><br><span class="line">                        receiveConnectionAsync(client);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //处理接收到的连接</span><br><span class="line">                        receiveConnection(client);</span><br><span class="line">                    &#125;</span><br><span class="line">                    numRetries = 0;</span><br><span class="line">                &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (shutdown) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            numRetries++;</span><br><span class="line">            try &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch </span><br><span class="line">            ...</span><br><span class="line">            closeSocket(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、Listener的receiveConnection方法"><a href="#7、Listener的receiveConnection方法" class="headerlink" title="7、Listener的receiveConnection方法"></a>7、Listener的receiveConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void receiveConnection(final Socket sock) &#123;</span><br><span class="line">    DataInputStream din = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        din = new DataInputStream(</span><br><span class="line">                new BufferedInputStream(sock.getInputStream()));</span><br><span class="line">        //处理收到连接的数据</span><br><span class="line">        handleConnection(sock, din);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、Listener的handleConnection方法"><a href="#8、Listener的handleConnection方法" class="headerlink" title="8、Listener的handleConnection方法"></a>8、Listener的handleConnection方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private void handleConnection(Socket sock, DataInputStream din)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    Long sid = null, protocolVersion = null;</span><br><span class="line">    InetSocketAddress electionAddr = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //协议版本号</span><br><span class="line">        protocolVersion = din.readLong();</span><br><span class="line">        if (protocolVersion &gt;= 0) &#123; // this is a server id and not a protocol version</span><br><span class="line">            sid = protocolVersion;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                InitialMessage init = InitialMessage.parse(protocolVersion, din);</span><br><span class="line">                sid = init.sid;</span><br><span class="line">                //连接地址</span><br><span class="line">                electionAddr = init.electionAddr;</span><br><span class="line">            &#125; catch (InitialMessage.InitialMessageException ex) &#123;</span><br><span class="line">                LOG.error(ex.toString());</span><br><span class="line">                closeSocket(sock);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //连接的是只读服务器</span><br><span class="line">        if (sid == QuorumPeer.OBSERVER_ID) &#123;</span><br><span class="line">            sid = observerCounter.getAndDecrement();</span><br><span class="line">            LOG.info(&quot;Setting arbitrary identifier to observer: &quot; + sid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do authenticating learner</span><br><span class="line">    authServer.authenticate(sock, din);</span><br><span class="line"></span><br><span class="line">    //由序号大的服务器向小的发起连接</span><br><span class="line">    if (sid &lt; self.getId()) &#123;</span><br><span class="line">        //关掉发送消息线程</span><br><span class="line">        SendWorker sw = senderWorkerMap.get(sid);</span><br><span class="line">        if (sw != null) &#123;</span><br><span class="line">            sw.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭连接</span><br><span class="line">        closeSocket(sock);</span><br><span class="line"></span><br><span class="line">        if (electionAddr != null) &#123;</span><br><span class="line">            //发起连接</span><br><span class="line">            connectOne(sid, electionAddr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            connectOne(sid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123; // Otherwise start worker threads to receive data.</span><br><span class="line">        //发送消息线程</span><br><span class="line">        SendWorker sw = new SendWorker(sock, sid);</span><br><span class="line">        //接受消息线程</span><br><span class="line">        RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span><br><span class="line">        sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">        SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line">        //关闭旧线程</span><br><span class="line">        if (vsw != null) &#123;</span><br><span class="line">            vsw.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        //添加新线程</span><br><span class="line">        senderWorkerMap.put(sid, sw);</span><br><span class="line">        //等待发送的投票信息</span><br><span class="line">        queueSendMap.putIfAbsent(sid,</span><br><span class="line">                new ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));</span><br><span class="line">        </span><br><span class="line">        sw.start();</span><br><span class="line">        rw.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、Listener的connectOne方法"><a href="#9、Listener的connectOne方法" class="headerlink" title="9、Listener的connectOne方法"></a>9、Listener的connectOne方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">synchronized private boolean connectOne(long sid, InetSocketAddress electionAddr)&#123;</span><br><span class="line">    if (senderWorkerMap.get(sid) != null) &#123;</span><br><span class="line">        //发送消息线程已存在，则已连接上</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Socket sock = null;</span><br><span class="line">    try &#123;</span><br><span class="line">         sock = new Socket();</span><br><span class="line">         setSockOpts(sock);</span><br><span class="line">         //发起连接</span><br><span class="line">         sock.connect(electionAddr, cnxTO);</span><br><span class="line">        if (quorumSaslAuthEnabled) &#123;</span><br><span class="line">            initiateConnectionAsync(sock, sid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //初始化连接</span><br><span class="line">            initiateConnection(sock, sid);</span><br><span class="line">        &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125; catch (UnresolvedAddressException e) &#123;</span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         throw e;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         closeSocket(sock);</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、Listener的startConnection方法"><a href="#10、Listener的startConnection方法" class="headerlink" title="10、Listener的startConnection方法"></a>10、Listener的startConnection方法</h4><p>initiateConnection方法调用startConnection方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private boolean startConnection(Socket sock, Long sid)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    DataOutputStream dout = null;</span><br><span class="line">    DataInputStream din = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        dout = new DataOutputStream(buf);</span><br><span class="line">        //发送协议版本号</span><br><span class="line">        dout.writeLong(PROTOCOL_VERSION);</span><br><span class="line">        //发送服务器编号</span><br><span class="line">        dout.writeLong(self.getId());</span><br><span class="line">        String addr = self.getElectionAddress().getHostString() + &quot;:&quot; + self.getElectionAddress().getPort();</span><br><span class="line">        byte[] addr_bytes = addr.getBytes();</span><br><span class="line">        //发送本机地址</span><br><span class="line">        dout.writeInt(addr_bytes.length);</span><br><span class="line">        dout.write(addr_bytes);</span><br><span class="line">        dout.flush();</span><br><span class="line"></span><br><span class="line">        din = new DataInputStream(</span><br><span class="line">                new BufferedInputStream(sock.getInputStream()));</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // authenticate learner</span><br><span class="line">    QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);</span><br><span class="line">    if (qps != null) &#123;</span><br><span class="line">        // TODO - investigate why reconfig makes qps null.</span><br><span class="line">        authLearner.authenticate(sock, qps.hostname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 序号大的服务器向序号小的服务器发起连接</span><br><span class="line">    if (sid &gt; self.getId()) &#123;</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        // Otherwise proceed with the connection</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //发送数据线程</span><br><span class="line">        SendWorker sw = new SendWorker(sock, sid);</span><br><span class="line">        //接受数据线程</span><br><span class="line">        RecvWorker rw = new RecvWorker(sock, din, sid, sw);</span><br><span class="line">        sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">        SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line">        </span><br><span class="line">        if(vsw != null)</span><br><span class="line">            vsw.finish();</span><br><span class="line">        //发送消息线程Map</span><br><span class="line">        senderWorkerMap.put(sid, sw);</span><br><span class="line">        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">                    SEND_CAPACITY));</span><br><span class="line">        </span><br><span class="line">        sw.start();</span><br><span class="line">        rw.start();</span><br><span class="line">        </span><br><span class="line">        return true;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="11、SendWorker的run方法"><a href="#11、SendWorker的run方法" class="headerlink" title="11、SendWorker的run方法"></a>11、SendWorker的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //线程数量加一</span><br><span class="line">            threadCnt.incrementAndGet();</span><br><span class="line">            try &#123;</span><br><span class="line">                //待发送的数据队列</span><br><span class="line">                ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">                if (bq == null || isSendQueueEmpty(bq)) &#123;</span><br><span class="line">                    //无待发送数据，发送上次发送的数据</span><br><span class="line">                   ByteBuffer b = lastMessageSent.get(sid);</span><br><span class="line">                   if (b != null) &#123;</span><br><span class="line">                       send(b);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                this.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                while (running &amp;&amp; !shutdown &amp;&amp; sock != null) &#123;</span><br><span class="line"></span><br><span class="line">                    ByteBuffer b = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap</span><br><span class="line">                                .get(sid);</span><br><span class="line">                        if (bq != null) &#123;</span><br><span class="line">                            //获取待发送数据</span><br><span class="line">                            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if(b != null)&#123;</span><br><span class="line">                            lastMessageSent.put(sid, b);</span><br><span class="line">                            //发送数据</span><br><span class="line">                            send(b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            this.finish();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="12、接（一、10）RecvWorker的run方法"><a href="#12、接（一、10）RecvWorker的run方法" class="headerlink" title="12、接（一、10）RecvWorker的run方法"></a>12、接（一、10）RecvWorker的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    //线程数量加一</span><br><span class="line">    threadCnt.incrementAndGet();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (running &amp;&amp; !shutdown &amp;&amp; sock != null) &#123;</span><br><span class="line">            //消息长度</span><br><span class="line">            int length = din.readInt();</span><br><span class="line">            if (length &lt;= 0 || length &gt; PACKETMAXSIZE) &#123;</span><br><span class="line">                throw new IOException(</span><br><span class="line">                        &quot;Received packet with invalid packet: &quot;</span><br><span class="line">                                + length);</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * Allocates a new ByteBuffer to receive the message</span><br><span class="line">             */</span><br><span class="line">            byte[] msgArray = new byte[length];</span><br><span class="line">            din.readFully(msgArray, 0, length);</span><br><span class="line">            ByteBuffer message = ByteBuffer.wrap(msgArray);</span><br><span class="line">            //读取到的数据包转换成投票消息加入队列</span><br><span class="line">            addToRecvQueue(new Message(message.duplicate(), sid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">        sw.finish();</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、接（一、4）FastLeaderElection实例化"><a href="#13、接（一、4）FastLeaderElection实例化" class="headerlink" title="13、接（一、4）FastLeaderElection实例化"></a>13、接（一、4）FastLeaderElection实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager)&#123;</span><br><span class="line">    this.stop = false;</span><br><span class="line">    this.manager = manager;</span><br><span class="line">    starter(self, manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、FastLeaderElection的starter方法"><a href="#14、FastLeaderElection的starter方法" class="headerlink" title="14、FastLeaderElection的starter方法"></a>14、FastLeaderElection的starter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void starter(QuorumPeer self, QuorumCnxManager manager) &#123;</span><br><span class="line">    this.self = self;</span><br><span class="line">    proposedLeader = -1;</span><br><span class="line">    proposedZxid = -1;</span><br><span class="line"></span><br><span class="line">    //待发送的消息队列</span><br><span class="line">    sendqueue = new LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">    //接收到的消息队列</span><br><span class="line">    recvqueue = new LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">    this.messenger = new Messenger(manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15、Messenger的start方法"><a href="#15、Messenger的start方法" class="headerlink" title="15、Messenger的start方法"></a>15、Messenger的start方法</h4><p>FastLeaderElection的start方法调用Messenger的start方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void start()&#123;</span><br><span class="line">    //WorkerSender发送投票消息线程</span><br><span class="line">    this.wsThread.start();</span><br><span class="line">    //WorkerReceiver接受投票消息线程</span><br><span class="line">    this.wrThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="16、WorkerSender的run方法"><a href="#16、WorkerSender的run方法" class="headerlink" title="16、WorkerSender的run方法"></a>16、WorkerSender的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    while (!stop) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //从待发送消息队列获取消息</span><br><span class="line">            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);</span><br><span class="line">            if(m == null) continue;</span><br><span class="line">            //处理待发送消息</span><br><span class="line">            process(m);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17、WorkerSender的process方法"><a href="#17、WorkerSender的process方法" class="headerlink" title="17、WorkerSender的process方法"></a>17、WorkerSender的process方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void process(ToSend m) &#123;</span><br><span class="line">    //待发送投票消息转换为字节数据</span><br><span class="line">    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),</span><br><span class="line">                                        m.leader,</span><br><span class="line">                                        m.zxid,</span><br><span class="line">                                        m.electionEpoch,</span><br><span class="line">                                        m.peerEpoch,</span><br><span class="line">                                        m.configData);</span><br><span class="line">    //发送处理转换后的数据</span><br><span class="line">    manager.toSend(m.sid, requestBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、WorkerSender的toSend方法"><a href="#18、WorkerSender的toSend方法" class="headerlink" title="18、WorkerSender的toSend方法"></a>18、WorkerSender的toSend方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void toSend(Long sid, ByteBuffer b) &#123;</span><br><span class="line">    if (this.mySid == sid) &#123;</span><br><span class="line">        //发送给自己的数据，直接添加入接受到的数据队列</span><br><span class="line">         b.position(0);</span><br><span class="line">         addToRecvQueue(new Message(b.duplicate(), sid));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //Start a new connection if doesn&apos;t have one already.</span><br><span class="line">          </span><br><span class="line">        ArrayBlockingQueue&lt;ByteBuffer&gt; bq = new ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">            SEND_CAPACITY);</span><br><span class="line">        //如果没有，添加该服务器待发送数据队列</span><br><span class="line">        ArrayBlockingQueue&lt;ByteBuffer&gt; oldq = queueSendMap.putIfAbsent(sid, bq);</span><br><span class="line">        //将待发送数据加入队列</span><br><span class="line">        if (oldq != null) &#123;</span><br><span class="line">            addToSendQueue(oldq, b);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addToSendQueue(bq, b);</span><br><span class="line">        &#125;</span><br><span class="line">        //发起连接</span><br><span class="line">        connectOne(sid);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19、（接一、15）WorkerReceiver的run方法"><a href="#19、（接一、15）WorkerReceiver的run方法" class="headerlink" title="19、（接一、15）WorkerReceiver的run方法"></a>19、（接一、15）WorkerReceiver的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    Message response;</span><br><span class="line">    while (!stop) &#123;</span><br><span class="line">        // Sleeps on receive</span><br><span class="line">        try &#123;</span><br><span class="line">            //接收到的数据</span><br><span class="line">            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);</span><br><span class="line">            if(response == null) continue;</span><br><span class="line"></span><br><span class="line">            // The current protocol and two previous generations all send at least 28 bytes</span><br><span class="line">            if (response.buffer.capacity() &lt; 28) &#123;</span><br><span class="line">                LOG.error(&quot;Got a short response: &quot; + response.buffer.capacity());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // this is the backwardCompatibility mode in place before ZK-107</span><br><span class="line">            // It is for a version of the protocol in which we didn&apos;t send peer epoch</span><br><span class="line">            // With peer epoch and version the message became 40 bytes</span><br><span class="line">            boolean backCompatibility28 = (response.buffer.capacity() == 28);</span><br><span class="line"></span><br><span class="line">            // this is the backwardCompatibility mode for no version information</span><br><span class="line">            boolean backCompatibility40 = (response.buffer.capacity() == 40);</span><br><span class="line">            </span><br><span class="line">            response.buffer.clear();</span><br><span class="line"></span><br><span class="line">            //实例化消息对象</span><br><span class="line">            Notification n = new Notification();</span><br><span class="line"></span><br><span class="line">            int rstate = response.buffer.getInt();</span><br><span class="line">            long rleader = response.buffer.getLong();</span><br><span class="line">            long rzxid = response.buffer.getLong();</span><br><span class="line">            long relectionEpoch = response.buffer.getLong();</span><br><span class="line">            long rpeerepoch;</span><br><span class="line"></span><br><span class="line">            int version = 0x0;</span><br><span class="line">            if (!backCompatibility28) &#123;</span><br><span class="line">                rpeerepoch = response.buffer.getLong();</span><br><span class="line">                if (!backCompatibility40) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * Version added in 3.4.6</span><br><span class="line">                     */</span><br><span class="line">                    </span><br><span class="line">                    version = response.buffer.getInt();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    LOG.info(&quot;Backward compatibility mode (36 bits), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.info(&quot;Backward compatibility mode (28 bits), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QuorumVerifier rqv = null;</span><br><span class="line"></span><br><span class="line">            //消息中含有配置文件</span><br><span class="line">            if (version &gt; 0x1) &#123;</span><br><span class="line">                ...  </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.info(&quot;Backward compatibility mode (before reconfig), server id: &#123;&#125;&quot;, response.sid);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            //该服务器不具有选举权限</span><br><span class="line">            if(!self.getCurrentAndNextConfigVoters().contains(response.sid)) &#123;</span><br><span class="line">                Vote current = self.getCurrentVote();</span><br><span class="line">                QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                ToSend notmsg = new ToSend(ToSend.mType.notification,</span><br><span class="line">                        current.getId(),</span><br><span class="line">                        current.getZxid(),</span><br><span class="line">                        logicalclock.get(),</span><br><span class="line">                        self.getPeerState(),</span><br><span class="line">                        response.sid,</span><br><span class="line">                        current.getPeerEpoch(),</span><br><span class="line">                        qv.toString().getBytes());</span><br><span class="line">                //直接发送本机的投票信息</span><br><span class="line">                sendqueue.offer(notmsg);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //投票服务器的状态</span><br><span class="line">                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                switch (rstate) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.LOOKING;</span><br><span class="line">                    break;</span><br><span class="line">                case 1:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.FOLLOWING;</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.LEADING;</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    ackstate = QuorumPeer.ServerState.OBSERVING;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //初始化投票信息</span><br><span class="line">                n.leader = rleader;</span><br><span class="line">                n.zxid = rzxid;</span><br><span class="line">                n.electionEpoch = relectionEpoch;</span><br><span class="line">                n.state = ackstate;</span><br><span class="line">                n.sid = response.sid;</span><br><span class="line">                n.peerEpoch = rpeerepoch;</span><br><span class="line">                n.version = version;</span><br><span class="line">                n.qv = rqv;</span><br><span class="line">                //本机是选举状态</span><br><span class="line">                if(self.getPeerState() == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                    //消息添加到接受队列</span><br><span class="line">                    recvqueue.offer(n);</span><br><span class="line">                    //发送消息的服务器为选举状态</span><br><span class="line">                    if((ackstate == QuorumPeer.ServerState.LOOKING)</span><br><span class="line">                            &amp;&amp; (n.electionEpoch &lt; logicalclock.get()))&#123;</span><br><span class="line">                        Vote v = getVote();</span><br><span class="line">                        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                        ToSend notmsg = new ToSend(ToSend.mType.notification,</span><br><span class="line">                                v.getId(),</span><br><span class="line">                                v.getZxid(),</span><br><span class="line">                                logicalclock.get(),</span><br><span class="line">                                self.getPeerState(),</span><br><span class="line">                                response.sid,</span><br><span class="line">                                v.getPeerEpoch(),</span><br><span class="line">                                qv.toString().getBytes());</span><br><span class="line">                        //发送本机的选票</span><br><span class="line">                        sendqueue.offer(notmsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //本机非选举状态直接发送当前选举结果</span><br><span class="line">                    Vote current = self.getCurrentVote();</span><br><span class="line">                    if(ackstate == QuorumPeer.ServerState.LOOKING)&#123;</span><br><span class="line">                        if(LOG.isDebugEnabled())&#123;</span><br><span class="line">                            LOG.debug(&quot;Sending new notification. My id =&#123;&#125; recipient=&#123;&#125; zxid=0x&#123;&#125; leader=&#123;&#125; config version = &#123;&#125;&quot;,</span><br><span class="line">                                    self.getId(),</span><br><span class="line">                                    response.sid,</span><br><span class="line">                                    Long.toHexString(current.getZxid()),</span><br><span class="line">                                    current.getId(),</span><br><span class="line">                                    Long.toHexString(self.getQuorumVerifier().getVersion()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">                        ToSend notmsg = new ToSend(</span><br><span class="line">                                ToSend.mType.notification,</span><br><span class="line">                                current.getId(),</span><br><span class="line">                                current.getZxid(),</span><br><span class="line">                                current.getElectionEpoch(),</span><br><span class="line">                                self.getPeerState(),</span><br><span class="line">                                response.sid,</span><br><span class="line">                                current.getPeerEpoch(),</span><br><span class="line">                                qv.toString().getBytes());</span><br><span class="line">                        sendqueue.offer(notmsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20、接（一、2）QuorumPeer的run方法"><a href="#20、接（一、2）QuorumPeer的run方法" class="headerlink" title="20、接（一、2）QuorumPeer的run方法"></a>20、接（一、2）QuorumPeer的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    updateThreadName();</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Main loop</span><br><span class="line">         */</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            //本机状态</span><br><span class="line">            switch (getPeerState()) &#123;</span><br><span class="line">            case LOOKING:</span><br><span class="line">                //本机为只读服务器</span><br><span class="line">                if (Boolean.getBoolean(&quot;readonlymode.enabled&quot;)) &#123;</span><br><span class="line">                    LOG.info(&quot;Attempting to start ReadOnlyZooKeeperServer&quot;);</span><br><span class="line"></span><br><span class="line">                    // Create read-only server but don&apos;t start it immediately</span><br><span class="line">                    final ReadOnlyZooKeeperServer roZk =</span><br><span class="line">                        new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);</span><br><span class="line"></span><br><span class="line">                    //等待两秒钟启动服务器</span><br><span class="line">                    Thread roZkMgr = new Thread() &#123;</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                // lower-bound grace period to 2 secs</span><br><span class="line">                                sleep(Math.max(2000, tickTime));</span><br><span class="line">                                if (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;);</span><br><span class="line">                            &#125; catch (Exception e) &#123;</span><br><span class="line">                                LOG.error(&quot;FAILED to start ReadOnlyZooKeeperServer&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        if (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = false;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        //选举并设置当前投票</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        if (shuttingDownLE) &#123;</span><br><span class="line">                           shuttingDownLE = false;</span><br><span class="line">                           startLeaderElection();</span><br><span class="line">                           &#125;</span><br><span class="line">                        //选举并设置当前选举结果</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        LOG.warn(&quot;Unexpected exception&quot;, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;                        </span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case OBSERVING:</span><br><span class="line">                try &#123;</span><br><span class="line">                    LOG.info(&quot;OBSERVING&quot;);</span><br><span class="line">                    setObserver(makeObserver(logFactory));</span><br><span class="line">                    //只读服务器初始化</span><br><span class="line">                    observer.observeLeader();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    LOG.warn(&quot;Unexpected exception&quot;,e );</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    observer.shutdown();</span><br><span class="line">                    setObserver(null);  </span><br><span class="line">                   updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case FOLLOWING:</span><br><span class="line">                try &#123;</span><br><span class="line">                   LOG.info(&quot;FOLLOWING&quot;);</span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    //初始化</span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                   LOG.warn(&quot;Unexpected exception&quot;,e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                   follower.shutdown();</span><br><span class="line">                   setFollower(null);</span><br><span class="line">                   updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case LEADING:</span><br><span class="line">                LOG.info(&quot;LEADING&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    setLeader(makeLeader(logFactory));</span><br><span class="line">                    //初始化</span><br><span class="line">                    leader.lead();</span><br><span class="line">                    setLeader(null);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    LOG.warn(&quot;Unexpected exception&quot;,e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (leader != null) &#123;</span><br><span class="line">                        leader.shutdown(&quot;Forcing shutdown&quot;);</span><br><span class="line">                        setLeader(null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    updateServerState();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            start_fle = Time.currentElapsedTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21、FastLeaderElection的lookForLeader方法选举LEADER"><a href="#21、FastLeaderElection的lookForLeader方法选举LEADER" class="headerlink" title="21、FastLeaderElection的lookForLeader方法选举LEADER"></a>21、FastLeaderElection的lookForLeader方法选举LEADER</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">public Vote lookForLeader() throws InterruptedException &#123;</span><br><span class="line">    ...</span><br><span class="line">    //选举开始时间</span><br><span class="line">    if (self.start_fle == 0) &#123;</span><br><span class="line">       self.start_fle = Time.currentElapsedTime();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //收到的投票</span><br><span class="line">        Map&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line">        Map&lt;Long, Vote&gt; outofelection = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        int notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            //选举轮次加一</span><br><span class="line">            logicalclock.incrementAndGet();</span><br><span class="line">            //更新投票提议，默认投自己</span><br><span class="line">            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //广播本机选票</span><br><span class="line">        sendNotifications();</span><br><span class="line">        //本机处于选举状态且为停止</span><br><span class="line">        while ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop))&#123;</span><br><span class="line">            //取出接收到的消息</span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                    TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            //未收到投票</span><br><span class="line">            if(n == null)&#123;</span><br><span class="line">                //投票已发送</span><br><span class="line">                if(manager.haveDelivered())&#123;</span><br><span class="line">                    //重新发送</span><br><span class="line">                    sendNotifications();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //投票未发送，重新连接</span><br><span class="line">                    manager.connectAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * Exponential backoff</span><br><span class="line">                 */</span><br><span class="line">                int tmpTimeOut = notTimeout*2;</span><br><span class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</span><br><span class="line">                        tmpTimeOut : maxNotificationInterval);</span><br><span class="line">                LOG.info(&quot;Notification time out: &quot; + notTimeout);</span><br><span class="line">            &#125; </span><br><span class="line">            else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) &#123;</span><br><span class="line">                switch (n.state) &#123;</span><br><span class="line">                //投票的服务器处于选举状态</span><br><span class="line">                case LOOKING:</span><br><span class="line">                    //-1说明加载数据出错，不处理</span><br><span class="line">                    if (getInitLastLoggedZxid() == -1) &#123;</span><br><span class="line">                        LOG.debug(&quot;Ignoring notification as our zxid is -1&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (n.zxid == -1) &#123;</span><br><span class="line">                        LOG.debug(&quot;Ignoring notification from member with -1 zxid&quot; + n.sid);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //发消息的服务器选举轮次大于本机轮次</span><br><span class="line">                    if (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                        //更新轮次</span><br><span class="line">                        logicalclock.set(n.electionEpoch);</span><br><span class="line">                        //废弃所有收到的选票</span><br><span class="line">                        recvset.clear();</span><br><span class="line">                        //选举PK，更新当前的提议为胜出者</span><br><span class="line">                        if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            updateProposal(getInitId(),</span><br><span class="line">                                    getInitLastLoggedZxid(),</span><br><span class="line">                                    getPeerEpoch());</span><br><span class="line">                        &#125;</span><br><span class="line">                        //发送选票</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; else if (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                        //发消息的服务器选举轮次小于本机轮次，不处理，跳出switch</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                            proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                        //同一轮次，选票PK，更新胜出者为当前提议</span><br><span class="line">                        updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        //发送消息</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //当前选票信息，添加到map中</span><br><span class="line">                    recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                    //若当前提议超过半数</span><br><span class="line">                    if (termPredicate(recvset,</span><br><span class="line">                            new Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                    logicalclock.get(), proposedEpoch))) &#123;</span><br><span class="line"></span><br><span class="line">                        //检查投票中，是否有PK胜出当前提议的投票</span><br><span class="line">                        while((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                TimeUnit.MILLISECONDS)) != null)&#123;</span><br><span class="line">                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                    proposedLeader, proposedZxid, proposedEpoch))&#123;</span><br><span class="line">                                recvqueue.put(n);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (n == null) &#123;</span><br><span class="line">                            //当前提议为最终结果，若提以为自己，则本机当选LEADER</span><br><span class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                            //设置最终选票</span><br><span class="line">                            Vote endVote = new Vote(proposedLeader,</span><br><span class="line">                                    proposedZxid, proposedEpoch);</span><br><span class="line">                            //清除选票容器</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            //返回最终选票</span><br><span class="line">                            return endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case OBSERVING:</span><br><span class="line">                    //当前状态为观察者，不参与处理</span><br><span class="line">                    break;</span><br><span class="line">                case FOLLOWING:</span><br><span class="line">                case LEADING:</span><br><span class="line">                    //发出消息的服务器，与本机轮次相同</span><br><span class="line">                    if(n.electionEpoch == logicalclock.get())&#123;</span><br><span class="line">                        //保存收到的选票</span><br><span class="line">                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                        //若n的选票超过半数，并且n的状态为Leader，并且n不为本机，则更新本机状态、选举结果</span><br><span class="line">                        if(termPredicate(recvset, new Vote(n.leader,</span><br><span class="line">                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                                        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line"></span><br><span class="line">                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            return endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    outofelection.put(n.sid, new Vote(n.leader, </span><br><span class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</span><br><span class="line">                    if (termPredicate(outofelection, new Vote(n.leader,</span><br><span class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</span><br><span class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</span><br><span class="line">                        synchronized(this)&#123;</span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                    ServerState.LEADING: learningState());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        leaveInstance(endVote);</span><br><span class="line">                        return endVote;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    LOG.warn(&quot;Notification state unrecoginized: &quot; + n.state</span><br><span class="line">                          + &quot; (n.state), &quot; + n.sid + &quot; (n.sid)&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG.warn(&quot;Ignoring notification from non-cluster member &quot; + n.sid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此leader选举就完成了;</p><h3 id="二、LEADER初始化过程"><a href="#二、LEADER初始化过程" class="headerlink" title="二、LEADER初始化过程"></a>二、LEADER初始化过程</h3><h4 id="1、实例化Leader"><a href="#1、实例化Leader" class="headerlink" title="1、实例化Leader"></a>1、实例化Leader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Leader(QuorumPeer self,LeaderZooKeeperServer zk) throws IOException &#123;</span><br><span class="line">    this.self = self;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">            ss = new ServerSocket(self.getQuorumAddress().getPort());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //socket服务器等待follower连接</span><br><span class="line">            ss = new ServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">        ss.setReuseAddress(true);</span><br><span class="line">        if (!self.getQuorumListenOnAllIPs()) &#123;</span><br><span class="line">            //监听地址</span><br><span class="line">            ss.bind(self.getQuorumAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (BindException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    //leader服务器</span><br><span class="line">    this.zk = zk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LEADER的lead方法"><a href="#2、LEADER的lead方法" class="headerlink" title="2、LEADER的lead方法"></a>2、LEADER的lead方法</h4><p>lead方法实现初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">void lead() throws IOException, InterruptedException &#123;</span><br><span class="line">    self.end_fle = Time.currentElapsedTime();</span><br><span class="line">    //leader选举所花的时间</span><br><span class="line">    long electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">    self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">    self.start_fle = 0;</span><br><span class="line">    self.end_fle = 0;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //leader计时器</span><br><span class="line">        self.tick.set(0);</span><br><span class="line">        //恢复数据</span><br><span class="line">        zk.loadData();</span><br><span class="line">        //leader服务器最新的事务状态</span><br><span class="line">        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());</span><br><span class="line"></span><br><span class="line">        // 等待follower接入的线程</span><br><span class="line">        cnxAcceptor = new LearnerCnxAcceptor();</span><br><span class="line">        cnxAcceptor.start();</span><br><span class="line">        //等待足够多的follower进来，代表自己确实是leader，此处lead线程可能会等待 </span><br><span class="line">        //返回最新的批次加一</span><br><span class="line">        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());</span><br><span class="line">        //用最新的批次创建事务序号</span><br><span class="line">        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));</span><br><span class="line"></span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            //最新提交的事务序号</span><br><span class="line">            lastProposed = zk.getZxid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),</span><br><span class="line">               null, null);</span><br><span class="line"></span><br><span class="line">        //新批次的事务序号不是从零开始</span><br><span class="line">        if ((newLeaderProposal.packet.getZxid() &amp; 0xffffffffL) != 0) &#123;</span><br><span class="line">            LOG.info(&quot;NEWLEADER proposal has Zxid of &quot;</span><br><span class="line">                    + Long.toHexString(newLeaderProposal.packet.getZxid()));</span><br><span class="line">        &#125;</span><br><span class="line">        //校验器</span><br><span class="line">        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">        QuorumVerifier curQV = self.getQuorumVerifier();</span><br><span class="line">        if (curQV.getVersion() == 0 &amp;&amp; curQV.getVersion() == lastSeenQV.getVersion()) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               QuorumVerifier newQV = self.configFromString(curQV.toString());</span><br><span class="line">               newQV.setVersion(zk.getZxid());</span><br><span class="line">               self.setLastSeenQuorumVerifier(newQV, true);    </span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               throw new IOException(e);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">        if (self.getLastSeenQuorumVerifier().getVersion() &gt; self.getQuorumVerifier().getVersion())&#123;</span><br><span class="line">           newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         //等待足够多的follower确认，leader的事务为最新的事务</span><br><span class="line">         waitForEpochAck(self.getId(), leaderStateSummary);</span><br><span class="line">         //设置当前批次</span><br><span class="line">         self.setCurrentEpoch(epoch);    </span><br><span class="line">        </span><br><span class="line">         try &#123;</span><br><span class="line">             //等待最少半数follower同步数据完成</span><br><span class="line">             waitForNewLeaderAck(self.getId(), zk.getZxid(), LearnerType.PARTICIPANT);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //启动LeaderZooKeeperServer</span><br><span class="line">         startZkServer();</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">        // We ping twice a tick, so we only update the tick every other</span><br><span class="line">        // iteration</span><br><span class="line">        boolean tickSkip = true;</span><br><span class="line">        // If not null then shutdown this leader</span><br><span class="line">        String shutdownMessage = null;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                long start = Time.currentElapsedTime();</span><br><span class="line">                long cur = start;</span><br><span class="line">                long end = start + self.tickTime / 2;</span><br><span class="line">                while (cur &lt; end) &#123;</span><br><span class="line">                    //等待</span><br><span class="line">                    wait(end - cur);</span><br><span class="line">                    cur = Time.currentElapsedTime();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!tickSkip) &#123;</span><br><span class="line">                    计时器加一</span><br><span class="line">                    self.tick.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //未超时的服务器的id集合</span><br><span class="line">                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();</span><br><span class="line">                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());</span><br><span class="line">                if (self.getLastSeenQuorumVerifier() != null</span><br><span class="line">                        &amp;&amp; self.getLastSeenQuorumVerifier().getVersion() &gt; self</span><br><span class="line">                                .getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">                    syncedAckSet.addQuorumVerifier(self</span><br><span class="line">                            .getLastSeenQuorumVerifier());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                syncedAckSet.addAck(self.getId());</span><br><span class="line"></span><br><span class="line">                for (LearnerHandler f : getLearners()) &#123;</span><br><span class="line">                    //连接未超时</span><br><span class="line">                    if (f.synced()) &#123;</span><br><span class="line">                        syncedAckSet.addAck(f.getSid());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // check leader running status</span><br><span class="line">                if (!this.isRunning()) &#123;</span><br><span class="line">                    // set shutdown flag</span><br><span class="line">                    shutdownMessage = &quot;Unexpected internal error&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //未超时的连接小于半数，则退出主循环</span><br><span class="line">                if (!tickSkip &amp;&amp; !syncedAckSet.hasAllQuorums()) &#123;</span><br><span class="line">                    shutdownMessage = &quot;Not sufficient followers synced, only synced with sids: [ &quot;</span><br><span class="line">                            + syncedAckSet.ackSetsToString() + &quot; ]&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                tickSkip = !tickSkip;</span><br><span class="line">            &#125;</span><br><span class="line">            for (LearnerHandler f : getLearners()) &#123;</span><br><span class="line">                //心跳检测</span><br><span class="line">                f.ping();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shutdownMessage != null) &#123;</span><br><span class="line">            shutdown(shutdownMessage);</span><br><span class="line">            // leader goes in looking state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        zk.unregisterJMX(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、LearnerCnxAcceptor线程的run方法"><a href="#3、LearnerCnxAcceptor线程的run方法" class="headerlink" title="3、LearnerCnxAcceptor线程的run方法"></a>3、LearnerCnxAcceptor线程的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (!stop) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                //接受follower连接</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                // start with the initLimit, once the ack is processed</span><br><span class="line">                // in LearnerHandler switch to the syncLimit</span><br><span class="line">                s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">                s.setTcpNoDelay(nodelay);</span><br><span class="line"></span><br><span class="line">                BufferedInputStream is = new BufferedInputStream(</span><br><span class="line">                        s.getInputStream());</span><br><span class="line">                //处理follower数据的线程</span><br><span class="line">                LearnerHandler fh = new LearnerHandler(s, is, Leader.this);</span><br><span class="line">                fh.start();</span><br><span class="line">            &#125; catch</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.warn(&quot;Exception while accepting follower&quot;, e.getMessage());</span><br><span class="line">        handleException(this.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、LearnerHandler线程的run方法"><a href="#4、LearnerHandler线程的run方法" class="headerlink" title="4、LearnerHandler线程的run方法"></a>4、LearnerHandler线程的run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        leader.addLearnerHandler(this);</span><br><span class="line">        //超时时间</span><br><span class="line">        tickOfNextAckDeadline = leader.self.tick.get()</span><br><span class="line">                + leader.self.initLimit + leader.self.syncLimit;</span><br><span class="line"></span><br><span class="line">        ia = BinaryInputArchive.getArchive(bufferedInput);</span><br><span class="line">        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        oa = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line"></span><br><span class="line">        QuorumPacket qp = new QuorumPacket();</span><br><span class="line">        ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line">        //检查数据类型</span><br><span class="line">        if(qp.getType() != Leader.FOLLOWERINFO &amp;&amp; qp.getType() != Leader.OBSERVERINFO)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte learnerInfoData[] = qp.getData();</span><br><span class="line">        if (learnerInfoData != null) &#123;</span><br><span class="line">            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);</span><br><span class="line">            if (learnerInfoData.length &gt;= 8) &#123;</span><br><span class="line">                this.sid = bbsid.getLong();</span><br><span class="line">            &#125;</span><br><span class="line">            if (learnerInfoData.length &gt;= 12) &#123;</span><br><span class="line">                this.version = bbsid.getInt(); // protocolVersion</span><br><span class="line">            &#125;</span><br><span class="line">            if (learnerInfoData.length &gt;= 20) &#123;</span><br><span class="line">                long configVersion = bbsid.getLong();</span><br><span class="line">                if (configVersion &gt; leader.self.getQuorumVerifier().getVersion()) &#123;</span><br><span class="line">                    throw new IOException(&quot;Follower is ahead of the leader (has a later activated configuration)&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.sid = leader.followerCounter.getAndDecrement();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (qp.getType() == Leader.OBSERVERINFO) &#123;</span><br><span class="line">              learnerType = LearnerType.OBSERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //follwer的最新批次</span><br><span class="line">        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">        long peerLastZxid;</span><br><span class="line">        StateSummary ss = null;</span><br><span class="line">        long zxid = qp.getZxid();</span><br><span class="line">        //等待足够多的follower进来，代表自己确实是leader，此处lead线程可能会等待 </span><br><span class="line">        //返回最新的批次加一</span><br><span class="line">        long newEpoch = leader.getEpochToPropose(this.getSid(), lastAcceptedEpoch);</span><br><span class="line">        //最新批次事务序号</span><br><span class="line">        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);</span><br><span class="line"></span><br><span class="line">        if (this.getVersion() &lt; 0x10000) &#123;</span><br><span class="line">            // we are going to have to extrapolate the epoch information</span><br><span class="line">            long epoch = ZxidUtils.getEpochFromZxid(zxid);</span><br><span class="line">            //该follower的最新事务批次、最大事务序号</span><br><span class="line">            ss = new StateSummary(epoch, zxid);</span><br><span class="line">            //确认follower的事务序号小于leader，需等待半数follower完成</span><br><span class="line">            leader.waitForEpochAck(this.getSid(), ss);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte ver[] = new byte[4];</span><br><span class="line">            ByteBuffer.wrap(ver).putInt(0x10000);</span><br><span class="line">            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);</span><br><span class="line">            oa.writeRecord(newEpochPacket, &quot;packet&quot;);</span><br><span class="line">            bufferedOutput.flush();</span><br><span class="line">            QuorumPacket ackEpochPacket = new QuorumPacket();</span><br><span class="line">            ia.readRecord(ackEpochPacket, &quot;packet&quot;);</span><br><span class="line">            if (ackEpochPacket.getType() != Leader.ACKEPOCH) &#123;</span><br><span class="line">                LOG.error(ackEpochPacket.toString()</span><br><span class="line">                        + &quot; is not ACKEPOCH&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());</span><br><span class="line">            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());</span><br><span class="line">            leader.waitForEpochAck(this.getSid(), ss);</span><br><span class="line">        &#125;</span><br><span class="line">        //该follwer最新的事务序号</span><br><span class="line">        peerLastZxid = ss.getLastZxid();</span><br><span class="line">       </span><br><span class="line">        //向该follower同步数据</span><br><span class="line">        boolean needSnap = syncFollower(peerLastZxid, leader.zk.getZKDatabase(), leader);</span><br><span class="line">    </span><br><span class="line">        // 发送newleader给follower</span><br><span class="line">        if (getVersion() &lt; 0x10000) &#123;</span><br><span class="line">            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,</span><br><span class="line">                    newLeaderZxid, null, null);</span><br><span class="line">            oa.writeRecord(newLeaderQP, &quot;packet&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER,</span><br><span class="line">                    newLeaderZxid, leader.self.getLastSeenQuorumVerifier()</span><br><span class="line">                            .toString().getBytes(), null);</span><br><span class="line">            queuedPackets.add(newLeaderQP);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">        /* if we are not truncating or sending a diff just send a snapshot */</span><br><span class="line">        if (needSnap) &#123;</span><br><span class="line">            boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;</span><br><span class="line">            LearnerSnapshot snapshot = </span><br><span class="line">                    leader.getLearnerSnapshotThrottler().beginSnapshot(exemptFromThrottle);</span><br><span class="line">            try &#123;</span><br><span class="line">                long zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), &quot;packet&quot;);</span><br><span class="line">                bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">                // 向follower发送快照</span><br><span class="line">                leader.zk.getZKDatabase().serializeSnapshot(oa);</span><br><span class="line">                oa.writeString(&quot;BenWasHere&quot;, &quot;signature&quot;);</span><br><span class="line">                bufferedOutput.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                snapshot.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 启动发送数据包的线程,发送queuedPackets中数据</span><br><span class="line">        startSendingPackets();</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * Have to wait for the first ACK, wait until</span><br><span class="line">         * the leader is ready, and only then we can</span><br><span class="line">         * start processing messages.</span><br><span class="line">         */</span><br><span class="line">        qp = new QuorumPacket();</span><br><span class="line">        ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line">        if(qp.getType() != Leader.ACK)&#123;</span><br><span class="line">            ...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //follower同步数据完成，检查follower最新事务序号是否与leader相同，等待半数follower完成</span><br><span class="line">        leader.waitForNewLeaderAck(getSid(), qp.getZxid(), getLearnerType());</span><br><span class="line"></span><br><span class="line">        //等待时间限制</span><br><span class="line">        syncLimitCheck.start();</span><br><span class="line">        </span><br><span class="line">        // now that the ack has been processed expect the syncLimit</span><br><span class="line">        sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);</span><br><span class="line"></span><br><span class="line">        //等待LeaderZooKeeperServer启动</span><br><span class="line">        synchronized(leader.zk)&#123;</span><br><span class="line">            while(!leader.zk.isRunning() &amp;&amp; !this.isInterrupted())&#123;</span><br><span class="line">                leader.zk.wait(20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //通知follower退出同步数据循环     </span><br><span class="line">        queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));</span><br><span class="line">        //主循环</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            qp = new QuorumPacket();</span><br><span class="line">            //读取follower发来的数据</span><br><span class="line">            ia.readRecord(qp, &quot;packet&quot;);</span><br><span class="line"></span><br><span class="line">            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;</span><br><span class="line">            if (qp.getType() == Leader.PING) &#123;</span><br><span class="line">                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">            tickOfNextAckDeadline = leader.self.tick.get() + leader.self.syncLimit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ByteBuffer bb;</span><br><span class="line">            long sessionId;</span><br><span class="line">            int cxid;</span><br><span class="line">            int type;</span><br><span class="line"></span><br><span class="line">            switch (qp.getType()) &#123;</span><br><span class="line">            case Leader.ACK:</span><br><span class="line">                //刷新时间</span><br><span class="line">                syncLimitCheck.updateAck(qp.getZxid());</span><br><span class="line">                //处理follower对提议返回的投票</span><br><span class="line">                leader.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());</span><br><span class="line">                break;</span><br><span class="line">            case Leader.PING:</span><br><span class="line">                // 心跳信息</span><br><span class="line">                ByteArrayInputStream bis = new ByteArrayInputStream(qp</span><br><span class="line">                        .getData());</span><br><span class="line">                DataInputStream dis = new DataInputStream(bis);</span><br><span class="line">                while (dis.available() &gt; 0) &#123;</span><br><span class="line">                    long sess = dis.readLong();</span><br><span class="line">                    int to = dis.readInt();</span><br><span class="line">                    //更新session的有效时间</span><br><span class="line">                    leader.zk.touch(sess, to);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case Leader.REVALIDATE:</span><br><span class="line">                bis = new ByteArrayInputStream(qp.getData());</span><br><span class="line">                dis = new DataInputStream(bis);</span><br><span class="line">                long id = dis.readLong();</span><br><span class="line">                int to = dis.readInt();</span><br><span class="line">                ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">                DataOutputStream dos = new DataOutputStream(bos);</span><br><span class="line">                dos.writeLong(id);</span><br><span class="line">                boolean valid = leader.zk.checkIfValidGlobalSession(id, to);</span><br><span class="line">                if (valid) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //set the session owner</span><br><span class="line">                        // as the follower that</span><br><span class="line">                        // owns the session</span><br><span class="line">                        leader.zk.setOwner(id, this);</span><br><span class="line">                    &#125; catch (SessionExpiredException e) &#123;</span><br><span class="line">                        LOG.error(&quot;Somehow session &quot; + Long.toHexString(id) +</span><br><span class="line">                                &quot; expired right after being renewed! (impossible)&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dos.writeBoolean(valid);</span><br><span class="line">                qp.setData(bos.toByteArray());</span><br><span class="line">                queuedPackets.add(qp);</span><br><span class="line">                break;</span><br><span class="line">            case Leader.REQUEST:</span><br><span class="line">      //Follower转发过来的请求</span><br><span class="line">                bb = ByteBuffer.wrap(qp.getData());</span><br><span class="line">                sessionId = bb.getLong();</span><br><span class="line">                cxid = bb.getInt();</span><br><span class="line">                type = bb.getInt();</span><br><span class="line">                bb = bb.slice();</span><br><span class="line">                Request si;</span><br><span class="line">                if(type == OpCode.sync)&#123;</span><br><span class="line">                    si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());</span><br><span class="line">                &#125;</span><br><span class="line">                si.setOwner(this);</span><br><span class="line">                //调用prepRequestProcessor处理request</span><br><span class="line">                leader.zk.submitLearnerRequest(si);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                LOG.warn(&quot;unexpected quorum packet, type: &#123;&#125;&quot;, packetToString(qp));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Leader的getEpochToPropose方法"><a href="#5、Leader的getEpochToPropose方法" class="headerlink" title="5、Leader的getEpochToPropose方法"></a>5、Leader的getEpochToPropose方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public long getEpochToPropose(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException &#123;</span><br><span class="line">        synchronized(connectingFollowers) &#123;</span><br><span class="line">            if (!waitingForNewEpoch) &#123;</span><br><span class="line">                return epoch;</span><br><span class="line">            &#125;</span><br><span class="line">            //follower最新批次大于等于当前批次</span><br><span class="line">            if (lastAcceptedEpoch &gt;= epoch) &#123;</span><br><span class="line">                epoch = lastAcceptedEpoch+1;</span><br><span class="line">            &#125;</span><br><span class="line">            //已连接的follower集合</span><br><span class="line">            connectingFollowers.add(sid);</span><br><span class="line">            QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">            //已连接的follower是否超过半数</span><br><span class="line">            if (connectingFollowers.contains(self.getId()) &amp;&amp;</span><br><span class="line">                                            verifier.containsQuorum(connectingFollowers)) &#123;</span><br><span class="line">                waitingForNewEpoch = false;</span><br><span class="line">                self.setAcceptedEpoch(epoch);</span><br><span class="line">                connectingFollowers.notifyAll();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //不超过半数，则等待其他follower接入</span><br><span class="line">                long start = Time.currentElapsedTime();</span><br><span class="line">                long cur = start;</span><br><span class="line">                long end = start + self.getInitLimit()*self.getTickTime();</span><br><span class="line">                while(waitingForNewEpoch &amp;&amp; cur &lt; end) &#123;</span><br><span class="line">                    connectingFollowers.wait(end - cur);</span><br><span class="line">                    cur = Time.currentElapsedTime();</span><br><span class="line">                &#125;</span><br><span class="line">                if (waitingForNewEpoch) &#123;</span><br><span class="line">                    throw new InterruptedException(&quot;Timeout while waiting for epoch from quorum&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return epoch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6、接（二、4）Leader的waitForEpochAck方法"><a href="#6、接（二、4）Leader的waitForEpochAck方法" class="headerlink" title="6、接（二、4）Leader的waitForEpochAck方法"></a>6、接（二、4）Leader的waitForEpochAck方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void waitForEpochAck(long id, StateSummary ss) throws IOException, InterruptedException &#123;</span><br><span class="line">    synchronized(electingFollowers) &#123;</span><br><span class="line">        if (electionFinished) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ss.getCurrentEpoch() != -1) &#123;</span><br><span class="line">            //follower的事务大于leader</span><br><span class="line">            if (ss.isMoreRecentThan(leaderStateSummary)) &#123;</span><br><span class="line">                throw new IOException(&quot;Follower is ahead of the leader, leader summary: &quot; </span><br><span class="line">                                                + leaderStateSummary.getCurrentEpoch()</span><br><span class="line">                                                + &quot; (current epoch), &quot;</span><br><span class="line">                                                + leaderStateSummary.getLastZxid()</span><br><span class="line">                                                + &quot; (last zxid)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ss.getLastZxid() != -1) &#123;</span><br><span class="line">                //已完成确认的follower的集合</span><br><span class="line">                electingFollowers.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">        //是否有半数的follower完成确认</span><br><span class="line">        if (electingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(electingFollowers)) &#123;</span><br><span class="line">            electionFinished = true;</span><br><span class="line">            electingFollowers.notifyAll();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long start = Time.currentElapsedTime();</span><br><span class="line">            long cur = start;</span><br><span class="line">            long end = start + self.getInitLimit()*self.getTickTime();</span><br><span class="line">            while(!electionFinished &amp;&amp; cur &lt; end) &#123;</span><br><span class="line">                electingFollowers.wait(end - cur);</span><br><span class="line">                cur = Time.currentElapsedTime();</span><br><span class="line">            &#125;</span><br><span class="line">            if (!electionFinished) &#123;</span><br><span class="line">                throw new InterruptedException(&quot;Timeout while waiting for epoch to be acked by quorum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、接（二、4）LearnerHandler的syncFollower方法"><a href="#7、接（二、4）LearnerHandler的syncFollower方法" class="headerlink" title="7、接（二、4）LearnerHandler的syncFollower方法"></a>7、接（二、4）LearnerHandler的syncFollower方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) &#123;</span><br><span class="line">    //follower的事务于leader一致</span><br><span class="line">    boolean isPeerNewEpochZxid = (peerLastZxid &amp; 0xffffffffL) == 0;</span><br><span class="line">    //follower的当前事务序号</span><br><span class="line">    long currentZxid = peerLastZxid;</span><br><span class="line">    boolean needSnap = true;</span><br><span class="line">    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();</span><br><span class="line">    ReentrantReadWriteLock lock = db.getLogLock();</span><br><span class="line">    ReadLock rl = lock.readLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        rl.lock();</span><br><span class="line">        long maxCommittedLog = db.getmaxCommittedLog();</span><br><span class="line">        long minCommittedLog = db.getminCommittedLog();</span><br><span class="line">        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();</span><br><span class="line"></span><br><span class="line">        //最近一段时间内执行的事务</span><br><span class="line">        if (db.getCommittedLog().isEmpty()) &#123;</span><br><span class="line">            minCommittedLog = lastProcessedZxid;</span><br><span class="line">            maxCommittedLog = lastProcessedZxid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (forceSnapSync) &#123;</span><br><span class="line">            // Force leader to use snapshot to sync with follower</span><br><span class="line">            LOG.warn(&quot;Forcing snapshot sync - should not see this in production&quot;);</span><br><span class="line">        &#125; else if (lastProcessedZxid == peerLastZxid) &#123;</span><br><span class="line">            //follower的事务与leader相等，无需同步，将Leader.DIFF类型的数据包，加入待发送队列</span><br><span class="line">            queueOpPacket(Leader.DIFF, peerLastZxid);</span><br><span class="line">            needOpPacket = false;</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if (peerLastZxid &gt; maxCommittedLog &amp;&amp; !isPeerNewEpochZxid) &#123;</span><br><span class="line">            // follower事务序号超出了leader，废弃掉超出的部分</span><br><span class="line">            queueOpPacket(Leader.TRUNC, maxCommittedLog);</span><br><span class="line">            currentZxid = maxCommittedLog;</span><br><span class="line">            needOpPacket = false;</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if ((maxCommittedLog &gt;= peerLastZxid)</span><br><span class="line">                &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</span><br><span class="line">            //Follower的事务序号在CommittedLog之间</span><br><span class="line">            Iterator&lt;Proposal&gt; itr = db.getCommittedLog().iterator();</span><br><span class="line">            //向follower同步事务</span><br><span class="line">            currentZxid = queueCommittedProposals(itr, peerLastZxid,</span><br><span class="line">                                                 null, maxCommittedLog);</span><br><span class="line">            needSnap = false;</span><br><span class="line">        &#125; else if (peerLastZxid &lt; minCommittedLog &amp;&amp; txnLogSyncEnabled) &#123;</span><br><span class="line">            //从事务日志中可取回的事务的数量限制</span><br><span class="line">            long sizeLimit = db.calculateTxnLogSizeLimit();</span><br><span class="line">            //若peerLastZxid超出当前限制，则返回null</span><br><span class="line">            Iterator&lt;Proposal&gt; txnLogItr = db.getProposalsFromTxnLog(</span><br><span class="line">                    peerLastZxid, sizeLimit);</span><br><span class="line">            if (txnLogItr.hasNext()) &#123;</span><br><span class="line">                //同步事务</span><br><span class="line">                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid,</span><br><span class="line">                                                     minCommittedLog, maxCommittedLog);</span><br><span class="line"></span><br><span class="line">                //同步事务</span><br><span class="line">                Iterator&lt;Proposal&gt; committedLogItr = db.getCommittedLog().iterator();</span><br><span class="line">                currentZxid = queueCommittedProposals(committedLogItr, currentZxid,</span><br><span class="line">                                                     null, maxCommittedLog);</span><br><span class="line">                needSnap = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // closing the resources</span><br><span class="line">            if (txnLogItr instanceof TxnLogProposalIterator) &#123;</span><br><span class="line">                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;</span><br><span class="line">                txnProposalItr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG.warn(&quot;Unhandled scenario for peer sid: &quot; +  getSid());</span><br><span class="line">        &#125;</span><br><span class="line">        //处理leader中未完成的事务，将handler加入集合</span><br><span class="line">        leaderLastZxid = leader.startForwarding(this, currentZxid);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        rl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needOpPacket &amp;&amp; !needSnap) &#123;</span><br><span class="line">        // This should never happen, but we should fall back to sending</span><br><span class="line">        // snapshot just in case. 事务同步失败，直接同步快照</span><br><span class="line">        needSnap = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return needSnap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、LearnerHandler的queueCommittedProposals方法"><a href="#8、LearnerHandler的queueCommittedProposals方法" class="headerlink" title="8、LearnerHandler的queueCommittedProposals方法"></a>8、LearnerHandler的queueCommittedProposals方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">protected long queueCommittedProposals(Iterator&lt;Proposal&gt; itr,</span><br><span class="line">        long peerLastZxid, Long maxZxid, Long lastCommittedZxid) &#123;</span><br><span class="line">    //follower的事务序号，已更新为最新</span><br><span class="line">    boolean isPeerNewEpochZxid = (peerLastZxid &amp; 0xffffffffL) == 0;</span><br><span class="line">    long queuedZxid = peerLastZxid;</span><br><span class="line">    // as we look through proposals, this variable keeps track of previous</span><br><span class="line">    // proposal Id.</span><br><span class="line">    long prevProposalZxid = -1;</span><br><span class="line">    while (itr.hasNext()) &#123;</span><br><span class="line">        //取出下个事务</span><br><span class="line">        Proposal propose = itr.next();</span><br><span class="line"></span><br><span class="line">        long packetZxid = propose.packet.getZxid();</span><br><span class="line">        //同步事务序号的上限</span><br><span class="line">        if ((maxZxid != null) &amp;&amp; (packetZxid &gt; maxZxid)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 小于follower的事务无需同步</span><br><span class="line">        if (packetZxid &lt; peerLastZxid) &#123;</span><br><span class="line">            prevProposalZxid = packetZxid;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //默认true</span><br><span class="line">        if (needOpPacket) &#123;</span><br><span class="line"></span><br><span class="line">            // follower同步完成</span><br><span class="line">            if (packetZxid == peerLastZxid) &#123;</span><br><span class="line">                //通知follower，无需同步snaphot</span><br><span class="line">                queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">                needOpPacket = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //follower事务序号为最新批次序号，无需同步</span><br><span class="line">            if (isPeerNewEpochZxid) &#123;</span><br><span class="line">               queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">               needOpPacket = false;</span><br><span class="line">            &#125; else if (packetZxid &gt; peerLastZxid  ) &#123;</span><br><span class="line">                //不是同一批次，无法同步</span><br><span class="line">                if (ZxidUtils.getEpochFromZxid(packetZxid) !=</span><br><span class="line">                        ZxidUtils.getEpochFromZxid(peerLastZxid)) &#123;</span><br><span class="line">                    return queuedZxid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //废弃掉follower的peerLastZxid之后的事务</span><br><span class="line">                queueOpPacket(Leader.TRUNC, prevProposalZxid);</span><br><span class="line">                needOpPacket = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (packetZxid &lt;= queuedZxid) &#123;</span><br><span class="line">            // We can get here, if we don&apos;t have op packet to queue</span><br><span class="line">            // or there is a duplicate txn in a given iterator</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //向follower发出事务提议</span><br><span class="line">        queuePacket(propose.packet);</span><br><span class="line">        //向follower发出事务确认</span><br><span class="line">        queueOpPacket(Leader.COMMIT, packetZxid);</span><br><span class="line">        queuedZxid = packetZxid;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needOpPacket &amp;&amp; isPeerNewEpochZxid) &#123;</span><br><span class="line">        queueOpPacket(Leader.DIFF, lastCommittedZxid);</span><br><span class="line">        needOpPacket = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return queuedZxid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、接（二、7）Leader的startForwarding方法"><a href="#9、接（二、7）Leader的startForwarding方法" class="headerlink" title="9、接（二、7）Leader的startForwarding方法"></a>9、接（二、7）Leader的startForwarding方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">synchronized public long startForwarding(LearnerHandler handler,</span><br><span class="line">        long lastSeenZxid) &#123;</span><br><span class="line">    //leader有尚未</span><br><span class="line">    if (lastProposed &gt; lastSeenZxid) &#123;</span><br><span class="line">        //leader中完成投票，并未commit的事务</span><br><span class="line">        for (Proposal p : toBeApplied) &#123;</span><br><span class="line">            if (p.packet.getZxid() &lt;= lastSeenZxid) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            handler.queuePacket(p.packet);</span><br><span class="line">            QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet</span><br><span class="line">                    .getZxid(), null, null);</span><br><span class="line">            handler.queuePacket(qp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (handler.getLearnerType() == LearnerType.PARTICIPANT) &#123;</span><br><span class="line">            //尚未投票通过的提议</span><br><span class="line">            List&lt;Long&gt;zxids = new ArrayList&lt;Long&gt;(outstandingProposals.keySet());</span><br><span class="line">            Collections.sort(zxids);</span><br><span class="line">            for (Long zxid: zxids) &#123;</span><br><span class="line">                if (zxid &lt;= lastSeenZxid) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                handler.queuePacket(outstandingProposals.get(zxid).packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (handler.getLearnerType() == LearnerType.PARTICIPANT) </span><br><span class="line">        addForwardingFollower(handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addObserverLearnerHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lastProposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、接（二、2）Leader的startZkServer方法"><a href="#10、接（二、2）Leader的startZkServer方法" class="headerlink" title="10、接（二、2）Leader的startZkServer方法"></a>10、接（二、2）Leader的startZkServer方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void startZkServer() &#123;</span><br><span class="line">    // Update lastCommitted and Db&apos;s zxid to a value representing the new epoch</span><br><span class="line">    lastCommitted = zk.getZxid();</span><br><span class="line"></span><br><span class="line">    QuorumVerifier newQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">    </span><br><span class="line">    //获取最合适的备用Leader服务器的id</span><br><span class="line">    Long designatedLeader = getDesignatedLeader(newLeaderProposal, zk.getZxid());                                         </span><br><span class="line"></span><br><span class="line">    self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);</span><br><span class="line">    if (designatedLeader != self.getId()) &#123;</span><br><span class="line">        allowedToCommit = false;</span><br><span class="line">    &#125;</span><br><span class="line">    //启动leader服务器</span><br><span class="line">    zk.startup();</span><br><span class="line">    self.updateElectionVote(getEpoch());</span><br><span class="line"></span><br><span class="line">    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、ZooKeeperServer的startup方法"><a href="#11、ZooKeeperServer的startup方法" class="headerlink" title="11、ZooKeeperServer的startup方法"></a>11、ZooKeeperServer的startup方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  public synchronized void startup() &#123;</span><br><span class="line">    if (sessionTracker == null) &#123;</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    &#125;</span><br><span class="line">    startSessionTracker();</span><br><span class="line">    //启动处理器</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    setState(State.RUNNING);</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、LeaderZooKeeperServer的setupRequestProcessors方法"><a href="#12、LeaderZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="12、LeaderZooKeeperServer的setupRequestProcessors方法"></a>12、LeaderZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">    RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());</span><br><span class="line">    commitProcessor = new CommitProcessor(toBeAppliedProcessor,</span><br><span class="line">            Long.toString(getServerId()), false,</span><br><span class="line">            getZooKeeperServerListener());</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this,</span><br><span class="line">            commitProcessor);</span><br><span class="line">    proposalProcessor.initialize();</span><br><span class="line">    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);</span><br><span class="line">    prepRequestProcessor.start();</span><br><span class="line">    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);</span><br><span class="line"></span><br><span class="line">    setupContainerManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leader初始化结束</p><p>###三、FOLLOWER初始化过程</p><h4 id="1、FOLLOWER的followLeader方法"><a href="#1、FOLLOWER的followLeader方法" class="headerlink" title="1、FOLLOWER的followLeader方法"></a>1、FOLLOWER的followLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void followLeader() throws InterruptedException &#123;</span><br><span class="line">        self.end_fle = Time.currentElapsedTime();</span><br><span class="line">        long electionTimeTaken = self.end_fle - self.start_fle;</span><br><span class="line">        self.setElectionTimeTaken(electionTimeTaken);</span><br><span class="line">        self.start_fle = 0;</span><br><span class="line">        self.end_fle = 0;</span><br><span class="line">        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);</span><br><span class="line">        try &#123;</span><br><span class="line">            //找到leader服务器id</span><br><span class="line">            QuorumServer leaderServer = findLeader();</span><br><span class="line">            try &#123;</span><br><span class="line">                //连接leader服务器</span><br><span class="line">                connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">                //follower注册到leader服务器，返回leader最新的事务zxid</span><br><span class="line">                long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line"></span><br><span class="line">                //check to see if the leader zxid is lower than ours</span><br><span class="line">                //this should never happen but is just a safety check</span><br><span class="line">                long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);</span><br><span class="line">                if (newEpoch &lt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">                    LOG.error(&quot;Proposed leader epoch &quot; + ZxidUtils.zxidToString(newEpochZxid)</span><br><span class="line">                            + &quot; is less than our accepted epoch &quot; + ZxidUtils.zxidToString(self.getAcceptedEpoch()));</span><br><span class="line">                    throw new IOException(&quot;Error: Epoch of leader is lower&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                //和Leader同步数据</span><br><span class="line">                syncWithLeader(newEpochZxid);                </span><br><span class="line">                QuorumPacket qp = new QuorumPacket();</span><br><span class="line">                //主循环</span><br><span class="line">                while (this.isRunning()) &#123;</span><br><span class="line">                    readPacket(qp);</span><br><span class="line">                    processPacket(qp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                ...</span><br><span class="line">                // clear pending revalidations</span><br><span class="line">                pendingRevalidations.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            zk.unregisterJMX((Learner)this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2、FOLLOWER的registerWithLeader方法"><a href="#2、FOLLOWER的registerWithLeader方法" class="headerlink" title="2、FOLLOWER的registerWithLeader方法"></a>2、FOLLOWER的registerWithLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">protected long registerWithLeader(int pktType) throws IOException&#123;</span><br><span class="line">    //将follower的事务序号及follower的id</span><br><span class="line">    long lastLoggedZxid = self.getLastLoggedZxid();</span><br><span class="line">    QuorumPacket qp = new QuorumPacket();                </span><br><span class="line">    qp.setType(pktType);</span><br><span class="line">    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));</span><br><span class="line"></span><br><span class="line">    //Add sid to payload</span><br><span class="line">    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());</span><br><span class="line">    ByteArrayOutputStream bsid = new ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);</span><br><span class="line">    boa.writeRecord(li, &quot;LearnerInfo&quot;);</span><br><span class="line">    qp.setData(bsid.toByteArray());</span><br><span class="line">    //发送数据包</span><br><span class="line">    writePacket(qp, true);</span><br><span class="line">    //读取返回信息</span><br><span class="line">    readPacket(qp);        </span><br><span class="line">    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line">    if (qp.getType() == Leader.LEADERINFO) &#123;</span><br><span class="line">        // we are connected to a 1.0 server so accept the new epoch and read the next packet</span><br><span class="line">        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();</span><br><span class="line">        byte epochBytes[] = new byte[4];</span><br><span class="line">        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);</span><br><span class="line">        if (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">            //更新事务批次</span><br><span class="line">            wrappedEpochBytes.putInt((int)self.getCurrentEpoch());</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        &#125; else if (newEpoch == self.getAcceptedEpoch()) &#123;</span><br><span class="line">            wrappedEpochBytes.putInt(-1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IOException(&quot;Leaders epoch, &quot; + newEpoch + &quot; is less than accepted epoch, &quot; + self.getAcceptedEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);</span><br><span class="line">        writePacket(ackNewEpoch, true);</span><br><span class="line">        //返回leader的最新事务zxid</span><br><span class="line">        return ZxidUtils.makeZxid(newEpoch, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (newEpoch &gt; self.getAcceptedEpoch()) &#123;</span><br><span class="line">            //更新事务批次</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        if (qp.getType() != Leader.NEWLEADER) &#123;</span><br><span class="line">            LOG.error(&quot;First packet should have been NEWLEADER&quot;);</span><br><span class="line">            throw new IOException(&quot;First packet should have been NEWLEADER&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回leader的最新事务zxid</span><br><span class="line">        return qp.getZxid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、接（三、1）FOLLOWER的syncWithLeader方法"><a href="#3、接（三、1）FOLLOWER的syncWithLeader方法" class="headerlink" title="3、接（三、1）FOLLOWER的syncWithLeader方法"></a>3、接（三、1）FOLLOWER的syncWithLeader方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">protected void syncWithLeader(long newLeaderZxid) throws Exception&#123;</span><br><span class="line">    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);</span><br><span class="line">    QuorumPacket qp = new QuorumPacket();</span><br><span class="line">    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);</span><br><span class="line">    </span><br><span class="line">    QuorumVerifier newLeaderQV = null;</span><br><span class="line">    </span><br><span class="line">    boolean snapshotNeeded = true;</span><br><span class="line">    boolean syncSnapshot = false;</span><br><span class="line">    readPacket(qp);</span><br><span class="line">    LinkedList&lt;Long&gt; packetsCommitted = new LinkedList&lt;Long&gt;();</span><br><span class="line">    LinkedList&lt;PacketInFlight&gt; packetsNotCommitted = new LinkedList&lt;PacketInFlight&gt;();</span><br><span class="line">    synchronized (zk) &#123;</span><br><span class="line">        if (qp.getType() == Leader.DIFF) &#123;</span><br><span class="line">            //无需同步snaphot</span><br><span class="line">            snapshotNeeded = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (qp.getType() == Leader.SNAP) &#123;</span><br><span class="line">            //Leader给follower发送的是SNAP文件</span><br><span class="line">            //follower将SNAP文件替换到内存</span><br><span class="line">            zk.getZKDatabase().deserializeSnapshot(leaderIs);</span><br><span class="line">            ...</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">            syncSnapshot = true;</span><br><span class="line">        &#125; else if (qp.getType() == Leader.TRUNC) &#123;</span><br><span class="line">            //follower废弃大于Zxid的事务</span><br><span class="line">            boolean truncated=zk.getZKDatabase().truncateLog(qp.getZxid());</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());</span><br><span class="line">        //创建Session管理器</span><br><span class="line">        zk.createSessionTracker();            </span><br><span class="line">        long lastQueued = 0;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        boolean isPreZAB1_0 = true;</span><br><span class="line">        //同步SNAP则不需要同步事务</span><br><span class="line">        boolean writeToTxnLog = !snapshotNeeded;</span><br><span class="line">        //开始同步事务</span><br><span class="line">        outerLoop:</span><br><span class="line">        while (self.isRunning()) &#123;</span><br><span class="line">            readPacket(qp);</span><br><span class="line">            switch(qp.getType()) &#123;</span><br><span class="line">            case Leader.PROPOSAL:</span><br><span class="line">                //leader发来的提议</span><br><span class="line">                PacketInFlight pif = new PacketInFlight();</span><br><span class="line">                pif.hdr = new TxnHeader();</span><br><span class="line">                pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);</span><br><span class="line">                //加入到未commit队列</span><br><span class="line">                packetsNotCommitted.add(pif);</span><br><span class="line">                break;</span><br><span class="line">            case Leader.COMMIT:</span><br><span class="line">            case Leader.COMMITANDACTIVATE:</span><br><span class="line">                pif = packetsNotCommitted.peekFirst();</span><br><span class="line">                //已同步snaphot则不需同步事务</span><br><span class="line">                if (!writeToTxnLog) &#123;</span><br><span class="line">                    if (pif.hdr.getZxid() != qp.getZxid()) &#123;</span><br><span class="line">                        LOG.warn(&quot;Committing &quot; + qp.getZxid() + &quot;, but next proposal is &quot; + pif.hdr.getZxid());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //事务处理到内存db</span><br><span class="line">                        zk.processTxn(pif.hdr, pif.rec);</span><br><span class="line">                        packetsNotCommitted.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    packetsCommitted.add(qp.getZxid());</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case Leader.INFORM:</span><br><span class="line">            case Leader.INFORMANDACTIVATE:</span><br><span class="line">                ...                   </span><br><span class="line">                break;                </span><br><span class="line">            case Leader.UPTODATE:</span><br><span class="line">                ...</span><br><span class="line">                self.setZooKeeperServer(zk);</span><br><span class="line">                self.adminServer.setZooKeeperServer(zk);</span><br><span class="line">                //跳出同步数据循环</span><br><span class="line">                break outerLoop;</span><br><span class="line">            case Leader.NEWLEADER: // Getting NEWLEADER here instead of in discovery </span><br><span class="line">                // means this is Zab 1.0</span><br><span class="line">               if (qp.getData()!=null &amp;&amp; qp.getData().length &gt; 1) &#123;</span><br><span class="line">                   try &#123;                       </span><br><span class="line">                       QuorumVerifier qv = self.configFromString(new String(qp.getData()));</span><br><span class="line">                       self.setLastSeenQuorumVerifier(qv, true);</span><br><span class="line">                       newLeaderQV = qv;</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               //将从leader获取到的内存文件保存到磁盘</span><br><span class="line">               if (snapshotNeeded) &#123;</span><br><span class="line">                   zk.takeSnapshot(syncSnapshot);</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">                self.setCurrentEpoch(newEpoch);</span><br><span class="line">                writeToTxnLog = true; //Anything after this needs to go to the transaction log, not applied directly in memory</span><br><span class="line">                isPreZAB1_0 = false;</span><br><span class="line">                //同步数据完成给leader发送确认信息</span><br><span class="line">                writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));</span><br><span class="line">    //同步数据完成给leader发送确认信息</span><br><span class="line">    writePacket(ack, true);</span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.syncLimit);</span><br><span class="line">    //启动FollowerZooKeeperServer</span><br><span class="line">    zk.startup();</span><br><span class="line">    //更新选票事务批次</span><br><span class="line">    self.updateElectionVote(newEpoch);</span><br><span class="line"></span><br><span class="line">    // We need to log the stuff that came in between the snapshot and the uptodate</span><br><span class="line">    if (zk instanceof FollowerZooKeeperServer) &#123;</span><br><span class="line">        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer)zk;</span><br><span class="line">        //处理未投票事务</span><br><span class="line">        for(PacketInFlight p: packetsNotCommitted) &#123;</span><br><span class="line">            fzk.logRequest(p.hdr, p.rec);</span><br><span class="line">        &#125;</span><br><span class="line">        for(Long zxid: packetsCommitted) &#123;</span><br><span class="line">            //处理已投票事务</span><br><span class="line">            fzk.commit(zxid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (zk instanceof ObserverZooKeeperServer) &#123;</span><br><span class="line">        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;</span><br><span class="line">        for (PacketInFlight p : packetsNotCommitted) &#123;</span><br><span class="line">            Long zxid = packetsCommitted.peekFirst();</span><br><span class="line">            if (p.hdr.getZxid() != zxid) &#123;</span><br><span class="line">                // log warning message if there is no matching commit</span><br><span class="line">                // old leader send outstanding proposal to observer</span><br><span class="line">                LOG.warn(&quot;Committing &quot; + Long.toHexString(zxid)</span><br><span class="line">                        + &quot;, but next proposal is &quot;</span><br><span class="line">                        + Long.toHexString(p.hdr.getZxid()));</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            packetsCommitted.remove();</span><br><span class="line">            Request request = new Request(null, p.hdr.getClientId(),</span><br><span class="line">                    p.hdr.getCxid(), p.hdr.getType(), null, null);</span><br><span class="line">            request.setTxn(p.rec);</span><br><span class="line">            request.setHdr(p.hdr);</span><br><span class="line">            ozk.commitRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // New server type need to handle in-flight packets</span><br><span class="line">        throw new UnsupportedOperationException(&quot;Unknown server type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、FollowerZooKeeperServer的setupRequestProcessors方法"><a href="#2、FollowerZooKeeperServer的setupRequestProcessors方法" class="headerlink" title="2、FollowerZooKeeperServer的setupRequestProcessors方法"></a>2、FollowerZooKeeperServer的setupRequestProcessors方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void setupRequestProcessors() &#123;</span><br><span class="line">    RequestProcessor finalProcessor = new FinalRequestProcessor(this);</span><br><span class="line">    commitProcessor = new CommitProcessor(finalProcessor,</span><br><span class="line">            Long.toString(getServerId()), true, getZooKeeperServerListener());</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    firstProcessor = new FollowerRequestProcessor(this, commitProcessor);</span><br><span class="line">    ((FollowerRequestProcessor) firstProcessor).start();</span><br><span class="line">    syncProcessor = new SyncRequestProcessor(this,</span><br><span class="line">            new SendAckRequestProcessor((Learner)getFollower()));</span><br><span class="line">    syncProcessor.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>follower的初始化，到这儿就结束了</p>]]></content>
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/02/21/helloworld/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
